#!/usr/bin/perl
#
# This script creates function stubs and pointers for symbols specified
# from STDIN.
#
# $ Copyright Broadcom Corporation $
#
# <<Broadcom-WL-IPTag/Proprietary:>>
#
# $Id: build-ramfnstub,v 1.6 2010-09-16 16:01:04 lut Exp $
#

use warnings;
use strict;
use Getopt::Std;

my $idre = '([\w$]+)';
my $ifdef = '([^#]+)';
my $fnre = '([\w.-]+)';
my $addr_re = '([0-9a-fA-F]{8})';
my $out_w = 0;
my $fh;

sub usage {
    print STDERR "Usage: build-ramfnstub [-r ram mapfile] [out_w romctl.txt]\n";
    exit 1;
}

# Parse optional command line options.
my %opts;
getopts('r:t:', \%opts);

# Parse the all-RAM map file generated by the 'nm' utility. For ROM offload images, this is used to
# generate a list of all symbols used by a particular build. If a function is not used, but a
# RAM function stub exists for it, the RAM function stub is set to reference hnd_unimpl().
# This saves RAM memory by eliminating the need to include the function (and its associated
# call chain) from the ROM offload image.
#
# The format of the input file is:
#
# 00000148 T enable_arm_ints
# 00000184 T disable_arm_ints
my %sym_exists;
my $exclude_unused_func_stubs = 0;
if ($opts{r}) {
   my $fname_all_ram_mapfile = $opts{r};
   my ($fd);

   $exclude_unused_func_stubs = 1;

   # Open map file.
   open($fd, "<$fname_all_ram_mapfile") or
      die "Could not open $fname_all_ram_mapfile for reading: $!\n";

   map {
       $sym_exists{$2} = 1 if /${addr_re} . ${idre}$/;
   } <$fd>;
   close $fd;
}

if ($opts{t}) {
   my $fname_target_cfg = $opts{t};
   my ($fd);

   # Open map file.
   open($fd, "<$fname_target_cfg") or
      die "Could not open $fname_target_cfg for reading: $!\n";

   map {
      $sym_exists{$1} = 1 if /^${idre}\s+KEEP\b/;
   } <$fd>;
   close $fd;
}


# RAM fn pointer prefix
my $g_ramfnptr_prefix = "__ramfnptr_";
$out_w = shift @ARGV if ($ARGV[0]);

# read all symbols from STDIN
my @symbols = ();

# Outputs ramfnstub.w with ifdef flags from romctl.txt
if ($out_w == 1) {
   my $fname_ctl = shift @ARGV if ($ARGV[0]);
   my %ramfns = ();

   $fname_ctl = "romctl.txt" if (!$fname_ctl);
   if (-e $fname_ctl) {
      open($fh, $fname_ctl) or die "Could not open $fname_ctl for reading: $!\n";
      map {
         $ramfns{$1} = $2 if /^${idre}\s.*\bramfp_exclude_sym\s+${ifdef}/;
      } <$fh>;
      close $fh;
   }

   map {
      push (@symbols, $1) if /\b$g_ramfnptr_prefix${idre}$/;
   } <STDIN>;

   foreach(@symbols) {
      if (!$ramfns{$_}) {
          printf("$_\n");
          next;
      }

      my $a = $ramfns{$_};
      $a =~ s/^\s+//;
      $a =~ s/\s+$//;

      printf("#$a\n");
      printf("$_\n");
      printf("#endif\n");
   }

   exit 0;
}

# Outputs ramfnstub.S
map {
   push (@symbols, $1) if /^${idre}$/;
} <STDIN>;

# banner
printf("/*\n");
printf(" * DO NOT MODIFY! THIS IS GENERATED BY SCRIPT src/dongle/make/scripts/build-ramfnstub.\n");
printf(" *\n");
printf(" * Stub functions and function pointers for RAM functions called from ROM.\n");
printf(" */\n");
printf("\n");

### ARCH: ARM ###
printf("#if defined(__arm__)\n");
printf("\n");

### MODE: THUMB ###
printf("#if defined(__thumb__) || defined(__thumb2__)\n");
printf("\n");

# macros
printf("/* mark start/end of routine. */\n");
printf("#if !defined(BCMROMOFFLOAD)\n");
printf("#define FUNC(_fn) \\\n");
printf("	.global _fn; \\\n");
printf("	.func _fn; \\\n");
printf("	.thumb_func; \\\n");
printf("	.section .textrom._fn, \"ax\"; \\\n");
printf("_fn:\n");
printf("#define END(_fn) \\\n");
printf("	.endfunc; \\\n");
printf("	.size _fn, . - _fn\n");
printf("#endif /* !BCMROMOFFLOAD */\n");
printf("\n");

# RAM function table
printf("/* RAM function pointer table */\n");
printf("#ifdef BCMROMOFFLOAD\n");
for (my $s = 0; $s < @symbols; $s ++) {
    printf("	.extern %s\n", $symbols[$s]);
    printf("	.global %s%s\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.section .data.%s%s, \"aw\"\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.type %s%s, %%object\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.size %s%s, 4\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("%s%s:\n", $g_ramfnptr_prefix, $symbols[$s]);
    if ($exclude_unused_func_stubs && !$sym_exists{$symbols[$s]}) {
       printf("	.word	hnd_unimpl\n");
    }
    else {
       printf("	.word	%s\n", $symbols[$s]);
    }
    printf("\n");
}
printf("#else\n");
for (my $s = 0; $s < @symbols; $s ++) {
    printf("	.global %s%s\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.section .ramfnptr.%s%s, \"aw\"\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.type %s%s, %%object\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.size %s%s, 4\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("%s%s:\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.word	0\n");
    printf("\n");
}
printf("\n");

# generate stubs
printf("/* RAM function stubs */\n");
printf("\n");
for (my $s = 0; $s < @symbols; $s ++) {
    printf("FUNC(%s)\n", $symbols[$s]);
    printf("	push	{r4,lr}\n");
    printf("	ldr	r4,=%s%s\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	ldr	r4,[r4]\n");
    printf("	str	r4,[sp,#4]\n");
    printf("	pop	{r4,pc}\n");
    printf("END(%s)\n", $symbols[$s]);
    printf("\n");
}
printf("#endif /* !BCMROMOFFLOAD */\n");
printf("\n");

### MODE: ARM ###
printf("#else /* !__thumb__ && !__thumb2__ */\n");
printf("\n");
printf("/* mark start/end of routine. */\n");
printf("#define FUNC(_fn) \\\n");
printf("	.global	_fn; \\\n");
printf("	.func _fn; \\\n");
printf("	.section .textrom._fn, \"ax\"; \\\n");
printf("_fn:\n");
printf("#define END(_fn) \\\n");
printf("	.endfunc; \\\n");
printf("	.size _fn, . - _fn\n");
printf("\n");

# RAM function table
printf("/* RAM function table */\n");
printf("#ifdef BCMROMOFFLOAD\n");
for (my $s = 0; $s < @symbols; $s ++) {
    printf("	.global %s%s\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.section .data.%s%s, \"aw\"\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("%s%s:\n", $g_ramfnptr_prefix, $symbols[$s]);
    if ($exclude_unused_func_stubs && !$sym_exists{$symbols[$s]}) {
       printf("	.extern	hnd_unimpl\n");
       printf("	b	hnd_unimpl\n");
    }
    else {
       printf("	.extern	%s\n", $symbols[$s]);
       printf("	b	%s\n", $symbols[$s]);
    }
    printf("\n");
}
printf("#else\n");
printf("\n");
for (my $s = 0; $s < @symbols; $s ++) {
    printf("	.global %s%s\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.section .ramfnptr.%s%s, \"aw\"\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("%s%s:\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("	.word	0\n");
    printf("\n");
}

# generate stubs
printf("/* RAM function stubs */\n");
for (my $s = 0; $s < @symbols; $s ++) {
    printf("FUNC(%s)\n", $symbols[$s]);
    printf("	b	%s%s\n", $g_ramfnptr_prefix, $symbols[$s]);
    printf("END(%s)\n", $symbols[$s]);
    printf("\n");
}
printf("#endif /* BCMROMOFFLOAD */\n");
printf("\n");

printf("#endif /* !__thumb__ && !__thumb2__ */\n");
printf("\n");

### ARCH: xxx ###
printf("#else /* !__arm__ */\n");
printf("\n");
printf("#error Unknown architecture\n");
printf("\n");
printf("#endif /* __arm__ */\n");
