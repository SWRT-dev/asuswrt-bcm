#!/usr/bin/perl
#
# This script outputs .S for symbols in an object or a tgz of objects.
#
# $ Copyright Broadcom Corporation $
#
# <<Broadcom-WL-IPTag/Proprietary:>>
#
# $Id: gen-romdasm,v 1.3 2010-08-30 23:56:05 csm Exp $
#

use strict;
use warnings;

use IO::Seekable;
use File::Path;
use File::Basename;
use File::Copy;
use Getopt::Std;

# Disassemble patch symbols instead of those from the ROM table.
my $g_disas_patch_syms;
my $g_patch_sym_regexp;

# Optional output filename.
my $g_fname_out = "nil";
my $g_fname_ext_in = ".o.nopt";
my $g_fname_ext_out = ".o.nopt.disas.lst";

# Parse optional command line options.
my %g_opts;
getopts('po:e:i:', \%g_opts);
if ($g_opts{p}) {
	$g_disas_patch_syms = 1;
	$g_patch_sym_regexp = qr/\w+__auto_patch__\w+/;
}
if ($g_opts{o}) {
	$g_fname_out = $g_opts{o};
}
# input object files name extension -i ".o"
if ($g_opts{i}) {
	$g_fname_ext_in = $g_opts{i};
}
# output object files name extension -e ".lst"
if ($g_opts{e}) {
	$g_fname_ext_out = $g_opts{e};
}

if (@ARGV < 1) {
	print "Usage: perl gen-romdasm [-p] [-o fname_out] [-e fname_ext]\n";
	print "                        <rom-table-file-path> <object|tgz>\n";
	print "                        <dir-out> <objdump> <jtfull> <skip_abn>\n";
	exit 1;
}

my $fnromtbl = $ARGV[0];
my $inFile = $ARGV[1];
my $romSdir = $ARGV[2];
my $objdump = $ARGV[3];
my $jmptbl_full = $ARGV[4];
my $skip_abandons = $ARGV[5];

my @objects = ();
my $script = basename($0);

my $g_display_stats = 0;
my @bans = ();
my @dups = ();
my @undefs = ();


# if changing $g_romfn_subfix, need to update replace-rommap
my $g_romfn_subfix = "__bcmromfn";
my $g_romdat_subfix = "__bcmromdat";
my $g_romdat_patch_subfix = "__bcmromdat";
my $data_sect = "datarom";
my $rodata_sect = "datarom";
my $text_sect = "textrom";

if ($jmptbl_full == 1) {
	$data_sect = "data";
	$rodata_sect = "rodata";
	$text_sect = "text";
	$g_romfn_subfix = "";
	$g_romdat_subfix = "";
}

# Regular expression search strings.
my $g_str_label_regexp = '\.LC[0-9]+';
my $g_str_label_offset_regexp = '<\.LC[0-9]+(\+0x[0-9a-fA-F]+)?>';
my $g_sym_regexp = '([\w$]+)';

# Symbols generated by compiler for "__FUNCTION__" strings.
my $g_func_str_regexp = qr/__FUNCTION__\.\d+/;

# Symbols used to index EVENT_LOG strings.
my $g_eventlog_fmtnum_regexp = qr/fmtnum\.\d+/;

# Special linker sections used for storing EVENT_LOG strings and offsets.
my $g_lognums_sect = ".lognums";
my $g_logstrs_sect = ".logstrs";


# Symbols generated by compiler for initialized *local* variables (arrays and structs).
#
# For static, local initialized arrays and structs, the compiler creates a read-only data section
# for the initialization data. A random-numbered suffix is added to the variable name (to be
# globally unique).
#
# e.g. 'my_var1.1234' for the following local variable:
#
#    static const uint8 my_var1[] = {0xaa, 0xbb, 0xcc, 0xdd};
#
# Similarly, the compiler creates a read-only data section for the initialization data of
# non-static locals. The name of the data section is C.xxx.xxx.
#
# e.g. 'C.1234.5678' for the following local variable:
#
#    const uint8 my_var2[] = {0x11, 0x22, 0x33, 0x44};
#
# (Use negative look-ahead regular expression to exclude function strings, '__FUNCTION__.xxx' and
# event log symbols 'fmtnum.xxx').
my $g_local_var_regexp = qr/^(?!$g_func_str_regexp|$g_eventlog_fmtnum_regexp)(?:C\.\d+\.\d+|\w+\.\d+)/;


if ($objdump eq "") {
	$objdump = "/projects/hnd/tools/linux/hndtools-armeabi-2007q3/bin/arm-none-eabi-objdump";
}

eval { mkpath($romSdir) };
if ($@) {
	print "Couldn't create $romSdir: $@";
}

# Create a array of objects to process, based on either a tgz input,
# or a single object file.
my ($filename, $extension) = split(/\./, basename($inFile), 2);
if ($extension eq "tgz")
{
	my $DIR;
	my $tmpobjpath = "$romSdir/tmpobjs";

	# old romdasm script assumed clean path
	rmtree($romSdir);

	eval { mkpath($tmpobjpath) };
	if ($@) {
		print "Couldn't create $tmpobjpath: $@";
	}

	# extract the files
	exit(2) if system("tar zxf $inFile -C $tmpobjpath");

	# Get a list of the extracted objects
	opendir(DIR, $tmpobjpath) or die $!;
	my @files = readdir(DIR);
	closedir(DIR);

	# Need relative path of extracted ojects
	foreach my $f (@files) {
		if ($f ne "." && $f ne "..") {
			push(@objects, "$tmpobjpath/$f");
		}
	}

	# Display summary stats.
	$g_display_stats = 1;
} else {
	push(@objects, $inFile);
}

# Assembly Potential Violation Rules
my @asm_rules = (
	qr{R_ARM_ABS32\s+\.rodata\.C\.},
	);

# Ignore Rules
my @exclude_rules = (
	qr{file format elf32-littlearm},
	);

my @matched = ();


# Read a string from a location in an object file.
#
# Note that the source code may use "strings" for byte arrays. e.g.
#
#     #define WAPI_OUI   "\x00\x14\x72"  /* WAPI OUI */
#
# These byte array "strings" may use a NULL value for bytes other than termination. Therefore,
# the length of strings cannot be determined based upon the NULL termination character. As a
# result, this function takes a string length as a parameter. This will be used to read the
# specified number of bytes from the object file.
#
# Params: FH:   IN  Object file handle.
#         addr: IN  Address to start reading the string.
#         len:  IN  Length of string.
#
# Returns: String.
sub get_str_from_obj {
	my ($FH, $addr, $len) = @_;
	my $str;
	my $buffer;

	# If 'len' is -1 read a real NULL terminated string.
	if ($len == -1) {
		# Set input record separator to NULL.
		local $/ = "\0";

		# Read string.
		seek(FH, $addr, SEEK_SET)
			or die "Seek error: $!\n";
		$str = <FH>;

		# remove the trailing zero - may make string null
		chomp($str);
	}
	else {
		# The "string" may be a real NULL terminated string, or a byte array.

		# Read string at specified address.
		seek(FH, $addr, SEEK_SET)
			or die "Seek error: $!\n";

		read(FH, $buffer, $len);

		# Test if read buffer is ASCII.
		if ($buffer =~ /^(?!\0)[[:ascii:]]{$len}/) {
			$str = $buffer;
		}
		else {
			# The read buffer contains non-ASCII characters. Treat it as a byte array,
			# and create a string based upon the hex representation, e.g. "\x00\x14\x72".
			my @str_array = unpack('C*', $buffer);
			foreach my $c (@str_array) {
				$str .= "\\x" . sprintf ("%02x", $c);
			}
		}
	}

	return ($str);
}


# Write a 32 bit integer in little endian to an object file
#
# Params: FH  : IN  Object file handle
#         addr: IN  Address of the integer
#         word: IN  Integer to write
#
# Returns: Nothing
sub set_int32_from_obj {
	my ($FH, $addr, $word) = @_;
	my $w;

	binmode(FH);
	seek(FH, $addr, SEEK_SET)
		or die "Seek error: $!\n";

	# pack into little endian bytes
	$w = pack("V", $word);

	# output to seek location
	printf FH $w;
}

# Get a 32 bit integer in from an object file
#
# Params: FH  : IN  Object file handle
#         addr: IN  Address of the integer
#
# Returns: Integer value
sub get_int32_from_obj {
	my ($FH, $addr) = @_;
	my $word;
	my $w;

	binmode(FH);
	seek(FH, $addr, SEEK_SET)
		or die "Seek error: $!\n";

	# Extract 4 bytes from the file
	read(FH, $word, 4)
		or die "Read error: $!\n";

	# Format is little endian, upack the bytes
	$w = unpack("V", $word);
	return $w;
}

# Retrieve the strings for all string pointers that are referenced by a .rodata section.
#
# Must have labels in the format similar to:
#   0: R_ARM_ABS32  .rodata
#
# Params: file:         IN  Object file
#         section:      IN  Section to parse pointers
#         section_addr: IN  Address of section in object file
#         rodata_addr:  IN  Address of .rodata in object file
#         clear:        IN  Modify the object file to zero the pointer offset
#         str_table:    OUT A hash of offsets and strings
#         str_addrs:    OUT Hash of string addresses.
#
# Returns: Nothing
sub get_rodata_str_pointers {
	my ($file, $section, $section_addr, $rodata_addr, $clear, $str_table, $str_addrs) = @_;
	my @inS;
	my $line;
	my $offset;
	my $offset_addr;
	my $FH;

	# Get a list of .rodata pointer labels
	@inS = `$objdump -r --section=\"$section\" $file | grep 'R_ARM_ABS32.*\.rodata'`;

	# Open the object to read and modify
	open(FH, "+<",$file)
		or die "Cannot open $file: $!\n";

	foreach $line (@inS) {
		my @b = split(/\s+/, $line);
		$offset = hex("0x$b[0]");

		# Extract the pointers .rodata reference
		$offset_addr = get_int32_from_obj($FH, $offset + $section_addr);

		# Different rodata sections may reference the same string pointer.
		if (!exists($str_addrs->{$offset_addr})) {
			# Set the string label name to "anonymous" since the compiler does not
			# assign string labels (e.g. .LCxx) for string pointers referenced by rodata.
			$str_addrs->{$offset_addr} = "anonymous";
		}

		# Get the string from .rodata
		$str_table->{$offset} = get_str_from_obj($FH, $rodata_addr + $offset_addr, -1);

		# remove the .rodata pointer reference from the object as these will mismatch
		if ($clear == 1) {
			set_int32_from_obj($FH, $offset + $section_addr, 0);
		}
	}

	close(FH);
}


# Retrieve all strings referenced by all functions in an object file.
#
# Params: file:        IN  Object file
#         addrs:       IN  A hash that maps string address to string label names.
#         lens:        IN  A hash that maps string labels to string lengths.
#         rodata_addr: IN  Address of .rodata in object file
#         str_table:   OUT A hash of labels and strings
#
# Returns: Nothing
sub get_func_str_labels {
	my ($file, $addrs, $lens, $rodata_addr, $str_table) = @_;
	my $label;
	my $addr;
	my $FH;

	# Clear the hash table of strings.
	%{$str_table} = ();

	open(FH, "+<", $file)
		or die "Cannot open $file: $!\n";

	foreach $addr (keys %{$addrs}) {
		my $label = $addrs->{$addr};
		if ($label =~ /${g_str_label_regexp}/) {
			$str_table->{$label} = get_str_from_obj($FH, $addr + $rodata_addr,
			                                        $lens->{$label});
		}
	}

	close(FH);
}


# Retrieve all EVENT_LOG strings referenced by all functions in an object file.
#
# The EVENT_LOG feature is used to record driver events in dongle memory. It uses a macro of the
# format:
#         EVENT_LOG(id, fmt_string, ...)
# where 'fmt_string' is a printf style format string, '...' are the printf parameters.
#
# The actual format strings are not included in the dongle image. They are saved to a special linker
# section '.logstrs' and extracted to a file (logstrs.bin). This file also contains the special
# section '.lognums' which contains the offset of each format string in '.logstrs'. Each
# offset within '.lognums' is saved in a symbol called 'fmtnum.xxx'. The index of 'fmtnum.xxx'
# gets saved into dongle memory by EVENT_LOG().
#
# The EVENT_LOG strings are used to replace references to 'fmtnum.xxx' in the disassembly with
# the actual string. Therefore, if a string changes post tape-out it will be detected when
# comparing ROM and RAM and the referencing function will be invalidated from ROM.
#
# Params: file:         IN  Object file
#         fmtnum_addrs: IN  A hash that maps EVENT_LOG 'fmtnum.xxx' symbol names to addresses within
#                           the '.lognums' section.
#         lognums_addr: IN  Address of '.lognums' section in object file
#         logstrs_addr: IN  Address of '.logstrs' section in object file
#         evtlog_strs:  OUT A hash that maps EVENT_LOG 'fmtnum.xxx' symbol name to string.
#
# Returns: Nothing
sub get_evtlog_func_strs {
	my ($file, $fmtnum_addrs, $lognums_addr, $logstrs_addr, $evtlog_strs) = @_;
	my $fmtnum;
	my $FH;

	# Clear the hash table of strings.
	%{$evtlog_strs} = ();

	open(FH, "+<", $file)
		or die "Cannot open $file: $!\n";

	foreach $fmtnum (keys %{$fmtnum_addrs}) {
		my $logstr_offset;

		# Extract the offset within '.logstrs' of the EVENT_LOG string.
		$logstr_offset = get_int32_from_obj($FH, $fmtnum_addrs->{$fmtnum} + $lognums_addr);

		# Extract the EVENT_LOG string.
		$evtlog_strs->{$fmtnum} = get_str_from_obj($FH, $logstr_offset + $logstrs_addr, -1);
	}

	close(FH);
}


# Retrieve all strings addresses referenced by all functions in an object file.
#
# Params: file:         IN  Object file
#         addrs:        OUT A hash that maps string address to string label names.
#         fmtnum_addrs: OUT A hash that maps EVENT_LOG 'fmtnum.xxx' symbol names to addresses within
#                           the '.lognums' section.
#
# Returns: Nothing
sub get_func_str_addrs {
	my ($file, $addrs, $fmtnum_addrs) = @_;
	my @inS;
	my $line;

	# Clear the hash table of addresses.
	%{$addrs} = ();

	# Get a list of all function string labels in the object file
	@inS = `$objdump -t $file`;


	# Parse objdump symbol table. The format is:
	#
	# 00003410 l       .rodata   00000000 .LC546
	# 00000020 l     O .lognums  00000004 fmtnum.18519
	foreach $line (@inS) {
		my @words = split(/\s+/, $line);
		my $addr = $words[0];
		my $sym  = $words[$#words];

		if (defined($sym)) {
			# Save addresses for string label symbols.
			if ($sym =~ /${g_str_label_regexp}/) {
				$addrs->{hex("0x$addr")} = $sym;
			}
			# Save addresses for EVENT_LOG symbols.
			elsif ($sym =~ /${g_eventlog_fmtnum_regexp}/) {
				$fmtnum_addrs->{$sym} = hex("0x$addr");
			}
		}
	}
}


# Retrieve all string lengths referenced by all functions and rodata in an object file.
#
# Params: addrs: IN  A hash that maps string address to string label names.
#         lens:  OUT A hash that maps string labels to string lengths.
#
# Returns: Nothing
sub get_str_lens {
	my ($addrs, $lens) = @_;
	my $found_label = 0;
	my $prev_label;
	my $prev_label_addr;

	# Clear the hash table of string lengths.
	%{$lens} = ();

	# Calculate delta string addresses to determine the string lengths. Store string lengths
	# in a hash table.
	for my $addr (sort { $a <=> $b } keys %{$addrs}) {
		my $label = $addrs->{$addr};

		if ($found_label) {
			my $len = $addr - $prev_label_addr;
			$lens->{$prev_label} = $len;
			$found_label = 0;
		}

		if ($label =~ /${g_str_label_regexp}/) {
			$found_label = 1;
			$prev_label = $label;
			$prev_label_addr = $addr;
		}
	}
}


# Get section specific information (name, addr, size etc) for an object file.
#
# Params: file:         IN  Object file.
#         sections:     OUT Hash that maps section names to addresses.
#         sizes:        OUT Hash that maps section names to sizes.
#         rodata_sects: OUT Array of all rodata sections.
#
# Returns: Nothing.
sub get_section_info {
	my ($file, $sections, $sizes, $rodata_sects) = @_;
	my (@inS, $addr, $ident, $line, $size);

	# Clear the section info.
	%{$sections}     = ();
	%{$sizes}        = ();
	@{$rodata_sects} = ();


	# Parse objdump section header. The format is:
	#
        #   Idx Name          Size      VMA       LMA       File off  Algn
        #     0 .text         00000000  00000000  00000000  00000034  2**1
        #                     CONTENTS, ALLOC, LOAD, READONLY, CODE
        #     1 .data         00000000  00000000  00000000  00000034  2**0
        #                     CONTENTS, ALLOC, LOAD, DATA
	#   ...
	@inS = `$objdump -h $file`;
	foreach $line (@inS) {
		# trim the start and trailing whitespace from line
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		if ($line =~ /\s+[0-9]/) {
			my @b = split(/\s+/, $line);
			$addr = hex("0x$b[5]");
			$size  = hex("0x$b[2]");
			$ident = $b[1];
			# need to escape the $ symbols in static variable sections
			if ($ident =~ /\$/) {
				my ($f, $s) = split(/\$/, $ident);
				$ident = "$f\\\$$s";
			}
			$sections->{$ident} = $addr;
			$sizes->{$ident}	= $size;

			# Create an array of rodata sections. Exclude function strings.
			if ($ident =~ /\.($rodata_sect|$data_sect)\.(.*)/) {
				if ($ident !~ /$g_func_str_regexp/) {
					push(@{$rodata_sects}, $ident);
				}
			}
		}
	}
}

# Scan line against @asm_rules
sub scan_violations {
	my($sym, $line) = @_;

	foreach(@asm_rules) {
		if ($line =~ /$_/) {
			chop($line);
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			push(@matched, "$sym: $line");
		}
	}
}

# Scan line against @exclude_rules
sub scan_excludes {
	my($line) = @_;

	foreach(@exclude_rules) {
		if ($line =~ /$_/) {
			return 1;
		}
	}
	return 0;
}

# Function does the following:
#   1. Filter .S to prevent false mismatches between ROM and RAM disassembly.
#   2. Scans .S for potential assembly violations
#   3. Scan rules to exclude from output
#
# Params: sym:             IN  Symbols name.
#         strs:            IN  Hash that maps function string labels (e.g. .LCxx) to strings.
#         pstrs:           IN  Hash that maps rodata address offsets to strings.
#         evtlog_strs:     IN  Hash that maps EVENT_LOG 'fmtnum.xxx' symbol name to string.
#         local_var_disas: IN  Hash that maps local variable initialization data section name to
#                              its disassembly.
#         inS:             MOD Disassembly to be filtered.
#
# Returns: Nothing.
sub postprocess_asm {
	my($sym, $strs, $pstrs, $evtlog_strs, $local_var_disas, @inS) = @_;
	my @outS = ();
	my @append_sym_disas;
	my %is_appended_sym_disas;

	for (my $d = 0; $d < $#inS+1; $d ++) {
		if (scan_excludes($inS[$d])) {
			next;
		}

		if ($inS[$d] =~ /bl\s+0\s+<$sym>/) {
			# There is a disassembler quirk, related to whether a function that's being
			# called is in the same file as the caller or not. e.g. When wlc_sendctl()
			# calls wlc_send_q() and both are in the same file, the function annotated
			# in the branch instruction is misleadingly the calling function. The actual
			# called function is correctly specified in the relocation record on the
			# following line:
			#
			#    11e:    f7ff fffe     bl    0 <wlc_sendctl>
			#                          11e: R_ARM_THM_CALL    wlc_send_q
			#
			# When the called function is in a different file, both the branch
			# instruction and the relocation record specify the called function, e.g.
			#
			#    d2:f7ff fffe          bl    0 <wlc_apps_psq>
			#                          d2: R_ARM_THM_CALL     wlc_apps_psq
			#
			# Replace the function annotated in the branch instruction to be the
			# called function, e.g.
			#
			#    11e:    f7ff fffe     bl    0 <wlc_send_q>
			#                          11e: R_ARM_THM_CALL    wlc_send_q
			#
			# This prevents the caller from being unnecessarily invalidated from ROM
			# when the called function is moved to a new source file.
			if ($inS[$d+1] =~ /R_ARM_THM_CALL\s+$g_sym_regexp/) {
				my $called_func = $1;
				# Avoid replacement for recursive calls.
				if ($sym ne $called_func) {
					$inS[$d] =~ s/$sym/$called_func/g;
				}
			}

		} elsif ($inS[$d] =~ /R_ARM.*\s+(${g_eventlog_fmtnum_regexp})/) {
			# Replace EVENT_LOG 'fmtnum.xxx' symbols with the actual string,
			# e.g. replace:
			#
			#     10: R_ARM_THM_MOVT_ABS	fmtnum.12345678
			#
			# with:
			#
			#     10: R_ARM_THM_MOVT_ABS	'EVENT_LOG_STR(disable timer expired (%d, %d ms))'
			#
			# Tag replaced string with 'EVENT_LOG_STR' so that it can be easily
			# searched/identified.
			my $replacement;
			if (exists $evtlog_strs->{$1}) {
				$replacement = "EVENT_LOG_STR(" . $evtlog_strs->{$1} . ")";
			} else {
				die "$script: ERROR: could not find fmtnum '$1' for $sym";
			}
			$inS[$d] =~ s/${g_eventlog_fmtnum_regexp}/\'$replacement\'/;
		} elsif ($inS[$d] =~ /R_ARM_ABS32\s+\.(data|rodata)\..+\.[0-9]+/) {
			# Replace random-numbered symbol suffixes with 00000000
			# Ex. 75c: R_ARM_ABS32 .rodata.__FUNCTION__.41932
			# Ex. 54: R_ARM_ABS32 .data.maxsp.35811

			$inS[$d] =~ s/\.[0-9]+/\.00000000/g;
		} elsif ($inS[$d] =~ /R_ARM.*\s+(.*\.[0-9]+)/) {
			my $data_sym = $1;
			# Replace random-numbered symbol suffixes with 00000000
			#
			# e.g. 16:  R_ARM_THM_MOVW_ABS_NC       maxsp.46813
			#      204: R_ARM_THM_MOVW_ABS_NC      __FUNCTION__.25598
			$inS[$d] =~ s/\.[0-9]+/\.00000000/g;


			# Keep track of functions that have local initialized arrays and structs.
			# The disassembly of the initialization data will be appended to the end
			# of the function disassembly (to be able to detect changes in init data).
			if (defined($local_var_disas) && ($data_sym =~ /$g_local_var_regexp/)) {

				# Use an array to keep track of local variable initializations in
				# order to preserve the order in which they occur in the function
				# disassembly (for comparison purposes between ROM/RAM).
				# (The initialization data may be referenced multiple
				# times by the function disasembly, so avoid appending duplicates).
				if (!$is_appended_sym_disas{$data_sym}) {
					$is_appended_sym_disas{$data_sym} = 1;
					push(@append_sym_disas, $data_sym);
				}
			}
		} elsif ($inS[$d] =~ /Disassembly of section\s+\.(rodata|data)\.$sym/) {
			# Replace random-numbered symbol suffixes with 00000000 in the
			# disassembly header of local variable initialization data.
			#
			# e.g. replace:
			#
			# Disassembly of section .rodata.hex.12345678:
			#
			# with:
			#
			# Disassembly of section .rodata.hex.00000000:
			if ($sym =~ /$g_local_var_regexp/) {
				$inS[$d] =~ s/\.[0-9]+/\.00000000/g;
			}
		} elsif ($inS[$d] =~ /<$sym>:/) {
			# Replace random-numbered symbol suffixes with 00000000 in the
			# disassembly header of local variable initialization data.
			#
			# e.g. replace:
			#
			# 00000000 <hex.12345678>:
			#
			# with:
			#
			# 00000000 <hex.00000000>:
			if ($sym =~ /$g_local_var_regexp/) {
				$inS[$d] =~ s/\.[0-9]+/\.00000000/g;
			}
		} elsif ($inS[$d] =~ /R_ARM.*\s+.*(${g_str_label_regexp})/) {
			# Replace string labels (.LCxx) with the actual string,
			# e.g. replace:
			#
			#     1e: f240 0000  movw r0, #0
			#     1e: R_ARM_THM_MOVW_ABS_NC .LC10
			#
			# with:
			#
			#     1e: f240 0000 movw r0, #0
			#     1e: R_ARM_THM_MOVW_ABS_NC 'FUNC_STR(foo)'
			#
			# Tag replaced string with 'FUNC_STR' so that it can be easily
			# searched/identified.
			my $replacement;
			if (exists $strs->{$1}) {
				$replacement = "FUNC_STR(" . $strs->{$1} . ")";
			} else {
				die "$script: ERROR: could not find string $1 for $sym";
			}
			$inS[$d] =~ s/${g_str_label_regexp}/\'$replacement\'/;
		} elsif ($inS[$d] =~ /\s+([0-9a-f]+)\: R_ARM_ABS32\s+\.rodata/) {
			# Replace rodata string pointer relocation entry with the actual string,
			# e.g. replace:
			#
			# 0: R_ARM_ABS32 .rodata
			#
			# with:
			#
			# 0: R_ARM_ABS32 'RODATA_STR(bar)'
			#
			# Tag replaced string with 'RODATA_STR' so that it can be easily
			# searched/identified.
			my $offset = hex ("0x$1");
			if (exists $pstrs->{$offset}) {
				my $replacement = "RODATA_STR(" . $pstrs->{$offset} . ")";
				$inS[$d] =~ s/\.rodata/\'$replacement\'/;
			} else {
				die "$script: ERROR: could not find pointer string $1 for $sym";
			}
		} elsif ($inS[$d] =~ /Disassembly of section \.textini[1-3]\./) {
			# Filter out reclaimable text section name,
			# e.g. replace:
			#
			# Disassembly of section .textini2.foobar:
			#
			# with:
			#
			# Disassembly of section .text.foobar:
			#
			# This allows comparison of functions in ROM that have been changed to
			# BCMATTACHDATA in RAM.
			$inS[$d] =~ s/\.textini[1-3]\./.text./;
		} elsif ($inS[$d] =~ /Disassembly of section \.dataini[1-3]\./) {
			# Filter out reclaimable data section name,
			# e.g. replace:
			#
			# Disassembly of section .dataini2.foobar:
			#
			# with:
			#
			# Disassembly of section .rodata.foobar:
			#
			# This allows comparison of functions in ROM that have been changed to
			# BCMATTACHDATA in RAM.
			$inS[$d] =~ s/\.dataini[1-3]\./.rodata./;
		} elsif ($inS[$d] =~ /(.*b[a-z]*\.[n,w]\s+)[0-9a-fA-F]+\s+<.*>/) {
			# Strip informational label offsets associated with branch instructions
			# to avoid false mismatches between ROM and RAM. It is sufficient to compare
			# the hex instruction value. There are a few sources that cause issues:
			#
			# 1) Strip string offset labels (<.LCxx+xx>). There appears to be an issue
			#    with the disassembler that causes it to incorrectly output a branch
			#    offset relative to a string label (.LCxx) instead of the current
			#    function.
			#
			# e.g. replace:
			#
			#     17a2: e009   b.n   3022 <.LC547+0x16>
			#
			#  with:
			#
			#     17a2: e009   b.n
			#
			# 2) Similarly, strip 'logstr' offset labels that suffer from the same issue.
			#
			# e.g. replace:
			#
			#   1fa:  e015     b.n   30a <logstr.10100+0xa>
			#
			#  with:
			#
			#   1fa:  e015     b.n
			#
			# 3) There are some cases where the offset value is incorrect (based upon
			#    a manual decode of the hex instruction), and different incorrect
			#    values are included in the disasembly for ROM and RAM (even though
			#    the value of the hex instruction is the same).
			#
			# replace:
			#
			#   3fa:  e0a8     b.n   1dc <wlc_awdl$awdl_do_election+0x1dc>
			#
			# with:
			#
			#   3fa:  e0a8     b.n
			#
			# 4) In some cases, the diassembler will incorrectly use a string offset
			#    label (see #1) for the ROM or RAM disassembly, and then use the proper
			#    function offset label for the other, resulting in a false mismatch.
			#
			$inS[$d] = $1 . "\n";
		}


		scan_violations($sym, $inS[$d]);
		push(@outS, $inS[$d]);
	}


	# The initialization data associated with local variables (arrays and structs) is not
	# embedded in the function disassembly by default. The compiler creates special read-only
	# data sections for the initialization data, and the functions reference these generated
	# sections.
	#
	# Therefore, manually append the local initialization data disassembly to the end of the
	# function disassembly. This allows changes to the initialization data to be detected when
	# comparing ROM/RAM.
	foreach my $data_sym (@append_sym_disas) {

		# Error check.
		if (!defined($local_var_disas->{$data_sym})) {
			die("$script: ERROR: '$sym' references undefined '$data_sym' \n");
		}

		# Append the local initialization data disassembly.
		foreach my $line (@{$local_var_disas->{$data_sym}}) {

			# Ensure that the local initialization data does not contain pointers
			# to functions or pointers to other initialization data. This is not
			# supported. (Pointers to strings are ok). Data with pointers to other
			# data or functions is only supported for global variables in the ROM auto
			# abandon system.
			if ($line =~ /\s+[0-9a-f]+:\s+R_ARM\w+\s+(.*)/) {
			        my $data_ptr = $1;
			        if ($data_ptr !~ /RODATA_STR/) {
			        	die("$script: ERROR: In function '$sym()', local intialization " .
					    "data section '$data_sym' has pointer to function or data " .
					    "'$data_ptr'. ROMing does not support array and struct local " .
					    "variable initialization data with pointers to other " .
					    "arrays, structs or functions.\n");
			        }
			}

			# Append the local initialization data disassembly.
			push(@outS, $line);
		}
	}


	return @outS;
}

# Parse romtable file, produces a hash indexed by object file name and symbol type (rodata/func).
# The hash value is an array of symbols.
#
# Params: romtable:    IN  romtable file
#         elements:    OUT hash representation of romtable
#         no_abandons: IN  should abandons be skipped?
#         objname:     IN  Optional argument to only parse romtable until specified object is found
#         rodata_syms: OUT Hash of all all rodata symbols.
#
# Returns: nothing
sub parse_romtable {
	my ($romtable, $elements, $no_abandons, $objname, $rodata_syms) = @_;
	my $fname = undef;
	my $tag;
	my $FH;
	my %symbols = ();

	open($FH, "<$romtable") or die "Unable to open file $romtable: $!\n";
	while (<$FH>) {
		my $ext;
		s/^\s+//;
		s/\s+$//;

		if (/^#\s*.*\.o/) {
			# If the object heading is not the first one, then we have found the
			# next heading and should fill the hash with the array of symbols
			if ($fname) {
				# If we have found the specified object, finish the parse
				if ($objname and ($fname eq $objname)) {
					return;
				}
			}


			# Find an object file heading
			s/^#\s*//;
			($fname, $ext) = split(/\./);


			# Init hash entries for this objject file.
			$elements->{$fname}{"func"} = [];
			$elements->{$fname}{"data"} = [];

			%symbols = ();
			next;
		} else {
			# Parse symbols list below heading
			my ($ext, $ident, $tag, $comment);
			$ident = undef;

			# Skip if only looking for specific object
			if ($fname and $objname and ($fname ne $objname)) {
				next;
			}

			# Skip comment
			if (/^#/) {
				next;
			}

			# Skip
			if (/#\s*\.skipjmptbl/) {
				next;
			}

			# Skip abandons if option is set
			if ($no_abandons) {
				if (/#\s*.*\.abandon\b/) {
					my ($ext, $ident) = split(/\s+/);
					push(@bans, $ident);
					next;
				}
			}

			# Determine if the symbol is rodata or a function
			if (/#\s*\.rodata/) {
				($ext, $ident, $comment) = split(/\s+/);
				$tag = "data";
			} elsif (/^\.extern\s+/) {
				($ext, $ident) = split(/\s+/);
				$tag = "func";
			}

			# need to escape the $ symbols in static variable sections
			if ($ident) {
				if ($ident =~ /\$/) {
					my ($f, $s) = split(/\$/, $ident);
					$ident = "$f\\\$$s";
				}
				# hack to get rid of duplicate symbols
				if (not exists $symbols{$ident}) {
					push(@{$elements->{$fname}{$tag}}, $ident);

					$symbols{$ident} = $tag;

					# Create a hash of all rodata symbols.
					if ($tag eq "data") {
						$rodata_syms->{$ident} = 1;
					}
				}
				else {
					push(@dups, $ident);
				}
			}
		}
	}
}

my %g_romtable = ();
my @g_sects_avail = ();
my %g_str_values;
my %g_section_addrs;
my %g_section_sizes;
my %g_str_addrs;
my %g_str_lens;
my %g_rom_rodata_syms;


# Disassemble and post-process the specified object file section.
#
# Params: obj:             IN  Full path to object file.
#         fname:           IN  Base filename associated with object file.
#         sects_avail:     IN  Array of sections contained in the object file.
#         section_addrs:   IN  Hash that maps section names to addresses.
#         sym_type:        IN  Type of symbol (data/func).
#         sym_name:        IN  Name of symbol to disassemble.
#         str_addrs:       IN  Hash that maps string addresses to labels.
#         str_values:      IN  Hash that maps string labels to strings.
#         evtlog_strs:     IN  Hash that maps EVENT_LOG 'fmtnum.xxx' symbol name to string.
#         disas_lst_fd:    IN  File handle for disassembly listing file.
#         skip_disas:      IN  If 1, skip disas and only process the rodata str pointers.
#         local_var_disas: IN  Hash that maps local variable initialization data section name to
#                              its disassembly.
#         disas:           OUT Hash that maps 'sym_name' to its disassembly. If defined, then the
#                              disassembly is stored in the hash. If not defined, then the
#                              disassembly is written to a file.
#
# Returns: Nothing.
sub disas_section {
	my ($obj, $fname, $sects_avail, $section_addrs, $sym_type, $sym_name, @more_args) = @_;
	my ($str_addrs, $str_values, $evtlog_strs, $disas_lst_fd, $skip_disas, @more_args2) = @more_args;
	my ($local_var_disas, $disas) = @more_args2;

	my $section = "";
	if ($sym_type eq "data") {
		# Find the actual section the symbol is located in for the object
		#
		# In addition to rodata sections, also include regular data sections in the search.
		# This is necessary since the compiler appears to have an optimization that converts
		# data sections to rodata sections (perhaps if it determines that they are read-only).
		#
		# Also, look in reclaimable data sections (dataini[1-3]). This allows comparison of
		# functions in ROM that have been changed to BCMATTACHDATA in RAM.
		my @datasyms = grep(/\.($data_sect|$rodata_sect|dataini[1-3])\.\Q$sym_name\E(|$g_romdat_patch_subfix)$/, @{$sects_avail});
		if ($#datasyms == 0) {
			# Symbol can have substitution subfix
			chomp($datasyms[0]);
			$section = $datasyms[0];
		}
		else {
			# We have a variable in romtable.S but it's not defined
			# in the corresponding .o file which could be due to
			# an omitted compiler flag
			#
			push(@undefs, $sym_name);
		}
	}
	elsif ($sym_type eq "func") {
		# Find the actual section the symbol is located in for the object
		#
		# In addition to the .text section, also look in reclaimable text sections
		# (textini[1-3]). This allows comparison of functions in ROM that have been changed
		# to BCMATTACHFN in RAM.
		my @fnsyms = grep(/\.(text|textini[1-3])\.\Q$sym_name\E(|$g_romfn_subfix)$/, @{$sects_avail});
		if ($#fnsyms == 0) {
			# Symbol can have substitution subfix
			chomp($fnsyms[0]);
			$section = $fnsyms[0];
		}
		else {
			# We have a variable in romtable.S but it's not defined
			# in the corresponding .o file which could be due to
			# an omitted compiler flag
			#
			push(@undefs, $sym_name);
		}
	}


	if ($section eq "") {
		return;
	}

	if (!(-e "$obj")) {
		printf("File %s does not exist. Skip: %s\n", $obj, $section);
		return;
	}

	my %pstrings;

	# Must retrieve pointer strings for a section before
	# running the object dump, as if the clear flag is set
	# it will modify the pointer references in-place.
	if ($sym_type eq "data") {
		get_rodata_str_pointers($obj, $section, $section_addrs->{$section},
		                        $section_addrs->{".rodata"}, 1, \%pstrings, $str_addrs);
	}


	# Skip disas and only process the rodata str pointers.
	if ($skip_disas) {
		return;
	}

	# Dump a specific section from the object
	my @outS = `$objdump -r -d -z --section=\"$section\" $obj`;
	die "objdump -r -d failed" if $?;

	@outS = postprocess_asm($sym_name, $str_values, \%pstrings, $evtlog_strs, $local_var_disas,
	                        @outS);

	if ($#outS == 1) {
		die ("$script: ERROR: no section found: $sym_name\n");
	}


	# If 'disas' is defined, then store the disassembly in the hash. Otherwise, write the
	# disassembly to a file.
	if (defined($disas)) {
		push(@{$disas->{$sym_name}}, @outS);
		return;
	}

	# strip the escape characters from the output symbol name
	my $outsym = $sym_name;
	$outsym =~ s/\\//g;

	# Update file that lists all symbols disassembled.
	my $disas_file = "./$romSdir/$outsym.$fname.$sym_type.S";
	printf $disas_lst_fd ("$disas_file\n");

	open(SFILE, ">$disas_file")
		or die "Unable to open file $disas_file\n";
	for (my $d = 0; $d < $#outS+1; $d++) {
		printf SFILE ("%s", $outS[$d]);
	}
	close(SFILE);
}



my $fname = undef;
my $ext;
my $obj;

# Only one object, can make parse_romtable() faster
# by only retrieving the specific files info
if ($#objects == 0) {
	$obj = $objects[0];
	($fname, $ext) = split(/\./, basename($obj), 2);
}

# Get a hash representation of the romtable file
parse_romtable($fnromtbl, \%g_romtable, $skip_abandons, $fname, \%g_rom_rodata_syms);



# Disassemble and post-process sections of all object files.
#
# The post-processing of the disassembly replaces string labels (.LCxx) with the actual strings.
# It is important to note that the source code may use "strings" for byte arrays. e.g.
#
#     #define WAPI_OUI   "\x00\x14\x72"  /* WAPI OUI */
#
# These byte array "strings" may use a NULL value for bytes other than termination. Therefore,
# the length of strings cannot be determined based upon the NULL termination character. As a
# result, string lengths need to be calculated by determining the addresses of all strings
# within each object file.
#
# Strings referenced in functions are assigned a label (.LCxx), and their addresses can be found
# in the object file's symbol table. String addresses referenced in rodata can be found by
# parsing the rodata contents. Therefore, the symbol table and all the rodata must be processed
# first in order to determine the string lengths. Subsequently, the text sections can be processed.
foreach $obj (@objects)
{
	my $disas_lst_fd;
	my @obj_rodata_sects;
	my $fname_out;
	my @funcs_to_disas;

	# Hash that maps EVENT_LOG 'fmtnum.xxx' symbol names to addresses within the
	# '.lognums' section.
	my %fmtnum_addrs;

	# Hash that maps EVENT_LOG 'fmtnum.xxx' symbol name to string.
	my %evtlog_strs;


	# Hash that maps local variable initialization data section name to its disassembly.
	my %local_var_disas = ();


	# Output filename.
	$fname_out = $g_fname_out;
	if ($fname_out eq "nil") {
		$fname_out = "./$obj";
		$fname_out =~ s/$g_fname_ext_in$/$g_fname_ext_out/;
	}

	# Display some output
	if (!$g_disas_patch_syms && $g_fname_out eq "nil") {
		printf("$script %s -> %s\n", $obj, $fname_out);
	}

	# The disassembly and post-processing is destructive to the input object file.
	# Use a backup for the processing to avoid altering the original.
	my $tmp_obj = "$obj.bk";
	if ($g_disas_patch_syms) {
		$tmp_obj = "$tmp_obj.patch";
	}
	copy("$obj","$tmp_obj") or die "Copy of $obj failed: $!";
	$obj = "$tmp_obj";

	($fname, $ext) = split(/\./, basename($obj), 2);

	# Create file that lists all symbols disassembled.
	open($disas_lst_fd, ">$fname_out")
		or die "Unable to open file $fname_out";

	# Extract symbols for only the current object from the romtable
	if (!$g_romtable{$fname}) {
		next;
	}


	# Get section address and sizes.
	get_section_info($obj, \%g_section_addrs, \%g_section_sizes, \@obj_rodata_sects);

	# Get the address of all string pointers referenced by functions. Add a fake entry to the
	# address hash for the end of rodata so that the length of the last string in rodata can be
	# calculated.
	get_func_str_addrs($obj, \%g_str_addrs, \%fmtnum_addrs);
	if (exists($g_section_sizes{".rodata"})) {
		$g_str_addrs{$g_section_sizes{".rodata"}} = "rodata_size";
	}

	@g_sects_avail = (keys %g_section_addrs);


	# Lookup rodata string pointer addresses for rodata not in ROM, and disassemble local
	# variable initialization data.
	foreach my $sect (@obj_rodata_sects) {
		my %pstrings;
		my $sym = $sect;
		$sym =~ s/\.(data|rodata)\.//;

		# Only process rodata not in ROM. The ROM rodata will be processed later below.
		if (!$g_rom_rodata_syms{$sym}) {
			get_rodata_str_pointers($obj, $sect, $g_section_addrs{$sect},
			                        $g_section_addrs{".rodata"}, 0, \%pstrings,
			                        \%g_str_addrs);
		}

		# Disassemble local variable initialization data (structs and arrays). These will
		# be embedded in the function disassembly.
		if ($sym =~ /$g_local_var_regexp/) {
		        my $sym_type = "data";

		        # Disassemble section.
		        disas_section($obj, $fname, \@g_sects_avail, \%g_section_addrs, $sym_type,
		        	      $sym, \%g_str_addrs, \%g_str_values, undef, $disas_lst_fd, 0,
				      undef, \%local_var_disas);
		}
	}

	# Skip disas and only process the rodata str pointers for patch functions.
	my $skip_disas = 0;
	if ($g_disas_patch_syms) {
		$skip_disas = 1;
	}

	# Process all rodata sections.
	foreach my $symbol (@{$g_romtable{$fname}{"data"}}) {
		my $sym_name = $symbol;
		my $sym_type = "data";

		# Disassemble section.
		disas_section($obj, $fname, \@g_sects_avail, \%g_section_addrs, $sym_type, $sym_name,
		              \%g_str_addrs, \%g_str_values, undef, $disas_lst_fd, $skip_disas,
		              undef, undef);
	}

	# Process all rodata *patch* sections.
	if ($g_disas_patch_syms) {
		foreach my $sect (@g_sects_avail) {
			if ($sect =~ /\.rodata\.($g_patch_sym_regexp)/) {
				my $sym_name = $1;
				my $sym_type = "data";

				# Disassemble section.
				disas_section($obj, $fname, \@g_sects_avail, \%g_section_addrs,
				              $sym_type, $sym_name, \%g_str_addrs, \%g_str_values,
				              undef, $disas_lst_fd, 0, undef, undef);
			}
		}
	}


	# Calculate the string lengths.
	get_str_lens(\%g_str_addrs, \%g_str_lens);

	# Get the function string labels.
	get_func_str_labels($obj, \%g_str_addrs, \%g_str_lens, $g_section_addrs{".rodata"}, \%g_str_values);

	# Retrieve all EVENT_LOG strings.
	get_evtlog_func_strs($obj, \%fmtnum_addrs, $g_section_addrs{$g_lognums_sect},
	                     $g_section_addrs{$g_logstrs_sect}, \%evtlog_strs);


	# Create list of functions to disassemble.
	if ($g_disas_patch_syms) {
		# Add all patch functions.
		foreach my $sect (@g_sects_avail) {
			if ($sect =~ /\.text\.($g_patch_sym_regexp)/) {
				push(@funcs_to_disas, $1);
			}
		}
	}
	else {
		# Copy ROM table functions.
		@funcs_to_disas = @{$g_romtable{$fname}{"func"}};
	}


	# Process all text sections.
	foreach my $symbol (@funcs_to_disas) {
		my $sym_name = $symbol;
		my $sym_type = "func";

		# Disassemble section.
		disas_section($obj, $fname, \@g_sects_avail, \%g_section_addrs, $sym_type, $sym_name,
		              \%g_str_addrs, \%g_str_values, \%evtlog_strs, $disas_lst_fd, 0,
			      \%local_var_disas, undef);
	}


	close($disas_lst_fd);
	unlink $tmp_obj;
}

# Display stats.
if ($g_display_stats == 1) {
	my $sym;

	if (@undefs > 0) {
		printf("$script: ERROR: Symbols declared in $fnromtbl, but missing in object files: %d\n", scalar @undefs);
		foreach $sym (@undefs) {
			printf("   %s\n", $sym);
		}
		exit 1;
	}

	if (@dups > 0) {
		printf("Warning: duplicate symbols: %d\n", scalar @dups);
		foreach $sym (@dups) {
			printf("   %s\n", $sym);
		}
	}

	if (@bans > 0) {
        	printf("Symbols marked abandon: %d\n", scalar @bans);
        	foreach $sym (@bans) {
        		printf("   %s\n", $sym);
        	}
        }

        if ($#matched >= 0) {
        	printf("Warning: Found potential violations:\n");
        	printf("====================================\n");
        	foreach(@matched) {
        		printf("   %s\n", $_);
        	}
        	printf("\n");
        }
}
