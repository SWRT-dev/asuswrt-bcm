#!/usr/bin/perl
#
# This script generates a list of ROM function call substitution macros and
# ROM function pointers.
#
# It takes a list of BCMROMFN tagged functions names, a list of function declarations
# (function prototypes from where they are declared hence function declarations), and
# a list of function definitions (function prototypes from where they are defined hence
# function definitions). All three lists are passed in from STDIN separated by ':' sign
# in its own line. Function declarations are used to generate the substitutions prototypes.
# Function definitions are used to generate the substitutions macros and their parameters
# lists.
#
# $ Copyright Broadcom Corporation $
#
# <<Broadcom-WL-IPTag/Proprietary:>>
#
# $Id: build_rom_idxtbl,v 1.11 2009-11-08 22:08:14 csm Exp $
#

use warnings;

my $mogrifier;

if ( -s "/home/hwnbuild/src/tools/build/mogrify.pl" ) {
   $mogrifier = "/home/hwnbuild/src/tools/build/mogrify.pl";
} elsif ( -s "/projects/hnd_software/gallery/src/tools/build/mogrify.pl" ) {
   $mogrifier = "/home/hwnbuild/src/tools/build/mogrify.pl";
}

my $fnromtbl = "nil";
my $filename = "nil";
if (@ARGV > 1) {
    $fnromtbl = $ARGV[0];
    $filename = $ARGV[1];
}
if ($fnromtbl eq "nil" || $filename eq "nil") {
    die "Usage: perl build_rom_idxtbl <rom-table-file-path> <output-file-base-name> [<nojt>]\n";
}
# For debugging, set to zero to bypass jump table
#
my $no_jmptbl = 0;
if (@ARGV > 2) {
    $no_jmptbl = $ARGV[2];
}

my $jmptbl_full = 0;
if (@ARGV > 3) {
    $jmptbl_full = $ARGV[3];
}

# put tagged functions names, functions declarations, and functions definitions into
# different arrays.
my @parts = split(/:\n/, join('', <STDIN>));
my @romfns = split(/\n/, $parts[0]);
my @fndecls = ();
my @fndefs = ();
if ($jmptbl_full == 0) {
	@fndecls = split(/\n/, $parts[1]);
	@fndefs = split(/\n/, $parts[2]);
}

# Constants
#
my $g_fntype_subfix = "___bcmromfn_t";
my $g_fnype_prefix = "_bcmjmptbl__";
my $g_dtype_subfix = "___bcmromdat_t";

# if changing $g_romfn_subfix, need to update replace-rommap
my $g_romfn_subfix = "__bcmromfn";
my $g_romdat_suffix = "__bcmromdat";
my $g_patch_suffix = "__bcmpatch";

# TODO - read the component list from tools/release/WLAN.usf
@wl_components = qw(shared/bcmwifi wl/clm wl/ppr);

# Common directories to grep
# Include both old and new phy locations for compatibility
@pattlist = qw(
    include/*.h
    wl/sys/*.[ch]
    ../components/phy/old/*.[ch]
    wl/phy/*.[ch]
    shared/*.[ch]
    bcmcrypto/*.[ch]
);
push(@pattlist, map { ( "$_/include/*.h", "$_/src/*.c" ) } @wl_components);
$patterns = join(' ', map { "../../../../$_" } @pattlist);

# Files to ignore grepping for sanity check
my @g_file_excludes = qw(
			wl_ndis.c
			wl_locator.c
			);

# find all lines with .extern in the rom table.
# symbols from these lines are used to limit the sustitutions generation.
open($fhromtbl, "<$fnromtbl") or die "Unable to open file $fnromtbl: $!\n";
my @declare = grep(/^\s*\.extern\s/, <$fhromtbl>);
close($fhromtbl);

# create lists for symbols possibly in jump table and not in jump table
my @jmptbl_funcs = ();
my @skipjmptbl_funcs = ();
my @romdatbl_syms = ();
my @romdat_decls = ();
my @romdat_unused_decls = ();
my @romdat_patches = ();

if ($no_jmptbl == 0) {
    foreach $line (@declare) {

	if ($line =~ /#\s*\.rodata\b/) {
	    # for full jmptbl, remove file name qualifier if exists
	    # since substitution happens at preprocessor stage
	    # and renaming happens after .S output compilation
	    if ($line =~ /\$/) {
		my ($m, $n, $p) = split(/\s+/, $line);
		my ($f, $s) = split(/\$/, $p);
		$line =~ s/$f\$$s/$s/;
	    }
	    push(@romdatbl_syms, $line);
	    next;
	}

	my($ext, $sym) = split(" ", $line);
	if ($line =~ /#\s*\.skipjmptbl\b/) {
	    push(@skipjmptbl_funcs, $sym);
	}
	else {
	    push(@jmptbl_funcs, $sym);
	}
    }
}

# header file name
$filename_h = $filename.".h";
open(HDR_FILE,">$filename_h.tmp") or die "Unable to open file $filename_h.tmp: $!\n";

# source file name
$filename_c = $filename.".c";
open(SRC_FILE,">$filename_c.tmp") or die "Unable to open file $filename_c.tmp: $!\n";

printf SRC_FILE ("/* FILE-CSTYLED */\n");
printf SRC_FILE ("/*\n");
printf SRC_FILE (" * DO NOT MODIFY. This is generated by script 'build_rom_idxtbl'.\n");
printf SRC_FILE (" * This file lists all pointers to ROM functions\n");
printf SRC_FILE (" *\n");
# Copyright text is split into two lines to fool mogrifier to skip this
printf SRC_FILE (" * \$Copyright (C) 2009");
printf SRC_FILE (" Broadcom Corporation\$\n");
printf SRC_FILE (" */\n");
printf SRC_FILE ("typedef void (*bcmromfn_ptr_t)(void);\n");
printf SRC_FILE ("\n");

printf SRC_FILE ("#if defined(BCMROMOFFLOAD)\n");
printf SRC_FILE ("\n");
printf SRC_FILE ("#define BCMROMFN_PTR(_data)\t__attribute__ ((__section__ (\".data.\"#_data))) _data\n");
printf SRC_FILE ("#define BCMROMFN_NAME(_fn)\t_fn\n");
printf SRC_FILE ("\n");
printf SRC_FILE ("#elif defined(BCMROMBUILD)\n");
printf SRC_FILE ("\n");
printf SRC_FILE ("#define BCMROMFN_PTR(_data)\t__attribute__ ((__section__ (\".romfnptr.\"#_data))) _data\n");
printf SRC_FILE ("#define BCMROMFN_NAME(_fn)\t_fn##%s\n", $g_romfn_subfix);
printf SRC_FILE ("\n");
printf SRC_FILE ("#endif\n");
printf SRC_FILE ("\n");

# generate substitution prototype, generate substitution macro to
# substitute function call xxxx() with mangled name xxxx__bcmromfn().
sub process_subst {
   my $fn = shift @_;
   my $decl = shift @_;
   my $def = shift @_;
   my $idx = shift @_;

   $decl =~ s/^(extern|static)\b//;
   $decl =~ s/\b\Q$fn\E\b/(*)/;
   $decl =~ s/^\s+//;
   $decl =~ s/;.*$//;

   $def =~ /\/\*\s(\(.*\))\s.*\*\//s;
   $def = $1;

   printf SRC_FILE ("/* $fn: FUNCTION POINTER $idx */\n");
   printf SRC_FILE ("void BCMROMFN_NAME(%s)(void);\n", $fn);
   printf SRC_FILE ("bcmromfn_ptr_t BCMROMFN_PTR(%s%s) = BCMROMFN_NAME(%s);\n",
		    $g_fnype_prefix, $fn, $fn);
   printf SRC_FILE ("\n");

   printf HDR_FILE ("/* $fn: FUNCTION CALL SUBSTITUTION $idx */\n");
   printf HDR_FILE ("extern bcmromfn_ptr_t %s%s;\n", $g_fnype_prefix, $fn);
   printf HDR_FILE ("#define %s%s \\\n\t%s\n", $fn, $g_fntype_subfix, $decl);
   if ($decl =~ /\.\.\./) {
       $def1 = $def;
       $def1 =~ s/\)$/, args...)/;
       $def2 = $def;
       $def2 =~ s/\)$/, ##args)/;
       printf HDR_FILE ("#define %s%s \\\n\t((%s%s)%s%s)%s\n",
			$fn, $def1, $fn, $g_fntype_subfix, $g_fnype_prefix, $fn, $def2);
   }
   else {
       printf HDR_FILE ("#define %s%s \\\n\t((%s%s)%s%s)%s\n",
			$fn, $def, $fn, $g_fntype_subfix, $g_fnype_prefix, $fn, $def);
   }
   printf HDR_FILE ("\n");
}

# generate substitution macro to rename function defintion xxxx__bcmromfn
# back to its orignal name xxxx.
sub process_name {
   my $fn = shift @_;

   printf HDR_FILE ("#define %s%s\t%s\n", $fn, $g_romfn_subfix, $fn);
   printf HDR_FILE ("\n");
}

sub get_bcmromdata{
	my ($romdatcnt, @romdatbl) = @_;
	my $create_entry = 0;

	my $grepstr = "(BCMROMDAT_APATCH|BCMROMDATA|BCMROMDAT_SPATCH)";

	my @alldecls = `egrep -n -e \"$grepstr\" $patterns`;
	my @datdecls = grep(/BCMROMDATA/, @alldecls);
	my @patches = grep(/(BCMROMDAT_APATCH|BCMROMDAT_SPATCH)/, @alldecls);

	foreach my $patch (@patches) {
		my($file, $lnum, $decl) = split(/:/, $patch);

		if ($decl =~ /#define/) {
			next;
		}
		if ($decl =~ /##/) {
			next;
		}
		if ($decl =~ /^\/\//) {
			next;
		}
		$decl =~ s/_APATCH//;
		$decl =~ s/_SPATCH//;
		my($tmp, $sym_side) = split(/BCMROMDAT\(/, $decl);
		my($sym, $tmp2) = split(/\)/, $sym_side);
		if (!grep(/\b\Q$sym\E\b/, @romdat_patches)) {
                	push(@romdat_patches, $sym);
		} else {
			printf("Error: duplicate patch: %s\n", $sym);
		}
	}

	foreach my $line (@datdecls) {
		chop($line);

		my($file, $lnum, $decl) = split(/:/, $line);

		if ($decl =~ /#define/) {
			next;
		}
		if ($decl =~ /##/) {
			next;
		}

		$decl =~ s/^STATIC//;
		$decl =~ s/^static//;
		$decl =~ s/^extern//;
		$decl =~ s/^\s+//;
		$decl =~ s/\s+$//;

		$decl = substr($decl, 0, rindex($decl, ';'));
		if (rindex($decl, '=') != -1) {
			my $pos = rindex($decl, '=');
			my $newstr = substr($decl, 0, $pos);

			$newstr =~ s/\s+$//;
			$decl = $newstr;
		}

		my($tmp, $sym_side) = split(/BCMROMDATA\(/, $decl);
		my($sym, $tmp2) = split(/\)/, $sym_side);

		$decl = "extern " . $decl . ";";

		# Create a data patch entry if it's in romtable.S and
		# there's a definition for BCMROMDAT_?PATCH()
		if (grep(/\b\Q$sym\E\b/, @romdat_patches)) {
			$create_entry = 1;
		} else {
			$create_entry = 0;
		}
		if (grep(/\b\Q$sym\E\b/, @romdatbl) && ($create_entry == 1)) {
			if (!grep(/BCMROMDATA\(\Q$sym\E\)/, @romdat_decls)) {
				push(@romdat_decls, $decl);
			}
		} else {
			if (!grep(/\b\Q$sym\E\b/, @romdat_unused_decls)) {
                		push(@romdat_unused_decls, $sym);
			}
        	}
	}
}

printf HDR_FILE ("/* FILE-CSTYLED */\n");
printf HDR_FILE ("/*\n");
printf HDR_FILE (" * DO NOT MODIFY. This is generated by script 'build_rom_idxtbl'.\n");
printf HDR_FILE (" * This file lists all substitutions to ROM functions references.\n");
printf HDR_FILE (" *\n");
# Copyright text is split into two lines to fool mogrifier to skip this
printf HDR_FILE (" * \$Copyright (C) 2009");
printf HDR_FILE (" Broadcom Corporation\$\n");
printf HDR_FILE (" */\n");
printf HDR_FILE ("#ifndef __%s_h__\n", $filename);
printf HDR_FILE ("#define __%s_h__\n", $filename);
printf HDR_FILE ("\n");
printf HDR_FILE ("typedef void (*bcmromfn_ptr_t)(void);\n");
printf HDR_FILE ("\n");

printf HDR_FILE ("#if defined(BCMROMBUILD)\n");
printf HDR_FILE ("\n");
if ($jmptbl_full == 0) {
	printf HDR_FILE ("#define BCMROMDATA_SUBST(_data)\t__attribute__ ((__section__ (\".datarom.\"#_data))) _data\n");
} else {
	printf HDR_FILE ("#define BCMROMDATA_SUBST(_data)\t_data\n");
}

printf HDR_FILE ("#define BCMROMDATA_SUBST_PATCH(_data)\t__attribute__ ((__section__ (\".romdptr.\"#_data))) _data\n");
printf HDR_FILE ("#define BCMROMDATA(_data)\t\tBCMROMDATA_SUBST(_data##%s)\n", $g_romdat_suffix);
printf HDR_FILE ("#define BCMROMDAT_NAME(_data)\t_data##%s\n", $g_romdat_suffix);
printf HDR_FILE ("#define BCMROMDAT_ARYSIZ(data)\tdata##__arraysize(data)\n");
printf HDR_FILE ("#define BCMROMDAT_SIZEOF(data)\tdata##__sizeof(data)\n");
printf HDR_FILE ("#define BCMROMDAT_APATCH(data)\tbcmromdat_patch_t BCMROMDATA_SUBST_PATCH(data##$g_patch_suffix) = \\\n\t{ sizeof(data##%s[0]), \\\n\tsizeof(data##%s)/sizeof(data##%s[0]), \\\n\t((void*)data##%s) };\n", $g_romdat_suffix, $g_romdat_suffix, $g_romdat_suffix, $g_romdat_suffix);
printf HDR_FILE ("#define BCMROMDAT_SPATCH(data)\tbcmromdat_patch_t BCMROMDATA_SUBST_PATCH(data##$g_patch_suffix) = \\\n\t{ sizeof(data##%s), 1, \\\n\t((void*)(&(data##%s))) };\n", $g_romdat_suffix, $g_romdat_suffix);
printf HDR_FILE ("\n");

if ($jmptbl_full == 0) {
	printf HDR_FILE ("#define BCMROMFN_SUBST(_fn)\t__attribute__ ((__section__ (\".textrom.\"#_fn))) _fn\n");
	printf HDR_FILE ("#define BCMROMFN(_fn)\t\tBCMROMFN_SUBST(_fn##%s)\n", $g_romfn_subfix);
	printf HDR_FILE ("#define BCMROMFN_NAME(_fn)\t_fn##%s\n", $g_romfn_subfix);
} else {
	printf HDR_FILE ("#define BCMROMFN(_fn)\t\t_fn\n");
	printf HDR_FILE ("#define BCMROMFN_NAME(_fn)\t_fn\n");
}

printf HDR_FILE ("\n");

if (($#jmptbl_funcs != -1) && ($jmptbl_full == 0)) {
    printf HDR_FILE ("/* BCMROMFN TAGS: %u */\n", scalar(@romfns));
    printf HDR_FILE ("\n");
    $fns = 0;
    foreach $fn (@romfns) {
	@decl = grep(/\b\Q$fn\E\s\(.*\);/, @fndecls);
	if (@decl > 1) {
	    die "$fn: found multiple times in declaration list\n";
	}
	@def = grep(/\b\Q$fn\E\s\(.*\);\s\/\*.*\*\//, @fndefs);
	if (@def > 1) {
	    die "$fn: found multiple times in definition list\n";
	}
	if (@decl == 0) {
	    printf HDR_FILE ("/* $fn: DECLARATION NOT FOUND */\n");
	    printf HDR_FILE ("\n");
	}
	elsif (@def == 0) {
	    printf HDR_FILE ("/* $fn: DEFINITION NOT FOUND */\n");
	    process_name($fn);
	}
	elsif (grep(/^\Q$fn\E$/, @jmptbl_funcs)) {
	    process_subst($fn, $decl[0], $def[0], $fns++);
	}
	elsif (grep(/^\Q$fn\E$/, @skipjmptbl_funcs)) {
	    printf HDR_FILE ("/* $fn: ROMMED BUT NO PATCH ENTRY */\n");
	    process_name($fn);
	}
	else {
	    printf HDR_FILE ("/* $fn: TAGGED BUT NO ROM ENTRY OR NOT ROMMED */\n");
	    process_name($fn);
	}
    }
    printf HDR_FILE ("/* ACTUAL FUNCTION SUBSTITUTIONS: %u */\n", $fns);
    printf HDR_FILE ("\n");
}

# Find all BCMROMDATA() to determine what to substitute
# and what to reverse
get_bcmromdata($#romdatbl_syms, @romdatbl_syms);
my @dpatch_names = ();
if ($#romdatbl_syms != -1) {
    my $dsym_cnt = 0;
    foreach my $extern_dsym (@romdatbl_syms) {
	my($extrn, $dsym) = split(" ", $extern_dsym);

	my @dat_decl = grep(/BCMROMDATA\(\Q$dsym\E\)/, @romdat_decls);
	if ($#dat_decl == -1) {
		printf("Symbol BCMROMDATA\(%s\) NOT found\n", $dsym)
		    if !$jmptbl_full;
	} else {
		$dsym_cnt++;

		my $is_struct = 0;
		my $dsym_cast = $dat_decl[0];
		$dsym_cast =~ s/extern//;
		$dsym_cast =~ s/;$//;

		push(@dpatch_names, $dsym);

		if ($dat_decl[0] =~ /\[.*\]\[.*\]/) {
			$dsym_cast =~ s/\[[^[]*\]//;
			$dsym_cast =~ s/BCMROMDATA\(\Q$dsym\E\)/\(\*\)/;
		} elsif ($dat_decl[0] =~ /\[.*\]/) {
			$dsym_cast =~ s/\[[^[]*\]//;
			$dsym_cast =~ s/BCMROMDATA\(\Q$dsym\E\)/\*/;
		} else {
			$dsym_cast =~ s/BCMROMDATA\(\Q$dsym\E\)//;
			$is_struct = 1; # Others assumed structs
		}
		$dsym_cast =~ s/^\s+//;

   		printf HDR_FILE ("/* %s: DATA PATCH ENTRY %d */\n", $dsym, $dsym_cnt);
   		printf HDR_FILE ("extern bcmromdat_patch_t %s$g_patch_suffix;\n", $dsym);
		printf HDR_FILE ("#define %s__arraysize(data) \\\n\t((%s$g_patch_suffix).cnt)\n", $dsym, $dsym);
		printf HDR_FILE ("#define %s__sizeof(data) \\\n\t(((%s$g_patch_suffix).esiz)*((%s$g_patch_suffix).cnt))\n", $dsym, $dsym, $dsym);
		if ($is_struct == 1) {
			# Struct type
   			printf HDR_FILE ("#define %s%s \\\n\t%s\*\n", $dsym, $g_dtype_subfix, $dsym_cast);
   			printf HDR_FILE ("#define %s \\\n\t\(\*\(\(%s%s\)%s$g_patch_suffix.addr\)\)\n", $dsym, $dsym, $g_dtype_subfix, $dsym);
		} else {
			# Array type
			printf HDR_FILE ("#define %s%s \\\n\t%s\n", $dsym, $g_dtype_subfix, $dsym_cast);
			printf HDR_FILE ("#define %s \\\n\t\(\(%s%s\)%s$g_patch_suffix.addr\)\n", $dsym, $dsym, $g_dtype_subfix, $dsym);
		}
		printf HDR_FILE ("\n");
	}
    }

    printf HDR_FILE ("/* ACTUAL DATA PATCH ENTRIES: %u */\n", $dsym_cnt);
    printf HDR_FILE ("\n");
}


# BCMROMDATA() symbols not used in romtable.S
# Need to reverse macro name
if ($#romdat_unused_decls >= 0) {
	printf HDR_FILE ("/* BCMROMDATA symbols not in romtable.S or no patch entry */\n");
	foreach my $dsym (@romdat_unused_decls) {
		printf HDR_FILE ("\n");
		if (grep(/\b\Q$dsym\E\b/, @romdatbl_syms)) {
			printf HDR_FILE ("/* %s: DATA ROMMED, NOT PATCHED */\n",  $dsym);
		} else {
			printf HDR_FILE ("/* %s: DATA NOT ROMMED */\n",  $dsym);
		}
		printf HDR_FILE ("#define %s__arraysize(data) \\\n\tARRAYSIZE(%s)\n", $dsym, $dsym);
		printf HDR_FILE ("#define %s__sizeof(data) \\\n\tsizeof(%s)\n", $dsym, $dsym);
		printf HDR_FILE ("#define %s%s\t%s\n", $dsym, $g_romdat_suffix, $dsym);
	}
	printf HDR_FILE ("\n");
}

printf HDR_FILE ("#endif /* BCMROMBUILD */\n");
printf HDR_FILE ("\n");
printf HDR_FILE ("#endif /* __%s_h__ */\n", $filename);

close(SRC_FILE);
close(HDR_FILE);

# Update the output files only if they don't exist or the new ones are different.
# Otherwise, make will rebuild the world unnecessarily.

sub rename_diff {
    my ($src, $dst) = @_;
    if (! -f $dst) {
	rename($src, $dst) or die "Could not rename $src to $dst; $!\n";
    } else {
	open(my $dst_fh, $dst) || die "Could not open $dst: $!\n";
	open(my $src_fh, $src) || die "Could not open $src: $!\n";
	my $dst_txt = join '', <$dst_fh>;
	my $src_txt = join '', <$src_fh>;
	if ($dst_txt eq $src_txt) {
	    unlink($src) or die "Could not remove $src; $!\n";
	} else {
	    rename($src, $dst) or die "Could not rename $src to $dst; $!\n";
	}
    }
}

# Replace the copyright text in the generated files
system("perl $mogrifier $filename_h.tmp $filename_c.tmp 2> /dev/null");

&rename_diff("$filename_h.tmp", $filename_h);
&rename_diff("$filename_c.tmp", $filename_c);

if ($#dpatch_names >= 0) {
	my $patched_syms = join("|", @dpatch_names);
	my $grepstr = "(sizeof|ARRAYSIZE)\\(($patched_syms)\\)";
	my $file_excl = join("|", @g_file_excludes);
	my @wrong_sizes = ();

	my @bad_uses = `egrep -n -e \"$grepstr\" $patterns`;

	if ($#bad_uses >= 0) {
		foreach my $line (@bad_uses) {
			if (!($line =~ /($file_excl)/)) {
				push(@wrong_sizes, $line);
			}
		}
	}

	if ($#wrong_sizes >= 0) {
		printf("Error: need to fix the following:\n");
		printf("=================================\n");
		foreach my $line (@wrong_sizes) {
			printf("   %s", $line);
		}
		exit -1;
	}
}
