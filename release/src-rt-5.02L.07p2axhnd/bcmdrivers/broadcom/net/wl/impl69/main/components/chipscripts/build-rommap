#!/usr/bin/perl
#
# This script lists ROM symbols as absolute values in assembly using information
# found in romtable.S and symtbl files and outputs the list to STDOUT.
#
#     - symtbl map ('nm -n roml' output) from STDIN
#     - symbols in romtable.S with .extern keyword
#
# $ Copyright Broadcom Corporation $
#
# <<Broadcom-WL-IPTag/Proprietary:>>
#
# $Id: build-rommap,v 1.13.2.1 2010-12-23 07:27:07 lut Exp $
#

use strict;
use warnings;

my $idre = '([\w$]+)';
my $fnre = '([\w.-]+)';
my $fnromtbl = "nil";
my $fnromtbl_auto = "nil";
my $thumb = 0;
my $jmptbl = 0;
my $jmptbl_full = 0;
if (@ARGV > 2) {
	$fnromtbl      = $ARGV[0];
	$fnromtbl_auto = $ARGV[1];
	$thumb         = $ARGV[2];
	$jmptbl        = $ARGV[3];
	$jmptbl_full   = $ARGV[4];
}

if ($fnromtbl eq "nil") {
    die "Usage: perl build-rommap <rom-table> <rom-table-auto> <thumb-mode> <use-jmptbl> <use-datbl> <jmptbl-full>\n";
}

# Parse symbols in auto generated ROM table file (romtable_auto.S).
my $fhromtbl;
open($fhromtbl, "<$fnromtbl_auto") or die "Unable to open file $fnromtbl_auto: $!\n";
my %g_extern = ();
my %g_rodata = ();
my %g_abandon = ();
my %g_noesc = ();
map {
	$g_extern{$1} = 1 if /^\s*\.extern\s+${idre}\b/;
	$g_rodata{$1} = 1 if /^\s*\.extern\s+${idre}\s+\#\s*\.rodata\b/;
	$g_abandon{$1} = 1 if /^\s*\.extern\s+${idre}.*\#\s*\.abandon\b/;
	$g_noesc{$1} = 1 if /^\s*\.extern\s+${idre}\s+\#\s*\.no_esc\b/;
} <$fhromtbl>;
close($fhromtbl);

# Parse symbols in original ROM table file (romtable.S), which contains a complete listing of all
# symbols in ROM. This ensures that all symbols are included in the ROM map file
# generated by this script. (The auto generated ROM table file excludes invalidated ROM functions
# that do not require TCAM entries).
open($fhromtbl, "<$fnromtbl") or die "Unable to open file $fnromtbl: $!\n";
foreach my $line (<$fhromtbl>) {
	if (($line =~ /^\s*\.extern\s+${idre}\b/) && ($line !~ /\.rodata/)) {
		if (!defined($g_extern{$1})) {
			$g_extern{$1}  = 1;
			$g_abandon{$1} = 1;
		}
	}
}
close($fhromtbl);


# ROM func name suffix
my $g_romdat_suffix = "__bcmromdat";
my $g_romfn_suffix = "__bcmromfn";
my $g_romdat_patch_suffix = "__bcmpatch";

my @nm = <STDIN>;
my %g_nm_decl = ();
my %romfnaddr;

# Lookup symbols from romtable.S in nm
foreach (@nm) {
	chomp;
	my($addr, $attr, $sym) = split(/\s+/);

	if ($sym =~ /$g_romfn_suffix$/) {
	    $romfnaddr{$sym} = $addr;
	}

	$sym =~ s/$g_romfn_suffix$//; 
	$sym =~ s/$g_romdat_suffix$//; 

	push(@{$g_nm_decl{$sym}}, $_) if ($g_extern{$sym});
}

# print each symbol declared as .extern in romtable.S file as an absolute address
# found in symtbl map file
foreach my $line (sort keys %g_extern) {

	if (!$g_nm_decl{$line}) {
		printf("\t/* SYMBOL %s NOT FOUND IN ROM IMAGE */\n", $line);
		printf("\n");
		next;
	}

	my @nmsyms = @{$g_nm_decl{$line}};
	my $abandon = 0;
	my $noesc = 0;
	my $data = 0;

	$data = 1 if ($g_rodata{$line});
	$abandon = 1 if ($g_abandon{$line});
	$noesc = 1 if ($g_noesc{$line});

	foreach (@nmsyms) {
		my ($addr, $flag, $sym) = split(/\s+/);
		my $comm = "";

		# For abandoned symbols, keep only the romfn suffixed ones
		next if $abandon && $sym !~ /$g_romfn_suffix$/;

		# Remove suffix
		$sym =~ s/$g_romdat_suffix//; 

		# Remove fn suffix
		if ($jmptbl_full == 0) {
			$sym =~ s/$g_romfn_suffix//; 
		}

 
		printf("\t.global %s\n", $sym);
		printf("\t.type %s, %%%s\n", $sym, $data == 0 ? "function" : "object");
		if (!$data && ($sym !~ /$g_romfn_suffix/) && defined($romfnaddr{$sym . $g_romfn_suffix})) {
		    $addr = $romfnaddr{$sym.$g_romfn_suffix};
		    $comm = "\t/* Points to $sym$g_romfn_suffix */";
		}

		printf("\t%s = 0x%x $comm\n",
		       $sym, hex($addr) | (($data == 0 && $thumb != 0) ? 1 : 0));
		printf("\n");
 	}
}
