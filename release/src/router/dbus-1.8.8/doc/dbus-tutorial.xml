<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"
[
]>

<article id="index">
  <articleinfo>
    <title>D-Bus Tutorial</title>
    <releaseinfo>Version 0.5.0</releaseinfo>
    <date>20 August 2006</date>
    <authorgroup>
      <author>
	<firstname>Havoc</firstname>
	<surname>Pennington</surname>
	<affiliation>
	  <orgname>Red Hat, Inc.</orgname>
	  <address><email>hp@pobox.com</email></address>
	</affiliation>
      </author>
      <author>
	<firstname>David</firstname>
	<surname>Wheeler</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Palmieri</surname>
	<affiliation>
	  <orgname>Red Hat, Inc.</orgname>
	  <address><email>johnp@redhat.com</email></address>
	</affiliation>
      </author>
      <author>
	<firstname>Colin</firstname>
	<surname>Walters</surname>
	<affiliation>
	  <orgname>Red Hat, Inc.</orgname>
	  <address><email>walters@redhat.com</email></address>
	</affiliation>
      </author>
    </authorgroup>
  </articleinfo>

  <sect1 id="meta">
    <title>Tutorial Work In Progress</title>
    
    <para>
      This tutorial is not complete; it probably contains some useful information, but 
      also has plenty of gaps. Right now, you'll also need to refer to the D-Bus specification,
      Doxygen reference documentation, and look at some examples of how other apps use D-Bus.
    </para>

    <para>
      Enhancing the tutorial is definitely encouraged - send your patches or suggestions to the
      mailing list. If you create a D-Bus binding, please add a section to the tutorial for your 
      binding, if only a short section with a couple of examples.
    </para>

  </sect1>

  <sect1 id="whatis">
    <title>What is D-Bus?</title>
    <para>
      D-Bus is a system for <firstterm>interprocess communication</firstterm>
      (IPC). Architecturally, it has several layers:

      <itemizedlist>
        <listitem>
          <para>
            A library, <firstterm>libdbus</firstterm>, that allows two
            applications to connect to each other and exchange messages.
          </para>
        </listitem>
        <listitem>
          <para>
            A <firstterm>message bus daemon</firstterm> executable, built on
            libdbus, that multiple applications can connect to. The daemon can
            route messages from one application to zero or more other
            applications.
          </para>
        </listitem>
        <listitem>
          <para>
            <firstterm>Wrapper libraries</firstterm> or <firstterm>bindings</firstterm> 
            based on particular application frameworks.  For example, libdbus-glib and
            libdbus-qt. There are also bindings to languages such as
            Python. These wrapper libraries are the API most people should use,
            as they simplify the details of D-Bus programming. libdbus is 
            intended to be a low-level backend for the higher level bindings.
            Much of the libdbus API is only useful for binding implementation.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      libdbus only supports one-to-one connections, just like a raw network
      socket. However, rather than sending byte streams over the connection, you
      send <firstterm>messages</firstterm>. Messages have a header identifying
      the kind of message, and a body containing a data payload. libdbus also
      abstracts the exact transport used (sockets vs. whatever else), and
      handles details such as authentication.
    </para>

    <para>
      The message bus daemon forms the hub of a wheel. Each spoke of the wheel
      is a one-to-one connection to an application using libdbus.  An
      application sends a message to the bus daemon over its spoke, and the bus
      daemon forwards the message to other connected applications as
      appropriate. Think of the daemon as a router.
    </para>

    <para>
      The bus daemon has multiple instances on a typical computer.  The
      first instance is a machine-global singleton, that is, a system daemon
      similar to sendmail or Apache. This instance has heavy security
      restrictions on what messages it will accept, and is used for systemwide
      communication. The other instances are created one per user login session.
      These instances allow applications in the user's session to communicate 
      with one another.
    </para>

    <para>
      The systemwide and per-user daemons are separate.  Normal within-session
      IPC does not involve the systemwide message bus process and vice versa.
    </para>

    <sect2 id="uses">
      <title>D-Bus applications</title>
      <para>
        There are many, many technologies in the world that have "Inter-process
        communication" or "networking" in their stated purpose: <ulink
        url="http://www.omg.org">CORBA</ulink>, <ulink
        url="http://www.opengroup.org/dce/">DCE</ulink>, <ulink
        url="http://www.microsoft.com/com/">DCOM</ulink>, <ulink
        url="http://developer.kde.org/documentation/library/kdeqt/dcop.html">DCOP</ulink>, <ulink
        url="http://www.xmlrpc.com">XML-RPC</ulink>, <ulink
        url="http://www.w3.org/TR/SOAP/">SOAP</ulink>, <ulink
        url="http://www.mbus.org/">MBUS</ulink>, <ulink
        url="http://www.zeroc.com/ice.html">Internet Communications Engine (ICE)</ulink>,
        and probably hundreds more.
        Each of these is tailored for particular kinds of application.
        D-Bus is designed for two specific cases:
        <itemizedlist>
          <listitem>
            <para>
              Communication between desktop applications in the same desktop
              session; to allow integration of the desktop session as a whole,
              and address issues of process lifecycle (when do desktop components 
              start and stop running).
            </para>
          </listitem>
          <listitem>
            <para>
              Communication between the desktop session and the operating system, 
              where the operating system would typically include the kernel 
              and any system daemons or processes.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        For the within-desktop-session use case, the GNOME and KDE desktops 
        have significant previous experience with different IPC solutions
        such as CORBA and DCOP. D-Bus is built on that experience and 
        carefully tailored to meet the needs of these desktop projects 
        in particular. D-Bus may or may not be appropriate for other 
        applications; the FAQ has some comparisons to other IPC systems.
      </para>
      <para>
        The problem solved by the systemwide or communication-with-the-OS case 
        is explained well by the following text from the Linux Hotplug project:
        <blockquote>
          <para>
           A gap in current Linux support is that policies with any sort of
           dynamic "interact with user" component aren't currently
           supported. For example, that's often needed the first time a network
           adapter or printer is connected, and to determine appropriate places
           to mount disk drives. It would seem that such actions could be
           supported for any case where a responsible human can be identified:
           single user workstations, or any system which is remotely
           administered.
          </para>

          <para>
            This is a classic "remote sysadmin" problem, where in this case
            hotplugging needs to deliver an event from one security domain
            (operating system kernel, in this case) to another (desktop for
            logged-in user, or remote sysadmin). Any effective response must go
            the other way: the remote domain taking some action that lets the
            kernel expose the desired device capabilities. (The action can often
            be taken asynchronously, for example letting new hardware be idle
            until a meeting finishes.) At this writing, Linux doesn't have
            widely adopted solutions to such problems. However, the new D-Bus
            work may begin to solve that problem.
          </para>
        </blockquote>
      </para>
      <para>
        D-Bus may happen to be useful for purposes other than the one it was
        designed for. Its general properties that distinguish it from 
        other forms of IPC are:
        <itemizedlist>
          <listitem>
            <para>
              Binary protocol designed to be used asynchronously 
              (similar in spirit to the X Window System protocol).
            </para>
          </listitem>
          <listitem>
            <para>
              Stateful, reliable connections held open over time.
            </para>
          </listitem>
          <listitem>
            <para>
              The message bus is a daemon, not a "swarm" or 
              distributed architecture.
            </para>
          </listitem>
          <listitem>
            <para>
              Many implementation and deployment issues are specified rather
              than left ambiguous/configurable/pluggable.
            </para>
          </listitem>
          <listitem>
            <para>
              Semantics are similar to the existing DCOP system, allowing 
              KDE to adopt it more easily.
            </para>
          </listitem>
          <listitem>
            <para>
              Security features to support the systemwide mode of the 
              message bus.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
  </sect1>
  <sect1 id="concepts">
    <title>Concepts</title>
    <para>
      Some basic concepts apply no matter what application framework you're
      using to write a D-Bus application. The exact code you write will be
      different for GLib vs. Qt vs. Python applications, however.
    </para>
    
    <para>
      Here is a diagram (<ulink url="diagram.png">png</ulink> <ulink
      url="diagram.svg">svg</ulink>) that may help you visualize the concepts
      that follow.
    </para>

    <sect2 id="objects">
      <title>Native Objects and Object Paths</title>
      <para>
        Your programming framework probably defines what an "object" is like;
        usually with a base class. For example: java.lang.Object, GObject, QObject,
        python's base Object, or whatever. Let's call this a <firstterm>native object</firstterm>.
      </para>
      <para>
        The low-level D-Bus protocol, and corresponding libdbus API, does not care about native objects. 
        However, it provides a concept called an 
        <firstterm>object path</firstterm>. The idea of an object path is that 
        higher-level bindings can name native object instances, and allow remote applications 
        to refer to them.
      </para>
      <para>
        The object path
        looks like a filesystem path, for example an object could be 
        named <literal>/org/kde/kspread/sheets/3/cells/4/5</literal>. 
        Human-readable paths are nice, but you are free to create an 
        object named <literal>/com/mycompany/c5yo817y0c1y1c5b</literal> 
        if it makes sense for your application.
      </para>
      <para>
        Namespacing object paths is smart, by starting them with the components
        of a domain name you own (e.g. <literal>/org/kde</literal>). This 
        keeps different code modules in the same process from stepping 
        on one another's toes.
      </para>
    </sect2>    

    <sect2 id="members">
      <title>Methods and Signals</title>

      <para>
        Each object has <firstterm>members</firstterm>; the two kinds of member
        are <firstterm>methods</firstterm> and
        <firstterm>signals</firstterm>. Methods are operations that can be
        invoked on an object, with optional input (aka arguments or "in
        parameters") and output (aka return values or "out parameters").
        Signals are broadcasts from the object to any interested observers 
        of the object; signals may contain a data payload.
      </para>

      <para>
        Both methods and signals are referred to by name, such as 
        "Frobate" or "OnClicked".
      </para>

    </sect2>

    <sect2 id="interfaces">
      <title>Interfaces</title>
      <para>
        Each object supports one or more <firstterm>interfaces</firstterm>.
        Think of an interface as a named group of methods and signals, 
        just as it is in GLib or Qt or Java. Interfaces define the 
        <emphasis>type</emphasis> of an object instance.
      </para>
      <para>
        DBus identifies interfaces with a simple namespaced string,
        something like <literal>org.freedesktop.Introspectable</literal>.
        Most bindings will map these interface names directly to 
        the appropriate programming language construct, for example 
        to Java interfaces or C++ pure virtual classes.
      </para>
    </sect2>

    <sect2 id="proxies">
      <title>Proxies</title>
      <para>
        A <firstterm>proxy object</firstterm> is a convenient native object created to 
        represent a remote object in another process. The low-level DBus API involves manually creating 
        a method call message, sending it, then manually receiving and processing 
        the method reply message. Higher-level bindings provide proxies as an alternative.
        Proxies look like a normal native object; but when you invoke a method on the proxy 
        object, the binding converts it into a DBus method call message, waits for the reply 
        message, unpacks the return value, and returns it from the native method..
      </para>
      <para>
        In pseudocode, programming without proxies might look like this:
        <programlisting>
          Message message = new Message("/remote/object/path", "MethodName", arg1, arg2);
          Connection connection = getBusConnection();
          connection.send(message);
          Message reply = connection.waitForReply(message);
          if (reply.isError()) {
             
          } else {
             Object returnValue = reply.getReturnValue();
          }
        </programlisting>
      </para>
      <para>
        Programming with proxies might look like this:
        <programlisting>
          Proxy proxy = new Proxy(getBusConnection(), "/remote/object/path");
          Object returnValue = proxy.MethodName(arg1, arg2);
        </programlisting>
      </para>
    </sect2>

    <sect2 id="bus-names">
      <title>Bus Names</title>

      <para>
        When each application connects to the bus daemon, the daemon immediately
        assigns it a name, called the <firstterm>unique connection name</firstterm>.
        A unique name begins with a ':' (colon) character. These names are never 
        reused during the lifetime of the bus daemon - that is, you know 
        a given name will always refer to the same application.
        An example of a unique name might be
        <literal>:34-907</literal>. The numbers after the colon have 
        no meaning other than their uniqueness.
      </para>

      <para>
        When a name is mapped 
        to a particular application's connection, that application is said to 
        <firstterm>own</firstterm> that name.
      </para>

      <para>
        Applications may ask to own additional <firstterm>well-known
        names</firstterm>. For example, you could write a specification to
        define a name called <literal>com.mycompany.TextEditor</literal>.
        Your definition could specify that to own this name, an application
        should have an object at the path
        <literal>/com/mycompany/TextFileManager</literal> supporting the
        interface <literal>org.freedesktop.FileHandler</literal>.
      </para>
      
      <para>
        Applications could then send messages to this bus name, 
        object, and interface to execute method calls.
      </para>

      <para>
        You could think of the unique names as IP addresses, and the
        well-known names as domain names. So
        <literal>com.mycompany.TextEditor</literal> might map to something like
        <literal>:34-907</literal> just as <literal>mycompany.com</literal> maps
        to something like <literal>192.168.0.5</literal>.
      </para>
      
      <para>
        Names have a second important use, other than routing messages.  They
        are used to track lifecycle. When an application exits (or crashes), its
        connection to the message bus will be closed by the operating system
        kernel. The message bus then sends out notification messages telling
        remaining applications that the application's names have lost their
        owner. By tracking these notifications, your application can reliably
        monitor the lifetime of other applications.
      </para>

      <para>
        Bus names can also be used to coordinate single-instance applications.
        If you want to be sure only one
        <literal>com.mycompany.TextEditor</literal> application is running for
        example, have the text editor application exit if the bus name already
        has an owner.
      </para>

    </sect2>

    <sect2 id="addresses">
      <title>Addresses</title>

      <para>
        Applications using D-Bus are either servers or clients.  A server
        listens for incoming connections; a client connects to a server. Once
        the connection is established, it is a symmetric flow of messages; the
        client-server distinction only matters when setting up the 
        connection.
      </para>

      <para>
        If you're using the bus daemon, as you probably are, your application 
        will be a client of the bus daemon. That is, the bus daemon listens 
        for connections and your application initiates a connection to the bus 
        daemon.
      </para>

      <para>
        A D-Bus <firstterm>address</firstterm> specifies where a server will
        listen, and where a client will connect.  For example, the address
        <literal>unix:path=/tmp/abcdef</literal> specifies that the server will
        listen on a UNIX domain socket at the path
        <literal>/tmp/abcdef</literal> and the client will connect to that
        socket. An address can also specify TCP/IP sockets, or any other
        transport defined in future iterations of the D-Bus specification.
      </para>

      <para>
        When using D-Bus with a message bus daemon,
        libdbus automatically discovers the address of the per-session bus 
        daemon by reading an environment variable. It discovers the 
        systemwide bus daemon by checking a well-known UNIX domain socket path
        (though you can override this address with an environment variable).
      </para>

      <para>
        If you're using D-Bus without a bus daemon, it's up to you to 
        define which application will be the server and which will be 
        the client, and specify a mechanism for them to agree on 
        the server's address. This is an unusual case.
      </para>

    </sect2>

    <sect2 id="bigpicture">
      <title>Big Conceptual Picture</title>

      <para>
        Pulling all these concepts together, to specify a particular 
        method call on a particular object instance, a number of 
        nested components have to be named:
        <programlisting>
          Address -&gt; [Bus Name] -&gt; Path -&gt; Interface -&gt; Method
        </programlisting>
        The bus name is in brackets to indicate that it's optional -- you only
        provide a name to route the method call to the right application
        when using the bus daemon. If you have a direct connection to another
        application, bus names aren't used; there's no bus daemon.
      </para>

      <para>
        The interface is also optional, primarily for historical 
        reasons; DCOP does not require specifying the interface, 
        instead simply forbidding duplicate method names 
        on the same object instance. D-Bus will thus let you 
        omit the interface, but if your method name is ambiguous 
        it is undefined which method will be invoked.
      </para>

    </sect2>

    <sect2 id="messages">
      <title>Messages - Behind the Scenes</title>
      <para>
        D-Bus works by sending messages between processes. If you're using 
        a sufficiently high-level binding, you may never work with messages directly.
      </para>
      <para>
        There are 4 message types:
        <itemizedlist>
          <listitem>
            <para>
              Method call messages ask to invoke a method 
              on an object.
            </para>
          </listitem>
          <listitem>
            <para>
              Method return messages return the results 
              of invoking a method.
            </para>
          </listitem>
          <listitem>
            <para>
              Error messages return an exception caused by 
              invoking a method.
            </para>
          </listitem>
          <listitem>
            <para>
              Signal messages are notifications that a given signal 
              has been emitted (that an event has occurred). 
              You could also think of these as "event" messages.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        A method call maps very simply to messages: you send a method call
        message, and receive either a method return message or an error message
        in reply.
      </para>
      <para>
        Each message has a <firstterm>header</firstterm>, including <firstterm>fields</firstterm>, 
        and a <firstterm>body</firstterm>, including <firstterm>arguments</firstterm>. You can think 
        of the header as the routing information for the message, and the body as the payload.
        Header fields might include the sender bus name, destination bus name, method or signal name, 
        and so forth. One of the header fields is a <firstterm>type signature</firstterm> describing the 
        values found in the body. For example, the letter "i" means "32-bit integer" so the signature 
        "ii" means the payload has two 32-bit integers.
      </para>
    </sect2>

    <sect2 id="callprocedure">
      <title>Calling a Method - Behind the Scenes</title>

      <para>
        A method call in DBus consists of two messages; a method call message sent from process A to process B, 
        and a matching method reply message sent from process B to process A. Both the call and the reply messages
        are routed through the bus daemon. The caller includes a different serial number in each call message, and the
        reply message includes this number to allow the caller to match replies to calls.
      </para>

      <para>
        The call message will contain any arguments to the method.
        The reply message may indicate an error, or may contain data returned by the method.
      </para>

      <para>
        A method invocation in DBus happens as follows:
        <itemizedlist>
          <listitem>
            <para>
              The language binding may provide a proxy, such that invoking a method on 
              an in-process object invokes a method on a remote object in another process. If so, the 
              application calls a method on the proxy, and the proxy
              constructs a method call message to send to the remote process.
            </para>
          </listitem>
          <listitem>
            <para>
              For more low-level APIs, the application may construct a method call message itself, without
              using a proxy.
            </para>
          </listitem>
          <listitem>
            <para>
              In either case, the method call message contains: a bus name belonging to the remote process; the name of the method; 
              the arguments to the method; an object path inside the remote process; and optionally the name of the 
              interface that specifies the method.
            </para>
          </listitem>
          <listitem>
            <para>
              The method call message is sent to the bus daemon.
            </para>
          </listitem>
          <listitem>
            <para>
              The bus daemon looks at the destination bus name. If a process owns that name, 
              the bus daemon forwards the method call to that process. Otherwise, the bus daemon
              creates an error message and sends it back as the reply to the method call message.
            </para>
          </listitem>
          <listitem>
            <para>
              The receiving process unpacks the method call message. In a simple low-level API situation, it 
              may immediately run the method and send a method reply message to the bus daemon.
              When using a high-level binding API, the binding might examine the object path, interface,
              and method name, and convert the method call message into an invocation of a method on 
              a native object (GObject, java.lang.Object, QObject, etc.), then convert the return 
              value from the native method into a method reply message.
            </para>
          </listitem>
          <listitem>
            <para>
              The bus daemon receives the method reply message and sends it to the process that 
              made the method call.
            </para>
          </listitem>
          <listitem>
            <para>
              The process that made the method call looks at the method reply and makes use of any 
              return values included in the reply. The reply may also indicate that an error occurred.
              When using a binding, the method reply message may be converted into the return value of 
              of a proxy method, or into an exception.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        The bus daemon never reorders messages. That is, if you send two method call messages to the same recipient, 
        they will be received in the order they were sent. The recipient is not required to reply to the calls
        in order, however; for example, it may process each method call in a separate thread, and return reply messages
        in an undefined order depending on when the threads complete. Method calls have a unique serial 
        number used by the method caller to match reply messages to call messages.
      </para>

    </sect2>

    <sect2 id="signalprocedure">
      <title>Emitting a Signal - Behind the Scenes</title>

      <para>
        A signal in DBus consists of a single message, sent by one process to any number of other processes. 
        That is, a signal is a unidirectional broadcast. The signal may contain arguments (a data payload), but 
        because it is a broadcast, it never has a "return value." Contrast this with a method call 
        (see <xref linkend="callprocedure"/>) where the method call message has a matching method reply message.
      </para>

      <para>
        The emitter (aka sender) of a signal has no knowledge of the signal recipients. Recipients register
        with the bus daemon to receive signals based on "match rules" - these rules would typically include the sender and 
        the signal name. The bus daemon sends each signal only to recipients who have expressed interest in that 
        signal.
      </para>

      <para>
        A signal in DBus happens as follows:
        <itemizedlist>
          <listitem>
            <para>
              A signal message is created and sent to the bus daemon. When using the low-level API this may be 
              done manually, with certain bindings it may be done for you by the binding when a native object
              emits a native signal or event.
            </para>
          </listitem>
          <listitem>
            <para>
              The signal message contains the name of the interface that specifies the signal;
              the name of the signal; the bus name of the process sending the signal; and 
              any arguments 
            </para>
          </listitem>
          <listitem>
            <para>
              Any process on the message bus can register "match rules" indicating which signals it 
              is interested in. The bus has a list of registered match rules.
            </para>
          </listitem>
          <listitem>
            <para>
              The bus daemon examines the signal and determines which processes are interested in it.
              It sends the signal message to these processes.
            </para>
          </listitem>
          <listitem>
            <para>
              Each process receiving the signal decides what to do with it; if using a binding, 
              the binding may choose to emit a native signal on a proxy object. If using the 
              low-level API, the process may just look at the signal sender and name and decide
              what to do based on that.
            </para>
          </listitem>
        </itemizedlist>
      </para>

    </sect2>

    <sect2 id="introspection">
      <title>Introspection</title>

      <para>
        D-Bus objects may support the interface <literal>org.freedesktop.DBus.Introspectable</literal>.
        This interface has one method <literal>Introspect</literal> which takes no arguments and returns
        an XML string. The XML string describes the interfaces, methods, and signals of the object.
        See the D-Bus specification for more details on this introspection format.
      </para>

    </sect2>

  </sect1>

  <sect1 id="glib-client">
    <title>GLib API: Using Remote Objects</title>

    <para>
      The GLib binding is defined in the header file
      <literal>&lt;dbus/dbus-glib.h&gt;</literal>.
    </para>

    <sect2 id="glib-typemappings">
      <title>D-Bus - GLib type mappings</title>
      <para>
	The heart of the GLib bindings for D-Bus is the mapping it
	provides between D-Bus "type signatures" and GLib types
	(<literal>GType</literal>). The D-Bus type system is composed of
	a number of "basic" types, along with several "container" types.
      </para>
      <sect3 id="glib-basic-typemappings">
	<title>Basic type mappings</title>
	<para>
	  Below is a list of the basic types, along with their associated
	  mapping to a <literal>GType</literal>.
	  <informaltable>
	    <tgroup cols="4">
	      <thead>
		<row>
		  <entry>D-Bus basic type</entry>
		  <entry>GType</entry>
		  <entry>Free function</entry>
		  <entry>Notes</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><literal>BYTE</literal></entry>
		  <entry><literal>G_TYPE_UCHAR</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>BOOLEAN</literal></entry>
		  <entry><literal>G_TYPE_BOOLEAN</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>INT16</literal></entry>
		  <entry><literal>G_TYPE_INT</literal></entry>
		  <entry></entry>
		  <entry>Will be changed to a <literal>G_TYPE_INT16</literal> once GLib has it</entry>
		  </row><row>
		  <entry><literal>UINT16</literal></entry>
		  <entry><literal>G_TYPE_UINT</literal></entry>
		  <entry></entry>
		  <entry>Will be changed to a <literal>G_TYPE_UINT16</literal> once GLib has it</entry>
		  </row><row>
		  <entry><literal>INT32</literal></entry>
		  <entry><literal>G_TYPE_INT</literal></entry>
		  <entry></entry>
		  <entry>Will be changed to a <literal>G_TYPE_INT32</literal> once GLib has it</entry>
		  </row><row>
		  <entry><literal>UINT32</literal></entry>
		  <entry><literal>G_TYPE_UINT</literal></entry>
		  <entry></entry>
		  <entry>Will be changed to a <literal>G_TYPE_UINT32</literal> once GLib has it</entry>
		  </row><row>
		  <entry><literal>INT64</literal></entry>
		  <entry><literal>G_TYPE_GINT64</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>UINT64</literal></entry>
		  <entry><literal>G_TYPE_GUINT64</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>DOUBLE</literal></entry>
		  <entry><literal>G_TYPE_DOUBLE</literal></entry>
		  <entry></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>STRING</literal></entry>
		  <entry><literal>G_TYPE_STRING</literal></entry>
		  <entry><literal>g_free</literal></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>OBJECT_PATH</literal></entry>
		  <entry><literal>DBUS_TYPE_G_PROXY</literal></entry>
		  <entry><literal>g_object_unref</literal></entry>
		  <entry>The returned proxy does not have an interface set; use <literal>dbus_g_proxy_set_interface</literal> to invoke methods</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  As you can see, the basic mapping is fairly straightforward.
	</para>
      </sect3>
      <sect3 id="glib-container-typemappings">
	<title>Container type mappings</title>
	<para>
	  The D-Bus type system also has a number of "container"
	  types, such as <literal>DBUS_TYPE_ARRAY</literal> and
	  <literal>DBUS_TYPE_STRUCT</literal>.  The D-Bus type system
	  is fully recursive, so one can for example have an array of
	  array of strings (i.e. type signature
	  <literal>aas</literal>).
	</para>
	<para>
	  However, not all of these types are in common use; for
	  example, at the time of this writing the author knows of no
	  one using <literal>DBUS_TYPE_STRUCT</literal>, or a
	  <literal>DBUS_TYPE_ARRAY</literal> containing any non-basic
	  type.  The approach the GLib bindings take is pragmatic; try
	  to map the most common types in the most obvious way, and
	  let using less common and more complex types be less
	  "natural".
	</para>
	<para>
	  First, D-Bus type signatures which have an "obvious"
	  corresponding built-in GLib type are mapped using that type:
	  <informaltable>
	    <tgroup cols="6">
	      <thead>
		<row>
		  <entry>D-Bus type signature</entry>
		  <entry>Description</entry>
		  <entry>GType</entry>
		  <entry>C typedef</entry>
		  <entry>Free function</entry>
		  <entry>Notes</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><literal>as</literal></entry>
		  <entry>Array of strings</entry>
		  <entry><literal>G_TYPE_STRV</literal></entry>
		  <entry><literal>char **</literal></entry>
		  <entry><literal>g_strfreev</literal></entry>
		  <entry></entry>
		  </row><row>
		  <entry><literal>v</literal></entry>
		  <entry>Generic value container</entry>
		  <entry><literal>G_TYPE_VALUE</literal></entry>
		  <entry><literal>GValue *</literal></entry>
		  <entry><literal>g_value_unset</literal></entry>
		  <entry>The calling conventions for values expect that method callers have allocated return values; see below.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</para>
	<para>
	  The next most common recursive type signatures are arrays of
	  basic values.  The most obvious mapping for arrays of basic
	  types is a <literal>GArray</literal>.  Now, GLib does not
	  provide a builtin <literal>GType</literal> for
	  <literal>GArray</literal>.  However, we actually need more than
	  that - we need a "parameterized" type which includes the
	  contained type.  Why we need this we will see below.
	</para>
	<para>
	  The approach taken is to create these types in the D-Bus GLib
	  bindings; however, there is nothing D-Bus specific about them.
	  In the future, we hope to include such "fundamental" types in GLib
	  itself.
	  <informaltable>
	    <tgroup cols="6">
	      <thead>
		<row>
		  <entry>D-Bus type signature</entry>
		  <entry>Description</entry>
		  <entry>GType</entry>
		  <entry>C typedef</entry>
		  <entry>Free function</entry>
		  <entry>Notes</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><literal>ay</literal></entry>
		  <entry>Array of bytes</entry>
		  <entry><literal>DBUS_TYPE_G_BYTE_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>au</literal></entry>
		  <entry>Array of uint</entry>
		  <entry><literal>DBUS_TYPE_G_UINT_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>ai</literal></entry>
		  <entry>Array of int</entry>
		  <entry><literal>DBUS_TYPE_G_INT_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>ax</literal></entry>
		  <entry>Array of int64</entry>
		  <entry><literal>DBUS_TYPE_G_INT64_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>at</literal></entry>
		  <entry>Array of uint64</entry>
		  <entry><literal>DBUS_TYPE_G_UINT64_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>ad</literal></entry>
		  <entry>Array of double</entry>
		  <entry><literal>DBUS_TYPE_G_DOUBLE_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry><literal>ab</literal></entry>
		  <entry>Array of boolean</entry>
		  <entry><literal>DBUS_TYPE_G_BOOLEAN_ARRAY</literal></entry>
		  <entry><literal>GArray *</literal></entry>
		  <entry>g_array_free</entry>
		  <entry></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</para>
	<para>
	  D-Bus also includes a special type DBUS_TYPE_DICT_ENTRY which
	  is only valid in arrays.  It's intended to be mapped to a "dictionary"
	  type by bindings.  The obvious GLib mapping here is GHashTable.  Again,
	  however, there is no builtin <literal>GType</literal> for a GHashTable.
	  Moreover, just like for arrays, we need a parameterized type so that
	  the bindings can communiate which types are contained in the hash table.
	</para>
	<para>
	  At present, only strings are supported.  Work is in progress to
	  include more types.
	  <informaltable>
	    <tgroup cols="6">
	      <thead>
		<row>
		  <entry>D-Bus type signature</entry>
		  <entry>Description</entry>
		  <entry>GType</entry>
		  <entry>C typedef</entry>
		  <entry>Free function</entry>
		  <entry>Notes</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><literal>a{ss}</literal></entry>
		  <entry>Dictionary mapping strings to strings</entry>
		  <entry><literal>DBUS_TYPE_G_STRING_STRING_HASHTABLE</literal></entry>
		  <entry><literal>GHashTable *</literal></entry>
		  <entry>g_hash_table_destroy</entry>
		  <entry></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</para>
      </sect3>
      <sect3 id="glib-generic-typemappings">
	<title>Arbitrarily recursive type mappings</title>
	<para>
	  Finally, it is possible users will want to write or invoke D-Bus
	  methods which have arbitrarily complex type signatures not
	  directly supported by these bindings.  For this case, we have a
	  <literal>DBusGValue</literal> which acts as a kind of special
	  variant value which may be iterated over manually.  The
	  <literal>GType</literal> associated is
	  <literal>DBUS_TYPE_G_VALUE</literal>.
	</para>
	<para>
	  TODO insert usage of <literal>DBUS_TYPE_G_VALUE</literal> here.
	</para>
      </sect3>
    </sect2>
    <sect2 id="sample-program-1">
      <title>A sample program</title>
      <para>Here is a D-Bus program using the GLib bindings.
<programlisting>      
int
main (int argc, char **argv)
{
  DBusGConnection *connection;
  GError *error;
  DBusGProxy *proxy;
  char **name_list;
  char **name_list_ptr;
  
  g_type_init ();

  error = NULL;
  connection = dbus_g_bus_get (DBUS_BUS_SESSION,
                               &amp;error);
  if (connection == NULL)
    {
      g_printerr ("Failed to open connection to bus: %s\n",
                  error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Create a proxy object for the "bus driver" (name "org.freedesktop.DBus") */
  
  proxy = dbus_g_proxy_new_for_name (connection,
                                     DBUS_SERVICE_DBUS,
                                     DBUS_PATH_DBUS,
                                     DBUS_INTERFACE_DBUS);

  /* Call ListNames method, wait for reply */
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "ListNames", &amp;error, G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;name_list, G_TYPE_INVALID))
    {
      /* Just do demonstrate remote exceptions versus regular GError */
      if (error->domain == DBUS_GERROR &amp;&amp; error->code == DBUS_GERROR_REMOTE_EXCEPTION)
        g_printerr ("Caught remote method exception %s: %s",
	            dbus_g_error_get_name (error),
	            error-&gt;message);
      else
        g_printerr ("Error: %s\n", error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Print the results */
 
  g_print ("Names on the message bus:\n");
  
  for (name_list_ptr = name_list; *name_list_ptr; name_list_ptr++)
    {
      g_print ("  %s\n", *name_list_ptr);
    }
  g_strfreev (name_list);

  g_object_unref (proxy);

  return 0;
}
</programlisting>
    </para>
    </sect2>
    <sect2 id="glib-program-setup">
      <title>Program initalization</title>
      <para>
	A connection to the bus is acquired using
	<literal>dbus_g_bus_get</literal>.  Next, a proxy
	is created for the object "/org/freedesktop/DBus" with
	interface <literal>org.freedesktop.DBus</literal>
	on the service <literal>org.freedesktop.DBus</literal>.
	This is a proxy for the message bus itself.
      </para>
    </sect2>
    <sect2 id="glib-method-invocation">
      <title>Understanding method invocation</title>
      <para>
	You have a number of choices for method invocation.  First, as
	used above, <literal>dbus_g_proxy_call</literal> sends a
	method call to the remote object, and blocks until a reply is
	recieved.  The outgoing arguments are specified in the varargs
	array, terminated with <literal>G_TYPE_INVALID</literal>.
	Next, pointers to return values are specified, followed again
	by <literal>G_TYPE_INVALID</literal>.
      </para>
      <para>
	To invoke a method asynchronously, use
	<literal>dbus_g_proxy_begin_call</literal>.  This returns a
	<literal>DBusGPendingCall</literal> object; you may then set a
	notification function using
	<literal>dbus_g_pending_call_set_notify</literal>.
      </para>
    </sect2>
    <sect2 id="glib-signal-connection">
      <title>Connecting to object signals</title>
      <para>
	You may connect to signals using
	<literal>dbus_g_proxy_add_signal</literal> and
	<literal>dbus_g_proxy_connect_signal</literal>.  You must
	invoke <literal>dbus_g_proxy_add_signal</literal> to specify
	the signature of your signal handlers; you may then invoke
	<literal>dbus_g_proxy_connect_signal</literal> multiple times.
      </para>
      <para>
	Note that it will often be the case that there is no builtin
	marshaller for the type signature of a remote signal.  In that
	case, you must generate a marshaller yourself by using
	<application>glib-genmarshal</application>, and then register
	it using <literal>dbus_g_object_register_marshaller</literal>.
      </para>
    </sect2>
    <sect2 id="glib-error-handling">
      <title>Error handling and remote exceptions</title>
      <para>
	All of the GLib binding methods such as
	<literal>dbus_g_proxy_end_call</literal> return a
	<literal>GError</literal>.  This <literal>GError</literal> can
	represent two different things:
      <itemizedlist>
	<listitem>
	  <para>
	    An internal D-Bus error, such as an out-of-memory
	    condition, an I/O error, or a network timeout.  Errors
	    generated by the D-Bus library itself have the domain
	    <literal>DBUS_GERROR</literal>, and a corresponding code
	    such as <literal>DBUS_GERROR_NO_MEMORY</literal>.  It will
	    not be typical for applications to handle these errors
	    specifically.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    A remote D-Bus exception, thrown by the peer, bus, or
	    service.  D-Bus remote exceptions have both a textual
	    "name" and a "message".  The GLib bindings store this
	    information in the <literal>GError</literal>, but some
	    special rules apply.
	  </para>
	  <para>
	    The set error will have the domain
	    <literal>DBUS_GERROR</literal> as above, and will also
	    have the code
	    <literal>DBUS_GERROR_REMOTE_EXCEPTION</literal>.  In order
	    to access the remote exception name, you must use a
	    special accessor, such as
	    <literal>dbus_g_error_has_name</literal> or
	    <literal>dbus_g_error_get_name</literal>.  The remote
	    exception detailed message is accessible via the regular
	    GError <literal>message</literal> member.
	  </para>
	</listitem>
      </itemizedlist>
      </para>
    </sect2>
    <sect2 id="glib-more-examples">
      <title>More examples of method invocation</title>
      <sect3 id="glib-sending-stuff">
	<title>Sending an integer and string, receiving an array of bytes</title>
	<para>
<programlisting>
  GArray *arr;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "Foobar", &amp;error,
                          G_TYPE_INT, 42, G_TYPE_STRING, "hello",
			  G_TYPE_INVALID,
			  DBUS_TYPE_G_UCHAR_ARRAY, &amp;arr, G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_assert (arr != NULL);
   printf ("got back %u values", arr->len);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-sending-hash">
	<title>Sending a GHashTable</title>
	<para>
<programlisting>
  GHashTable *hash = g_hash_table_new (g_str_hash, g_str_equal);
  guint32 ret;
  
  g_hash_table_insert (hash, "foo", "bar");
  g_hash_table_insert (hash, "baz", "whee");

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "HashSize", &amp;error,
                          DBUS_TYPE_G_STRING_STRING_HASH, hash, G_TYPE_INVALID,
			  G_TYPE_UINT, &amp;ret, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_hash_table_destroy (hash);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-receiving-bool-int">
	<title>Receiving a boolean and a string</title>
	<para>
<programlisting>
  gboolean boolret;
  char *strret;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetStuff", &amp;error,
			  G_TYPE_INVALID,
                          G_TYPE_BOOLEAN, &amp;boolret,
                          G_TYPE_STRING, &amp;strret,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  printf ("%s %s", boolret ? "TRUE" : "FALSE", strret);
  g_free (strret);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-sending-str-arrays">
	<title>Sending two arrays of strings</title>
	<para>
<programlisting>
  /* NULL terminate */
  char *strs_static[] = {"foo", "bar", "baz", NULL};
  /* Take pointer to array; cannot pass array directly */
  char **strs_static_p = strs_static;
  char **strs_dynamic;

  strs_dynamic = g_new (char *, 4);
  strs_dynamic[0] = g_strdup ("hello");
  strs_dynamic[1] = g_strdup ("world");
  strs_dynamic[2] = g_strdup ("!");
  /* NULL terminate */
  strs_dynamic[3] = NULL;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "TwoStrArrays", &amp;error,
                          G_TYPE_STRV, strs_static_p,
                          G_TYPE_STRV, strs_dynamic,
			  G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_strfreev (strs_dynamic);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-getting-str-array">
	<title>Sending a boolean, receiving an array of strings</title>
	<para>
<programlisting>
  char **strs;
  char **strs_p;
  gboolean blah;

  error = NULL;
  blah = TRUE;
  if (!dbus_g_proxy_call (proxy, "GetStrs", &amp;error,
                          G_TYPE_BOOLEAN, blah,
			  G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;strs,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   for (strs_p = strs; *strs_p; strs_p++)
     printf ("got string: \"%s\"", *strs_p);
   g_strfreev (strs);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-sending-variant">
	<title>Sending a variant</title>
	<para>
<programlisting>
  GValue val = {0, };

  g_value_init (&amp;val, G_TYPE_STRING);
  g_value_set_string (&amp;val, "hello world");
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "SendVariant", &amp;error,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_value_unset (&amp;val);
</programlisting>
	</para>
      </sect3>
      <sect3 id="glib-receiving-variant">
	<title>Receiving a variant</title>
	<para>
<programlisting>
  GValue val = {0, };

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetVariant", &amp;error, G_TYPE_INVALID,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  if (G_VALUE_TYPE (&amp;val) == G_TYPE_STRING)
    printf ("%s\n", g_value_get_string (&amp;val));
  else if (G_VALUE_TYPE (&amp;val) == G_TYPE_INT)
    printf ("%d\n", g_value_get_int (&amp;val));
  else
    ...
  g_value_unset (&amp;val);
</programlisting>
	</para>
      </sect3>
    </sect2>

    <sect2 id="glib-generated-bindings">
      <title>Generated Bindings</title>
      <para>
        By using the Introspection XML files, convenient client-side bindings
        can be automatically created to ease the use of a remote DBus object.
      </para>
      <para>
        Here is a sample XML file which describes an object that exposes
        one method, named <literal>ManyArgs</literal>.
        <programlisting>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;node name="/com/example/MyObject"&gt;
  &lt;interface name="com.example.MyObject"&gt;
    &lt;method name="ManyArgs"&gt;
      &lt;arg type="u" name="x" direction="in" /&gt;
      &lt;arg type="s" name="str" direction="in" /&gt;
      &lt;arg type="d" name="trouble" direction="in" /&gt;
      &lt;arg type="d" name="d_ret" direction="out" /&gt;
      &lt;arg type="s" name="str_ret" direction="out" /&gt;
    &lt;/method&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</programlisting>
      </para>
      <para>
        Run <literal>dbus-binding-tool --mode=glib-client
          <replaceable>FILENAME</replaceable> &gt;
          <replaceable>HEADER_NAME</replaceable></literal> to generate the header
        file.  For example: <command>dbus-binding-tool --mode=glib-client
          my-object.xml &gt; my-object-bindings.h</command>.  This will generate
        inline functions with the following prototypes:
        <programlisting>
/* This is a blocking call */
gboolean
com_example_MyObject_many_args (DBusGProxy *proxy, const guint IN_x,
                                const char * IN_str, const gdouble IN_trouble,
                                gdouble* OUT_d_ret, char ** OUT_str_ret,
                                GError **error);

/* This is a non-blocking call */
DBusGProxyCall*
com_example_MyObject_many_args_async (DBusGProxy *proxy, const guint IN_x,
                                      const char * IN_str, const gdouble IN_trouble,
                                      com_example_MyObject_many_args_reply callback,
                                      gpointer userdata);

/* This is the typedef for the non-blocking callback */
typedef void
(*com_example_MyObject_many_args_reply)
(DBusGProxy *proxy, gdouble OUT_d_ret, char * OUT_str_ret,
 GError *error, gpointer userdata);
</programlisting>
        The first argument in all functions is a <literal>DBusGProxy
        *</literal>, which you should create with the usual
        <literal>dbus_g_proxy_new_*</literal> functions.  Following that are the
        "in" arguments, and then either the "out" arguments and a
        <literal>GError *</literal> for the synchronous (blocking) function, or
        callback and user data arguments for the asynchronous (non-blocking)
        function.  The callback in the asynchronous function passes the
        <literal>DBusGProxy *</literal>, the returned "out" arguments, an
        <literal>GError *</literal> which is set if there was an error otherwise
        <literal>NULL</literal>, and the user data.
      </para>
      <para>
        As with the server-side bindings support (see <xref
        linkend="glib-server"/>), the exact behaviour of the client-side
        bindings can be manipulated using "annotations".  Currently the only
        annotation used by the client bindings is
        <literal>org.freedesktop.DBus.GLib.NoReply</literal>, which sets the
        flag indicating that the client isn't expecting a reply to the method
        call, so a reply shouldn't be sent.  This is often used to speed up
        rapid method calls where there are no "out" arguments, and not knowing
        if the method succeeded is an acceptable compromise to half the traffic
        on the bus.
      </para>
    </sect2>
  </sect1>

  <sect1 id="glib-server">
    <title>GLib API: Implementing Objects</title>
    <para>
      At the moment, to expose a GObject via D-Bus, you must
      write XML by hand which describes the methods exported
      by the object.  In the future, this manual step will
      be obviated by the upcoming GLib introspection support.
    </para>
    <para>
      Here is a sample XML file which describes an object that exposes
      one method, named <literal>ManyArgs</literal>.
<programlisting>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;node name="/com/example/MyObject"&gt;

  &lt;interface name="com.example.MyObject"&gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object"/&gt;
    &lt;method name="ManyArgs"&gt;
      &lt;!-- This is optional, and in this case is redunundant --&gt;
      &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object_many_args"/&gt;
      &lt;arg type="u" name="x" direction="in" /&gt;
      &lt;arg type="s" name="str" direction="in" /&gt;
      &lt;arg type="d" name="trouble" direction="in" /&gt;
      &lt;arg type="d" name="d_ret" direction="out" /&gt;
      &lt;arg type="s" name="str_ret" direction="out" /&gt;
    &lt;/method&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</programlisting>
    </para>
    <para>
      This XML is in the same format as the D-Bus introspection XML
      format. Except we must include an "annotation" which give the C
      symbols corresponding to the object implementation prefix
      (<literal>my_object</literal>).  In addition, if particular
      methods symbol names deviate from C convention
      (i.e. <literal>ManyArgs</literal> -&gt;
      <literal>many_args</literal>), you may specify an annotation
      giving the C symbol.
    </para>
    <para>
      Once you have written this XML, run <literal>dbus-binding-tool --mode=glib-server <replaceable>FILENAME</replaceable> &gt; <replaceable>HEADER_NAME</replaceable>.</literal> to
      generate a header file.  For example: <command>dbus-binding-tool --mode=glib-server my-object.xml &gt; my-object-glue.h</command>.
    </para>
    <para>
      Next, include the generated header in your program, and invoke
      <literal>dbus_g_object_class_install_info</literal> in the class
      initializer, passing the object class and "object info" included in the
      header.  For example:
      <programlisting>
	dbus_g_object_type_install_info (COM_FOO_TYPE_MY_OBJECT, &amp;com_foo_my_object_info);
      </programlisting>
      This should be done exactly once per object class.
    </para>
    <para>
      To actually implement the method, just define a C function named e.g.
      <literal>my_object_many_args</literal> in the same file as the info
      header is included.  At the moment, it is required that this function
      conform to the following rules:
      <itemizedlist>
	<listitem>
	  <para>
	    The function must return a value of type <literal>gboolean</literal>;
	    <literal>TRUE</literal> on success, and <literal>FALSE</literal>
	    otherwise.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The first parameter is a pointer to an instance of the object.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Following the object instance pointer are the method
	    input values.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Following the input values are pointers to return values.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The final parameter must be a <literal>GError **</literal>.
	    If the function returns <literal>FALSE</literal> for an
	    error, the error parameter must be initalized with
	    <literal>g_set_error</literal>.
	  </para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      Finally, you can export an object using <literal>dbus_g_connection_register_g_object</literal>.  For example:
      <programlisting>
	  dbus_g_connection_register_g_object (connection,
                                               "/com/foo/MyObject",
                                               obj);
      </programlisting>
    </para>

    <sect2 id="glib-annotations">
      <title>Server-side Annotations</title>
      <para>
        There are several annotations that are used when generating the
        server-side bindings.  The most common annotation is
        <literal>org.freedesktop.DBus.GLib.CSymbol</literal> but there are other
        annotations which are often useful.
        <variablelist>
          <varlistentry>
            <term><literal>org.freedesktop.DBus.GLib.CSymbol</literal></term>
            <listitem>
              <para>
                This annotation is used to specify the C symbol names for
                the various types (interface, method, etc), if it differs from the
                name DBus generates.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>org.freedesktop.DBus.GLib.Async</literal></term>
            <listitem>
              <para>
                This annotation marks the method implementation as an
                asynchronous function, which doesn't return a response straight
                away but will send the response at some later point to complete
                the call.  This is used to implement non-blocking services where
                method calls can take time.
              </para>
              <para>
                When a method is asynchronous, the function prototype is
                different. It is required that the function conform to the
                following rules:
                <itemizedlist>
                  <listitem>
                    <para>
                      The function must return a value of type <literal>gboolean</literal>;
                      <literal>TRUE</literal> on success, and <literal>FALSE</literal>
                      otherwise. TODO: the return value is currently ignored.
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      The first parameter is a pointer to an instance of the object.
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      Following the object instance pointer are the method
                      input values.
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      The final parameter must be a
                      <literal>DBusGMethodInvocation *</literal>.  This is used
                      when sending the response message back to the client, by
                      calling <literal>dbus_g_method_return</literal> or
                      <literal>dbus_g_method_return_error</literal>.
                    </para>
                  </listitem>
                </itemizedlist>
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>org.freedesktop.DBus.GLib.Const</literal></term>
            <listitem>
              <para>This attribute can only be applied to "out"
              <literal>&lt;arg&gt;</literal> nodes, and specifies that the
              parameter isn't being copied when returned.  For example, this
              turns a 's' argument from a <literal>char **</literal> to a
              <literal>const char **</literal>, and results in the argument not
              being freed by DBus after the message is sent.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>org.freedesktop.DBus.GLib.ReturnVal</literal></term>
            <listitem>
              <para>
                This attribute can only be applied to "out"
                <literal>&lt;arg&gt;</literal> nodes, and alters the expected
                function signature.  It currently can be set to two values:
                <literal>""</literal> or <literal>"error"</literal>.  The
                argument marked with this attribute is not returned via a
                pointer argument, but by the function's return value.  If the
                attribute's value is the empty string, the <literal>GError
                *</literal> argument is also omitted so there is no standard way
                to return an error value.  This is very useful for interfacing
                with existing code, as it is possible to match existing APIs.
                If the attribute's value is <literal>"error"</literal>, then the
                final argument is a <literal>GError *</literal> as usual.
              </para>
              <para>
                Some examples to demonstrate the usage. This introspection XML:
                <programlisting>
&lt;method name="Increment"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" /&gt;
&lt;/method&gt;
                </programlisting>
                Expects the following function declaration:
                <programlisting>
gboolean
my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error);
                </programlisting>
              </para>
              <para>
                This introspection XML:
                <programlisting>
&lt;method name="IncrementRetval"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" &gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.ReturnVal" value=""/&gt;
  &lt;/arg&gt;
&lt;/method&gt;
                </programlisting>
                Expects the following function declaration:
                <programlisting>
gint32
my_object_increment_retval (MyObject *obj, gint32 x)
                </programlisting>
              </para>
              <para>
                This introspection XML:
                <programlisting>
&lt;method name="IncrementRetvalError"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" &gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.ReturnVal" value="error"/&gt;
  &lt;/arg&gt;
&lt;/method&gt;
                </programlisting>
                Expects the following function declaration:
                <programlisting>
gint32
my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error)
                </programlisting>
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
    </sect2>
  </sect1>

  <sect1 id="python-client">
    <title>Python API</title>
    <para>
      The Python API, dbus-python, is now documented separately in
      <ulink url="http://dbus.freedesktop.org/doc/dbus-python/doc/tutorial.html">the dbus-python tutorial</ulink> (also available in doc/tutorial.txt,
      and doc/tutorial.html if built with python-docutils, in the dbus-python
      source distribution).
    </para>
  </sect1>

  <sect1 id="qt-client">
    <title>Qt API: Using Remote Objects</title>
    <para>
      
      The Qt bindings are not yet documented.

    </para>
  </sect1>

  <sect1 id="qt-server">
    <title>Qt API: Implementing Objects</title>
    <para>
      The Qt bindings are not yet documented.
    </para>
  </sect1>
</article>
