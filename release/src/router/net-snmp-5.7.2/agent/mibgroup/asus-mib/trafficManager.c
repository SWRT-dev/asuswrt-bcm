/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "trafficManager.h"
#include <nmp.h>

#define MAXQOSRULE	32
#define QOSRULESTRNUM	256
static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;

/* 
 * trafficManager_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid trafficManager_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,10 };

/* 
 * variable7 trafficManager_variables:
 *   this variable defines function callbacks and type return information 
 *   for the trafficManager mib section 
 */

struct variable7 trafficManager_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define ENABLEQOS		1
{ENABLEQOS,  ASN_INTEGER,  RWRITE,  var_trafficManager, 2,  { 1,1 }},
#define UPLOADBANDWIDTH		2
{UPLOADBANDWIDTH,  ASN_INTEGER,  RWRITE,  var_trafficManager, 2,  { 1,2 }},
#define DOWNLOADBANDWIDTH		3
{DOWNLOADBANDWIDTH,  ASN_INTEGER,  RWRITE,  var_trafficManager, 2,  { 1,3 }},
#define UPHIGHESTMINRESERVEBD		4
{UPHIGHESTMINRESERVEBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,1 }},
#define UPHIGHESTMAXBD		5
{UPHIGHESTMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,2 }},
#define UPHIGHMINRESERVEBD		6
{UPHIGHMINRESERVEBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,3 }},
#define UPHIGHMAXBD		7
{UPHIGHMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,4 }},
#define UPMEDIUMMINRESERVEBD		8
{UPMEDIUMMINRESERVEBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,5 }},
#define UPMEDIUMMAXBD		9
{UPMEDIUMMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,6 }},
#define UPLOWMINRESERVEBD		10
{UPLOWMINRESERVEBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,7 }},
#define UPLOWMAXBD		11
{UPLOWMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,8 }},
#define UPLOWESTMINRESERVEBD		12
{UPLOWESTMINRESERVEBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,9 }},
#define UPLOWESTMAXBD		13
{UPLOWESTMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,1,10 }},
#define DOWNHIGHESTMAXBD		14
{DOWNHIGHESTMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,2,1 }},
#define DOWNHIGHMAXBD		15
{DOWNHIGHMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,2,2 }},
#define DOWNMEDIUMMAXBD		16
{DOWNMEDIUMMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,2,3 }},
#define DOWNLOWMAXBD		17
{DOWNLOWMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,2,4 }},
#define DOWNLOWESTMAXBD		18
{DOWNLOWESTMAXBD,  ASN_INTEGER,  RWRITE,  var_trafficManager, 3,  { 3,2,5 }},
#define HIGHESTPRIORITYPACKET		19
{HIGHESTPRIORITYPACKET,  ASN_OCTET_STR,  RWRITE,  var_trafficManager, 2,  { 3,3 }},

#define USERSPECIFYRULEINDEX		20
{USERSPECIFYRULEINDEX,  ASN_INTEGER,  RONLY,   var_userSpecifyRuleTable, 4,  { 2,1, 1, 1 }},
#define USERSPECIFYRULESERVICENAME		21
{USERSPECIFYRULESERVICENAME,  ASN_OCTET_STR,  RWRITE,  var_userSpecifyRuleTable, 4,  { 2,1, 1, 2 }},
#define USERSPECIFYRULESRCIPORMAC		22
{USERSPECIFYRULESRCIPORMAC,  ASN_OCTET_STR,  RWRITE,  var_userSpecifyRuleTable, 4,  { 2,1, 1, 3 }},
#define USERSPECIFYRULEDESTPORT		23
{USERSPECIFYRULEDESTPORT,  ASN_OCTET_STR,  RWRITE,  var_userSpecifyRuleTable, 4,  { 2,1, 1, 4 }},
#define USERSPECIFYRULEPROTOCOL		24
{USERSPECIFYRULEPROTOCOL,  ASN_INTEGER,  RWRITE,  var_userSpecifyRuleTable, 4,  { 2,1, 1, 5 }},
#define USERSPECIFYRULEMINTRANSFERRED		25
{USERSPECIFYRULEMINTRANSFERRED,  ASN_OCTET_STR,  RWRITE,  var_userSpecifyRuleTable, 4,  { 2,1, 1, 6 }},
#define USERSPECIFYRULEMAXTRANSFERRED		26
{USERSPECIFYRULEMAXTRANSFERRED,  ASN_OCTET_STR,  RWRITE,  var_userSpecifyRuleTable, 4,  { 2,1, 1, 7 }},
#define USERSPECIFYRULEPRIORITY		27
{USERSPECIFYRULEPRIORITY,  ASN_INTEGER,  RWRITE,  var_userSpecifyRuleTable, 4,  { 2,1, 1, 8 }},
#define USERSPECIFYRULEDELENTRY		28
{USERSPECIFYRULEDELENTRY,  ASN_INTEGER,  RWRITE,  var_userSpecifyRuleTable, 4,  { 2,1, 1, 9 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the trafficManager module */
void
init_trafficManager(void)
{

    DEBUGMSGTL(("trafficManager", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("trafficManager", trafficManager_variables, variable7,
               trafficManager_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_trafficManager():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_trafficManager(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)	//Doesn't support in AP and repeater mode
	   return NULL;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case ENABLEQOS:
        *write_method = write_enableQoS;
        if(nmp_safe_get("qos_enable") != NULL)
      	{
    		tmpval = nmp_get_int("qos_enable");
    		if(tmpval == 1) /* enable */
    			tmpval = 1;
    		else if(tmpval == 0) /* disable */
    			tmpval = 2;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case UPLOADBANDWIDTH:
        *write_method = write_uploadBandwidth;
        if(nmp_safe_get("qos_obw") != NULL)
      	{
    		tmpval = nmp_get_int("qos_obw");
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case DOWNLOADBANDWIDTH:
        *write_method = write_downloadBandwidth;
        if(nmp_safe_get("qos_ibw") != NULL)
      	{
    		tmpval = nmp_get_int("qos_ibw");
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case UPHIGHESTMINRESERVEBD:
        *write_method = write_upHighestMinReserveBd;
    	tmpval = get_qos_orates(0, 1);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPHIGHESTMAXBD:
        *write_method = write_upHighestMaxBd;
    	tmpval = get_qos_orates(0, 0);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPHIGHMINRESERVEBD:
        *write_method = write_upHighMinReserveBd;
    	tmpval = get_qos_orates(1, 1);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPHIGHMAXBD:
        *write_method = write_upHighMaxBd;
    	tmpval = get_qos_orates(1, 0);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPMEDIUMMINRESERVEBD:
        *write_method = write_upMediumMinReserveBd;
    	tmpval = get_qos_orates(2, 1);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPMEDIUMMAXBD:
        *write_method = write_upMediumMaxBd;
    	tmpval = get_qos_orates(2, 0);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPLOWMINRESERVEBD:
        *write_method = write_upLowMinReserveBd;
    	tmpval = get_qos_orates(3, 1);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPLOWMAXBD:
        *write_method = write_upLowMaxBd;
    	tmpval = get_qos_orates(3, 0);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPLOWESTMINRESERVEBD:
        *write_method = write_upLowestMinReserveBd;
    	tmpval = get_qos_orates(4, 1);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case UPLOWESTMAXBD:
        *write_method = write_upLowestMaxBd;
    	tmpval = get_qos_orates(4, 0);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case DOWNHIGHESTMAXBD:
        *write_method = write_downHighestMaxBd;
    	tmpval = get_qos_irates(0);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case DOWNHIGHMAXBD:
        *write_method = write_downHighMaxBd;
    	tmpval = get_qos_irates(1);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case DOWNMEDIUMMAXBD:
        *write_method = write_downMediumMaxBd;
    	tmpval = get_qos_irates(2);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case DOWNLOWMAXBD:
        *write_method = write_downLowMaxBd;
    	tmpval = get_qos_irates(3);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case DOWNLOWESTMAXBD:
        *write_method = write_downLowestMaxBd;
    	tmpval = get_qos_irates(4);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    case HIGHESTPRIORITYPACKET:
        *write_method = write_highestPriorityPacket;
        tmpval = 0;
    	if(!strcmp(nmp_safe_get("qos_ack"), "on")) tmpval += (1 << 7);
    	if(!strcmp(nmp_safe_get("qos_syn"), "on")) tmpval += (1 << 6);
    	if(!strcmp(nmp_safe_get("qos_fin"), "on")) tmpval += (1 << 5);
    	if(!strcmp(nmp_safe_get("qos_rst"), "on")) tmpval += (1 << 4);
    	if(!strcmp(nmp_safe_get("qos_icmp"), "on")) tmpval += (1 << 3);
    	*var_len = sizeof( long );
    	return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_userSpecifyRuleTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_trafficManager above.
 */
unsigned char *
var_userSpecifyRuleTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *srcIPorMac, *destPort, *protocol, *transferred, *priority, *transMin, *transMax;

    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(qos_rulelist[qos_rulelist_count], b);
    		qos_rulelist_count++;		
    	}
    	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXQOSRULE /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case USERSPECIFYRULEINDEX:
        return NULL;
    case USERSPECIFYRULESERVICENAME:
        *write_method = write_userSpecifyRuleServiceName;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);
        if(index <= qos_rulelist_count-1) {
        	if (strlen(qos_rulelist[index])) {
    			if(vstrsep(qos_rulelist[index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
        		strcpy(tmpstr, serviceName);
            }
    	}
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case USERSPECIFYRULESRCIPORMAC:
        *write_method = write_userSpecifyRuleSrcIPorMAC;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);        
        if(index <= qos_rulelist_count-1) {
        	if (strlen(qos_rulelist[index])) {
    			if(vstrsep(qos_rulelist[index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			strcpy(tmpstr, srcIPorMac);
    		}
    	}
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case USERSPECIFYRULEDESTPORT:
        *write_method = write_userSpecifyRuleDestPort;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);       
        if(index <= qos_rulelist_count-1) {
        	if (strlen(qos_rulelist[index])) {
    			if(vstrsep(qos_rulelist[index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			strcpy(tmpstr, destPort);
    		}
    	}
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;        
    case USERSPECIFYRULEPROTOCOL:
        *write_method = write_userSpecifyRuleProtocol;
        index = name[*length-1]-1;
        tmpval = 1;     
        if(index <= qos_rulelist_count-1) {
        	if (strlen(qos_rulelist[index])) {
    			if(vstrsep(qos_rulelist[index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			
    			if(!strcmp(protocol, "tcp")) tmpval = 1;
    			else if(!strcmp(protocol, "udp")) tmpval = 2;
    			else if(!strcmp(protocol, "tcp/udp")) tmpval = 3;
    			else if(!strcmp(protocol, "any")) tmpval = 4;
    		}
    	}
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case USERSPECIFYRULEMINTRANSFERRED:
        *write_method = write_userSpecifyRuleMinTransferred;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);        
        if(index <= qos_rulelist_count-1) {
        	if (strlen(qos_rulelist[index])) {
    			if(vstrsep(qos_rulelist[index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			if(vstrsep(transferred, "~", &transMin, &transMax) == 2)
                    strcpy(tmpstr, transMin);
    		}
    	}
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr; 
    case USERSPECIFYRULEMAXTRANSFERRED:
        *write_method = write_userSpecifyRuleMaxTransferred;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);        
        if(index <= qos_rulelist_count-1) {
        	if (strlen(qos_rulelist[index])) {
    			if(vstrsep(qos_rulelist[index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			if(vstrsep(transferred, "~", &transMin, &transMax) == 2)
                    strcpy(tmpstr, transMax);
    		}
    	}
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr; 
    case USERSPECIFYRULEPRIORITY:
        *write_method = write_userSpecifyRulePriority;
        index = name[*length-1]-1;
        tmpval = 2;
        if(index <= qos_rulelist_count-1) {
        	if (strlen(qos_rulelist[index])) {
    			if(vstrsep(qos_rulelist[index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			tmpval = atoi(priority);
    			if(tmpval == 0) tmpval = 1;
    			else if(tmpval == 1) tmpval = 2;
    			else if(tmpval == 2) tmpval = 3;
    			else if(tmpval == 3) tmpval = 4;
    			else if(tmpval == 4) tmpval = 5;
    		}
    	}
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case USERSPECIFYRULEDELENTRY:
        *write_method = write_userSpecifyRuleDelEntry;
	    tmpval = 2; /* no */
	 	*var_len = sizeof( long );
        return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_enableQoS(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf(stderr, "write to trafficManager: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 || value == 2){
		switch(value)
		{
      			case 1:/* enable */
				nmp_set("qos_enable", "1");
				break;	
      			case 2:/* disable */	
				nmp_set("qos_enable", "0");
				break;     					
      		}		
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uploadBandwidth(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("qos_obw", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_downloadBandwidth(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("qos_ibw", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upHighestMinReserveBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(0, 1, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upHighestMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(0, 0, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upHighMinReserveBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(1, 1, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upHighMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(1, 0, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upMediumMinReserveBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(2, 1, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upMediumMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(2, 0, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upLowMinReserveBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(3, 1, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upLowMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(3, 0, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upLowestMinReserveBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(4, 1, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_upLowestMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_orates(4, 0, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_downHighestMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_irates(0, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_downHighMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_irates(1, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_downMediumMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_irates(2, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_downLowMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_irates(3, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_downLowestMaxBd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 100){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		set_qos_irates(4, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_highestPriorityPacket(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;

    value = * (char *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to trafficManager not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             (value & (1 << 7)) ? nmp_set("qos_ack", "on") : nmp_set("qos_ack", "off");
             (value & (1 << 6)) ? nmp_set("qos_syn", "on") : nmp_set("qos_syn", "off");
             (value & (1 << 5)) ? nmp_set("qos_fin", "on") : nmp_set("qos_fin", "off");
             (value & (1 << 4)) ? nmp_set("qos_rst", "on") : nmp_set("qos_rst", "off");
             (value & (1 << 3)) ? nmp_set("qos_icmp", "on") : nmp_set("qos_icmp", "off");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_userSpecifyRuleServiceName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *srcIPorMac, *destPort, *protocol, *transferred, *priority;
    char serviceNameStr[64];
    char string[QOSRULESTRNUM];

    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(qos_rulelist[qos_rulelist_count], b);
		qos_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to trafficManager not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(serviceNameStr, 0, sizeof(serviceNameStr));
            strncpy(serviceNameStr, (u_char *)var_val, var_val_len); 

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > qos_rulelist_count)
    			real_index = qos_rulelist_count;
    		else
    			real_index = index;

    		if(qos_rulelist[real_index][0]) {
    			if((vstrsep(qos_rulelist[real_index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6)) break;
    			sprintf(string, "%s>%s>%s>%s>%s>%s", serviceNameStr, srcIPorMac, destPort, protocol, transferred, priority);
    		}
    		else
    			sprintf(string, "%s>>>>>", serviceNameStr);	
    		strcpy(qos_rulelist[real_index], string);
                 	
    		//Re-generate qos_rulelist
    		for(i = 0; i < MAXQOSRULE; i++)
    		{
    			char entry_str[QOSRULESTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(qos_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", qos_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("qos_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userSpecifyRuleSrcIPorMAC(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *srcIPorMac, *destPort, *protocol, *transferred, *priority;
    char srcIPorMacStr[32];
    char string[QOSRULESTRNUM];

    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(qos_rulelist[qos_rulelist_count], b);
    		qos_rulelist_count++;		
    	}
    	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to trafficManager not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(srcIPorMacStr, 0, sizeof(srcIPorMacStr));
            strncpy(srcIPorMacStr, (u_char *)var_val, var_val_len); 

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > qos_rulelist_count)
    			real_index = qos_rulelist_count;
    		else
    			real_index = index;

    		if(qos_rulelist[real_index][0]) {
    			if(vstrsep(qos_rulelist[real_index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			sprintf(string, "%s>%s>%s>%s>%s>%s", serviceName, srcIPorMacStr, destPort, protocol, transferred, priority);
    		}
    		else {
                if(var_val_len)
                    sprintf(string, ">%s>>>>", srcIPorMacStr);	
                else /* Value is blank and there is no such entry. Escape!*/
                    break;
            }
    		strcpy(qos_rulelist[real_index], string);
                 	
    		//Re-generate qos_rulelist
    		for(i = 0; i < MAXQOSRULE; i++)
    		{
    			char entry_str[QOSRULESTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(qos_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", qos_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("qos_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userSpecifyRuleDestPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *srcIPorMac, *destPort, *protocol, *transferred, *priority;
    char destPortStr[256];
    char string[QOSRULESTRNUM];

    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(qos_rulelist[qos_rulelist_count], b);
    		qos_rulelist_count++;		
    	}
    	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to trafficManager not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(destPortStr, 0, sizeof(destPortStr));
            strncpy(destPortStr, (u_char *)var_val, var_val_len); 

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > qos_rulelist_count)
    			real_index = qos_rulelist_count;
    		else
    			real_index = index;

    		if(qos_rulelist[real_index][0]) {
    			if(vstrsep(qos_rulelist[real_index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			sprintf(string, "%s>%s>%s>%s>%s>%s", serviceName, srcIPorMac, destPortStr, protocol, transferred, priority);
    		}
    		else
    			sprintf(string, ">>%s>>>", destPortStr);	
    		strcpy(qos_rulelist[real_index], string);
                 	
    		//Re-generate qos_rulelist
    		for(i = 0; i < MAXQOSRULE; i++)
    		{
    			char entry_str[QOSRULESTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(qos_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", qos_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("qos_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userSpecifyRuleProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *srcIPorMac, *destPort, *protocol, *transferred, *priority;
    char protocolStr[16];
    int protocolInt;
    char string[QOSRULESTRNUM];

    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(qos_rulelist[qos_rulelist_count], b);
    		qos_rulelist_count++;		
    	}
    	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to trafficManager: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
    		protocolInt = *(u_long *)var_val;
    		if(protocolInt == 1) sprintf(protocolStr, "tcp");
    		else if(protocolInt == 2) sprintf(protocolStr, "udp");
    		else if(protocolInt == 3) sprintf(protocolStr, "tcp/udp");
    		else if(protocolInt == 4) sprintf(protocolStr, "any");

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > qos_rulelist_count)
    			real_index = qos_rulelist_count;
    		else
    			real_index = index;

    		if(qos_rulelist[real_index][0]) {
    			if(vstrsep(qos_rulelist[real_index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;
    			sprintf(string, "%s>%s>%s>%s>%s>%s", serviceName, srcIPorMac, destPort, protocolStr, transferred, priority);
    		}
    		else
    			sprintf(string, ">>>%s>>", protocolStr);
    		strcpy(qos_rulelist[real_index], string);
                 	
    		//Re-generate qos_rulelist
    		for(i = 0; i < MAXQOSRULE; i++)
    		{
    			char entry_str[QOSRULESTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(qos_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", qos_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("qos_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userSpecifyRuleMinTransferred(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *srcIPorMac, *destPort, *protocol, *transferred, *priority, *transMin, *transMax;
    char transferredMin[8];
    char string[QOSRULESTRNUM];

    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(qos_rulelist[qos_rulelist_count], b);
    		qos_rulelist_count++;		
    	}
    	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to trafficManager not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(transferredMin, 0x0, 8);
            strncpy(transferredMin, (u_char *)var_val, var_val_len);
            transferredMin[var_val_len] = '\0';

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > qos_rulelist_count)
    			real_index = qos_rulelist_count;
    		else
    			real_index = index;

    		if(qos_rulelist[real_index][0]) {
    			if(vstrsep(qos_rulelist[real_index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;

    			if(strlen(transferred)) {
    				if(vstrsep(transferred, "~", &transMin, &transMax) != 2) break;
                    if(var_val_len || strlen(transMax))
    				    sprintf(string, "%s>%s>%s>%s>%s~%s>%s", serviceName, srcIPorMac, destPort, protocol, transferredMin, transMax, priority);
                    else/* transferredMin and transMax are both blank. */
                        sprintf(string, "%s>%s>%s>%s>>%s", serviceName, srcIPorMac, destPort, protocol, priority);    
    			}
    			else {
                    if(var_val_len)
    				    sprintf(string, "%s>%s>%s>%s>%s~>%s", serviceName, srcIPorMac, destPort, protocol, transferredMin, priority);
                    else
                        sprintf(string, "%s>%s>%s>%s>>%s", serviceName, srcIPorMac, destPort, protocol, priority); 
                }
    		}
    		else {
                if(var_val_len)
                    sprintf(string, ">>>>%s~>", transferredMin);
                else /* Value is blank and there is no such entry. Escape!*/
                    break;
            }

    		strcpy(qos_rulelist[real_index], string);
                 	
    		//Re-generate qos_rulelist
    		for(i = 0; i < MAXQOSRULE; i++)
    		{
    			char entry_str[QOSRULESTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(qos_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", qos_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("qos_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userSpecifyRuleMaxTransferred(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *srcIPorMac, *destPort, *protocol, *transferred, *priority, *transMin, *transMax;
    char transferredMax[8];
    char string[QOSRULESTRNUM];

    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(qos_rulelist[qos_rulelist_count], b);
		qos_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to trafficManager not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(transferredMax, 0x0, 8);
            strncpy(transferredMax, (u_char *)var_val, var_val_len);
            transferredMax[var_val_len] = '\0';

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > qos_rulelist_count)
    			real_index = qos_rulelist_count;
    		else
    			real_index = index;

    		if(qos_rulelist[real_index][0]) {
    			if(vstrsep(qos_rulelist[real_index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6) break;

    			if(strlen(transferred)) {
    				if(vstrsep(transferred, "~", &transMin, &transMax) != 2) break;
                    if(var_val_len || strlen(transMin))                    
    				    sprintf(string, "%s>%s>%s>%s>%s~%s>%s", serviceName, srcIPorMac, destPort, protocol, transMin, transferredMax, priority);
                    else/* transMin and transferredMax are both blank. */
                        sprintf(string, "%s>%s>%s>%s>>%s", serviceName, srcIPorMac, destPort, protocol, priority);                        
    			}
    			else{
                    if(var_val_len)
                        sprintf(string, "%s>%s>%s>%s>~%s>%s", serviceName, srcIPorMac, destPort, protocol, transferredMax, priority);
                    else
                        sprintf(string, "%s>%s>%s>%s>>%s", serviceName, srcIPorMac, destPort, protocol, priority);                     
                }
    		}
    		else {
                if(var_val_len)
                    sprintf(string, ">>>>~%s>", transferredMax);    
                else /* Value is blank and there is no such entry. Escape! */
                    break;                
            }                    

    		strcpy(qos_rulelist[real_index], string);
                 	
    		//Re-generate qos_rulelist
    		for(i = 0; i < MAXQOSRULE; i++)
    		{
    			char entry_str[QOSRULESTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(qos_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", qos_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("qos_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userSpecifyRulePriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *srcIPorMac, *destPort, *protocol, *transferred, *priority;
    int priorityInt;
    char string[QOSRULESTRNUM];

    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(qos_rulelist[qos_rulelist_count], b);
		qos_rulelist_count++;		
	}
	free(nv);
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 5 ) {
              fprintf(stderr, "write to trafficManager: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		priorityInt = *(u_long *)var_val;
		if(priorityInt == 1) priorityInt = 0;
		else if(priorityInt == 2) priorityInt = 1;
		else if(priorityInt == 3) priorityInt = 2;
		else if(priorityInt == 4) priorityInt = 3;
		else if(priorityInt == 5) priorityInt = 4;

		memset(string, 0x0, sizeof(string));
		if((index+1) > qos_rulelist_count)
			real_index = qos_rulelist_count;
		else
			real_index = index;

		if(qos_rulelist[real_index][0]) {
			if((vstrsep(qos_rulelist[real_index], ">", &serviceName, &srcIPorMac, &destPort, &protocol, &transferred, &priority) != 6)) break;
			sprintf(string, "%s>%s>%s>%s>%s>%d", serviceName, srcIPorMac, destPort, protocol, transferred, priorityInt);
		}
		else
			sprintf(string, ">>>>>%d", priorityInt);
		strcpy(qos_rulelist[real_index], string);
             	
		//Re-generate qos_rulelist
		for(i = 0; i < MAXQOSRULE; i++)
		{
			char entry_str[QOSRULESTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(qos_rulelist[i][0]) {
				sprintf(entry_str, "<%s", qos_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("qos_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_userSpecifyRuleDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char qos_rulelist[MAXQOSRULE][QOSRULESTRNUM];
    int i, qos_rulelist_count = 0;
    char *nv, *nvp, *b;
   
    for(i = 0; i < MAXQOSRULE; i++)
    	memset(qos_rulelist[i], 0x0, QOSRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] -1;

    //Compute the number of qos_rulelist
    nv = nvp = strdup(nmp_safe_get("qos_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(qos_rulelist[qos_rulelist_count], b);
		qos_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to trafficManager not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to trafficManager: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to trafficManager: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < qos_rulelist_count)
             {
        	memset(qos_rulelist[index], 0x0, QOSRULESTRNUM);

		//Re-generate qos_rulelist
		for(i = 0; i < MAXQOSRULE; i++)
		{
			char entry_str[QOSRULESTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(qos_rulelist[i][0]) {
				sprintf(entry_str, "<%s", qos_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("qos_rulelist", tmpstr);
             }  
          break;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
