/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ipv6.h"
#include <nmp.h>

static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;

/* 
 * ipv6_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipv6_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,4 };

/* 
 * variable4 ipv6_variables:
 *   this variable defines function callbacks and type return information 
 *   for the ipv6 mib section 
 */

struct variable7 ipv6_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define CONNECTIONTYPE    1
{CONNECTIONTYPE,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 1,1 }},
#define NATIVEDHCPPD    2
{NATIVEDHCPPD,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 1,2 }},
#define SERVERIPV4ADDRESS   3
{SERVERIPV4ADDRESS,  ASN_IPADDRESS,  RWRITE,  var_ipv6, 2,  { 1,3 }},
#define IPV4ANYCASTRELAY    4
{IPV4ANYCASTRELAY,  ASN_IPADDRESS,  RWRITE,  var_ipv6, 2,  { 1,4 }},
#define DHCPOPTION    5
{DHCPOPTION,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 1,5 }},
#define IPV6PREFIX    6
{IPV6PREFIX,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 1,6 }},
#define IPV6PREFIXLENGTH6RD   7
{IPV6PREFIXLENGTH6RD,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 1,7 }},
#define IPV4BORDERROUTER    8
{IPV4BORDERROUTER,  ASN_IPADDRESS,  RWRITE,  var_ipv6, 2,  { 1,8 }},
#define IPV4ROUTERMASKLENGTH    9
{IPV4ROUTERMASKLENGTH,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 1,9 }},
#define CLIENTIPV6ADDRESS   10
{CLIENTIPV6ADDRESS,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 1,10 }},
#define IPV6PREFIXLENGTH6IN4    11
{IPV6PREFIXLENGTH6IN4,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 1,11 }},
#define TUNNELMTU   12
{TUNNELMTU,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 1,12 }},
#define TUNNELTTL   13
{TUNNELTTL,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 1,13 }},
#define WANIPV6ADDRESS    14
{WANIPV6ADDRESS,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 2,1 }},
#define WANPREFIXLENGTH   15
{WANPREFIXLENGTH,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 2,2 }},
#define WANIPV6GATEWAY    16
{WANIPV6GATEWAY,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 2,3 }},
#define LANIPV6ADDRESS    17
{LANIPV6ADDRESS,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 3,1 }},
#define LANIPV6PREFIXLENGTH   18
{LANIPV6PREFIXLENGTH,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 3,2 }},
#define LANIPV6PREFIX   19
{LANIPV6PREFIX,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 3,3 }},
#define LANIPV6AUTOCONFIGURATION    20
{LANIPV6AUTOCONFIGURATION,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 3,4 }},
#define LANIPV6LIFETIME   21
{LANIPV6LIFETIME,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 3,5 }},
#define LANIPV6DHCPPOOLSTARTPREFIX		22
{LANIPV6DHCPPOOLSTARTPREFIX,  ASN_OCTET_STR,  RONLY ,  var_ipv6, 2,  { 3,6 }},
#define LANIPV6DHCPPOOLSTART		23
{LANIPV6DHCPPOOLSTART,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 3,7 }},
#define LANIPV6DHCPPOOLENDPREFIX		24
{LANIPV6DHCPPOOLENDPREFIX,  ASN_OCTET_STR,  RONLY ,  var_ipv6, 2,  { 3,8 }},
#define LANIPV6DHCPPOOLEND		25
{LANIPV6DHCPPOOLEND,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 3,9 }},
#define IPV6CONNECTTODNSSERVERAUTO		26
{IPV6CONNECTTODNSSERVERAUTO,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 4,1 }},
#define IPV6DNSSERVER1		27
{IPV6DNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 4,2 }},
#define IPV6DNSSERVER2		28
{IPV6DNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 4,3 }},
#define IPV6DNSSERVER3		29
{IPV6DNSSERVER3,  ASN_OCTET_STR,  RWRITE,  var_ipv6, 2,  { 4,4 }},
#define ENABLEROUTERADVERTISEMENT		30
{ENABLEROUTERADVERTISEMENT,  ASN_INTEGER,  RWRITE,  var_ipv6, 2,  { 5,1 }},

};
/*    (L = length of the oidsuffix) */


/** Initializes the ipv6 module */
void
init_ipv6(void)
{

    DEBUGMSGTL(("ipv6", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipv6", ipv6_variables, variable7,
               ipv6_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_ipv6():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_ipv6(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)  //Doesn't support in AP and repeater mode
        return NULL;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case CONNECTIONTYPE:
        *write_method = write_connectionType;
        if(nmp_safe_get("ipv6_service") != NULL)
        {
          if(!strcmp(nmp_get("ipv6_service"), "disabled")) /* disable */
             tmpval = 1;
          else if(!strcmp(nmp_get("ipv6_service"), "dhcp6")) /* native with dhcp-pd */
             tmpval = 2;
          else if(!strcmp(nmp_get("ipv6_service"), "6to4")) /* tunnel 6to4 */
             tmpval = 3;
          else if(!strcmp(nmp_get("ipv6_service"), "6in4")) /* tunnel 6in4 */
             tmpval = 4;
          else if(!strcmp(nmp_get("ipv6_service"), "6rd")) /* tunnel 6rd */
             tmpval = 5;
          else if(!strcmp(nmp_get("ipv6_service"), "other")) /* static ipv6 */
             tmpval = 6;
          *var_len = sizeof( long );
          return ( u_char * ) &tmpval;
        } 
        return NULL;
    case NATIVEDHCPPD:
        *write_method = write_nativeDhcpPd;
        if(nmp_safe_get("ipv6_dhcp_pd") != NULL)
        {
            tmpval = nmp_get_int("ipv6_dhcp_pd");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case SERVERIPV4ADDRESS:
        *write_method = write_serverIPv4Address;
        if(strlen(nmp_safe_get("ipv6_tun_v4end")))
        {
            tmpval_u = inet_addr(nmp_safe_get("ipv6_tun_v4end"));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;
    case IPV4ANYCASTRELAY:
        *write_method = write_ipv4AnycastRelay;
        if(strlen(nmp_safe_get("ipv6_relay")))
        {
            tmpval_u = inet_addr(nmp_safe_get("ipv6_relay"));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;
    case DHCPOPTION:
        *write_method = write_dhcpOption;
        if(nmp_safe_get("ipv6_6rd_dhcp") != NULL)
        {
            tmpval = nmp_get_int("ipv6_6rd_dhcp");
            if(tmpval == 1) /* enable */
            tmpval = 1;
            else if(tmpval == 0) /* disable */
            tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case IPV6PREFIX:
        *write_method = write_ipv6Prefix;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_6rd_prefix") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_6rd_prefix"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case IPV6PREFIXLENGTH6RD:
        *write_method = write_ipv6PrefixLength6rd;
        if(nmp_safe_get("ipv6_6rd_prefixlen") != NULL)
        {
            tmpval = nmp_get_int("ipv6_6rd_prefixlen");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case IPV4BORDERROUTER:
        *write_method = write_ipv4BorderRouter;
        if(strlen(nmp_safe_get("ipv6_6rd_router")))
        {
            tmpval_u = inet_addr(nmp_safe_get("ipv6_6rd_router"));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;
    case IPV4ROUTERMASKLENGTH:
        *write_method = write_ipv4RouterMaskLength;
        if(nmp_safe_get("ipv6_6rd_ip4size") != NULL)
        {
            tmpval = nmp_get_int("ipv6_6rd_ip4size");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case CLIENTIPV6ADDRESS:
        *write_method = write_clientIPv6Address;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_tun_addr") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_tun_addr"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case IPV6PREFIXLENGTH6IN4:
        *write_method = write_ipv6PrefixLength6in4;
        if(nmp_safe_get("ipv6_tun_addrlen") != NULL)
        {
            tmpval = nmp_get_int("ipv6_tun_addrlen");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case TUNNELMTU:
        *write_method = write_tunnelMTU;
        if(nmp_safe_get("ipv6_tun_mtu") != NULL)
        {
            tmpval = nmp_get_int("ipv6_tun_mtu");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case TUNNELTTL:
        *write_method = write_tunnelTTL;
        if(nmp_safe_get("ipv6_tun_ttl") != NULL)
        {
            tmpval = nmp_get_int("ipv6_tun_ttl");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case WANIPV6ADDRESS:
        *write_method = write_wanIPv6Address;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_ipaddr") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_ipaddr"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case WANPREFIXLENGTH:
        *write_method = write_wanPrefixLength;
        if(nmp_safe_get("ipv6_prefix_len_wan") != NULL)
        {
            tmpval = nmp_get_int("ipv6_prefix_len_wan");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case WANIPV6GATEWAY:
        *write_method = write_wanIPv6Gateway;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_gateway") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_gateway"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case LANIPV6ADDRESS:
        *write_method = write_lanIpv6Address;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_rtr_addr") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_rtr_addr"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case LANIPV6PREFIXLENGTH:
        *write_method = write_lanIpv6PrefixLength;
        if(nmp_safe_get("ipv6_prefix_length") != NULL)
        {
            tmpval = nmp_get_int("ipv6_prefix_length");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case LANIPV6PREFIX:
        *write_method = write_lanIpv6Prefix;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_prefix") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_prefix"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case LANIPV6AUTOCONFIGURATION:
        *write_method = write_lanIpv6AutoConfiguration;
        if(nmp_safe_get("ipv6_autoconf_type") != NULL)
        {
            tmpval = nmp_get_int("ipv6_autoconf_type");
            if(tmpval == 0) /* stateless */
                tmpval = 1;
            else if(tmpval == 1) /* stateful */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case LANIPV6LIFETIME:
        *write_method = write_lanIpv6LifeTime;
        if(nmp_safe_get("ipv6_dhcp_lifetime") != NULL)
        {
            tmpval = nmp_get_int("ipv6_dhcp_lifetime");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case LANIPV6DHCPPOOLSTARTPREFIX:
        if(nmp_safe_get("ipv6_dhcp_start") != NULL)
        {
            char *p;
            strcpy(tmpstr, nmp_safe_get("ipv6_dhcp_start"));
            p = strchr(tmpstr, ':');
            if(p)
                *p = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case LANIPV6DHCPPOOLSTART:
        *write_method = write_lanIpv6DhcpPoolStart;
        if(nmp_safe_get("ipv6_dhcp_start") != NULL)
        {
            char *p, str[SPRINT_MAX_LEN];
            memset(str, 0, SPRINT_MAX_LEN);
            strcpy(str, nmp_safe_get("ipv6_dhcp_start"));
            p = strrchr(str, ':');
            p++;
            strcpy(tmpstr, p);
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case LANIPV6DHCPPOOLENDPREFIX:
        if(nmp_safe_get("ipv6_dhcp_end") != NULL)
        {
            char *p;
            strcpy(tmpstr, nmp_safe_get("ipv6_dhcp_end"));
            p = strchr(tmpstr, ':');
            if(p)
                *p = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case LANIPV6DHCPPOOLEND:
        *write_method = write_lanIpv6DhcpPoolEnd;
        if(nmp_safe_get("ipv6_dhcp_end") != NULL)
        {
            char *p, str[SPRINT_MAX_LEN];
            memset(str, 0, SPRINT_MAX_LEN);
            strcpy(str, nmp_safe_get("ipv6_dhcp_end"));
            p = strrchr(str, ':');
            p++;
            strcpy(tmpstr, p);
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case IPV6CONNECTTODNSSERVERAUTO:
        *write_method = write_ipv6ConnectToDNSServerAuto;
        if(nmp_safe_get("ipv6_dnsenable") != NULL)
        {
            tmpval = nmp_get_int("ipv6_dnsenable");
            if(tmpval == 1) /* enable */
                tmpval = 1;
            else if(tmpval == 0) /* disable */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case IPV6DNSSERVER1:
        *write_method = write_ipv6DNSServer1;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_dns1") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_dns1"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case IPV6DNSSERVER2:
        *write_method = write_ipv6DNSServer2;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_dns2") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_dns2"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case IPV6DNSSERVER3:
        *write_method = write_ipv6DNSServer3;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ipv6_dns3") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ipv6_dns3"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case ENABLEROUTERADVERTISEMENT:
        *write_method = write_enableRouterAdvertisement;
        if(nmp_safe_get("ipv6_radvd") != NULL)
        {
            tmpval = nmp_get_int("ipv6_radvd");
            if(tmpval == 1) /* enable */
                tmpval = 1;
            else if(tmpval == 0) /* disable */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}





int
write_connectionType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to connectionType not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to connectionType: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 6) {
              fprintf(stderr, "write to connectionType: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                switch(value)
                {
                    case 1:/* disable */
                        nmp_set("ipv6_service", "disabled");
                    break;
                    case 2:/* native with dhcp-pd */
                        nmp_set("ipv6_service", "dhcp6");
                    break;
                    case 3: /* tunnel 6to4 */
                        nmp_set("ipv6_service", "6to4");
                    break;
                    case 4:/* tunnel 6in4 */
                        nmp_set("ipv6_service", "6in4");
                    break;
                    case 5: /* tunnel 6rd */
                        nmp_set("ipv6_service", "6rd");
                    break;
                    case 6:/* static ipv6 */
                        nmp_set("ipv6_service", "other");
                    break;
                }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_nativeDhcpPd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nativeDhcpPd not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nativeDhcpPd: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 1) {
              fprintf(stderr, "write to nativeDhcpPd: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              nmp_set_int("ipv6_dhcp_pd", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_serverIPv4Address(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to serverIPv4Address not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to serverIPv4Address: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("ipv6_tun_v4end", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv4AnycastRelay(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to ipv4AnycastRelay not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to ipv4AnycastRelay: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("ipv6_relay", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dhcpOption(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dhcpOption not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dhcpOption: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to dhcpOption: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set("ipv6_6rd_dhcp", "1");
                else if(value == 2)
                    nmp_set("ipv6_6rd_dhcp", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_ipv6Prefix(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ipv6Prefix not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 39 ) {
              fprintf(stderr, "write to ipv6Prefix: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 39)
             {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set("ipv6_6rd_prefix", tmpstr);       
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv6PrefixLength6rd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to ipv6PrefixLength6rd not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to ipv6PrefixLength6rd: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 3 || *(long *)var_val > 64){
              fprintf ( stderr,"write to ipv6PrefixLength6rd: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("ipv6_6rd_prefixlen", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv4BorderRouter(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to ipv4BorderRouter not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to ipv4BorderRouter: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("ipv6_6rd_router", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv4RouterMaskLength(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to ipv4RouterMaskLength not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to ipv4RouterMaskLength: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 32){
              fprintf ( stderr,"write to ipv4RouterMaskLength: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("ipv6_6rd_ip4size", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_clientIPv6Address(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to clientIPv6Address not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 39 ) {
              fprintf(stderr, "write to clientIPv6Address: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 39)
             {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set("ipv6_tun_addr", tmpstr);       
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv6PrefixLength6in4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to ipv6PrefixLength6in4 not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to ipv6PrefixLength6in4: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 3 || *(long *)var_val > 64){
              fprintf ( stderr,"write to ipv6PrefixLength6in4: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("ipv6_tun_addrlen", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_tunnelMTU(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to tunnelMTU not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to tunnelMTU: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1280 || *(long *)var_val < 1480 ) {
              fprintf(stderr, "write to tunnelMTU: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("ipv6_tun_mtu", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_tunnelTTL(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to tunnelTTL not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to tunnelTTL: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 255) {
              fprintf(stderr, "write to tunnelTTL: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("ipv6_tun_ttl", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wanIPv6Address(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wanIPv6Address not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 39 ) {
              fprintf(stderr, "write to wanIPv6Address: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 39)
             {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set("ipv6_ipaddr", tmpstr);       
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wanPrefixLength(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wanPrefixLength not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wanPrefixLength: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 3 || *(long *)var_val > 64){
              fprintf ( stderr,"write to wanPrefixLength: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("ipv6_prefix_len_wan", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wanIPv6Gateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wanIPv6Gateway not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 39 ) {
              fprintf(stderr, "write to wanIPv6Gateway: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 39)
             {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set("ipv6_gateway", tmpstr);      
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIpv6Address(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lanIpv6Address not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 39 ) {
              fprintf(stderr, "write to lanIpv6Address: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 39)
             {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set("ipv6_rtr_addr", tmpstr);       
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIpv6PrefixLength(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lanIpv6PrefixLength not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lanIpv6PrefixLength: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 3 || *(long *)var_val > 64){
              fprintf ( stderr,"write to lanIpv6PrefixLength: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("ipv6_prefix_length", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIpv6Prefix(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lanIpv6Prefix not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 39 ) {
              fprintf(stderr, "write to lanIpv6Prefix: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              if(var_val_len >= 1 || var_val_len <= 39)
              {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set("ipv6_prefix", tmpstr);       
              }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIpv6AutoConfiguration(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lanIpv6AutoConfiguration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lanIpv6AutoConfiguration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lanIpv6AutoConfiguration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              if(value == 1)//stateless
                  nmp_set("ipv6_autoconf_type", "0");
              else if(value == 2)//stateful
                  nmp_set("ipv6_autoconf_type", "1");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIpv6LifeTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lanIpv6LifeTime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lanIpv6LifeTime: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 120 || *(long *)var_val > 604800){
              fprintf ( stderr,"write to lanIpv6LifeTime: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              nmp_set_int("ipv6_dhcp_lifetime", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIpv6DhcpPoolStart(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int i = 0;
    char *p, str[32];

    memset(str, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    strncpy(str, (u_char *)var_val, var_val_len); 
    str[var_val_len] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lanIpv6DhcpPoolStart not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 1 || var_val_len > 4) {
              fprintf(stderr,"write to lanIpv6DhcpPoolStart: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }          
          while( i < var_val_len ){
              if( str[i] < '0' || (str[i] > '9' && str[i] < 'A') 
                || (str[i] > 'F' && str[i] < 'a') || str[i] > 'f') {
                    fprintf(stderr,"write to lanIpv6DhcpPoolStart: value out of range\n");
                    return SNMP_ERR_WRONGVALUE;
              }
              i++;                
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);            
            strcpy(tmpstr, nmp_safe_get("ipv6_dhcp_start"));
            p = strrchr(tmpstr, ':');
            if(p) {
                p++;
                *p = '\0';
            }
            strcat(tmpstr, str);
            nmp_set("ipv6_dhcp_start", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lanIpv6DhcpPoolEnd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int i = 0;
    char *p, str[32];

    memset(str, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    strncpy(str, (u_char *)var_val, var_val_len); 
    str[var_val_len] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lanIpv6DhcpPoolEnd not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 1 || var_val_len > 4) {
              fprintf(stderr,"write to lanIpv6DhcpPoolEnd: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          while( i < var_val_len ){
              if( str[i] < '0' || (str[i] > '9' && str[i] < 'A') 
                || (str[i] > 'F' && str[i] < 'a') || str[i] > 'f') {
                    fprintf(stderr,"write to lanIpv6DhcpPoolEnd: value out of range\n");
                    return SNMP_ERR_WRONGVALUE;
              }
              i++;                
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);            
            strcpy(tmpstr, nmp_safe_get("ipv6_dhcp_end"));
            p = strrchr(tmpstr, ':');
            if(p) {
                p++;
                *p = '\0';
            }
            strcat(tmpstr, str);
            nmp_set("ipv6_dhcp_end", tmpstr);                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv6ConnectToDNSServerAuto(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to ipv6ConnectToDNSServerAuto not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to ipv6ConnectToDNSServerAuto: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to ipv6ConnectToDNSServerAuto: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set("ipv6_dnsenable", "1");
                else if(value == 2)
                    nmp_set("ipv6_dnsenable", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv6DNSServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ipv6DNSServer1 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len > 39 ) {
              fprintf(stderr, "write to ipv6DNSServer1: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              strncpy(tmpstr, (u_char *)var_val, var_val_len); 
              tmpstr[var_val_len] = '\0';
              nmp_set("ipv6_dns1", tmpstr);       
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv6DNSServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ipv6DNSServer2 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len > 39 ) {
              fprintf(stderr, "write to ipv6DNSServer2: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              strncpy(tmpstr, (u_char *)var_val, var_val_len); 
              tmpstr[var_val_len] = '\0';
              nmp_set("ipv6_dns2", tmpstr);       
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipv6DNSServer3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ipv6DNSServer3 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len > 39 ) {
              fprintf(stderr, "write to ipv6DNSServer3: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("ipv6_dns3", tmpstr);      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableRouterAdvertisement(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to enableRouterAdvertisement not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to enableRouterAdvertisement: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to enableRouterAdvertisement: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set("ipv6_radvd", "1");
                else if(value == 2)
                    nmp_set("ipv6_radvd", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

