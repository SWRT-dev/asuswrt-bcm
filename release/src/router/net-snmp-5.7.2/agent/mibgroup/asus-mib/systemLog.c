/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "systemLog.h"
#include <nmp.h>

#define MAX_DHCP_LEASE      255
#define MAX_PORT_FORWARDING	64
#define MAX_ROUTING         64
#define MAX_WIRELESS        64
#define MAX_IPV6_DEVICES    255
#define MAX_ACTIVE_CONNECTIONS 255
#define SPRINT_MAX_LEN_SYSLOG   8192
static unsigned char tmpstr[SPRINT_MAX_LEN_SYSLOG];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;
static unsigned char tftpsrvip[39];
static unsigned char logfile[128];

int dhcp_lease_count = 0;
int dhcp_lease_flag = 0;
dhcp_lease_info_t dhcp_lease_list[MAX_DHCP_LEASE];

int port_forwarding_count = 0;
int port_forwarding_flag = 0;
port_forwarding_info_t port_forwarding_list[MAX_PORT_FORWARDING];

int routing_count = 0;
int routing_flag = 0;
routing_info_t routing_list[MAX_ROUTING];

int wireless_2g_count = 0;
int wireless_2g_flag = 0;
wireless_info_t wireless_2g_list[MAX_WIRELESS];

//#ifdef DUAL_BAND
int wireless_5g_count = 0;
int wireless_5g_flag = 0;
wireless_info_t wireless_5g_list[MAX_WIRELESS];
//#endif	//#ifdef DUAL_BAND

int active_connection_count = 0;
int active_connection_flag = 0;
active_connection_info_t active_connection_list[MAX_ACTIVE_CONNECTIONS];

int ipv6Lan_dev_count = 0;
int ipv6Lan_dev_flag = 0;
ipv6_landev_info_t ipv6_landev_info[MAX_IPV6_DEVICES];

int ipv6_routing_count = 0;
int ipv6_routing_flag = 0;
ipv6_routing_info_t ipv6_routing_info[MAX_ROUTING];
/* 
 * systemLog_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid systemLog_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,8 };

/* 
 * variable7 systemLog_variables:
 *   this variable defines function callbacks and type return information 
 *   for the systemLog mib section 
 */

struct variable7 systemLog_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define SYSTEMTIME		1
{SYSTEMTIME,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 1,1 }},
#define UPTIME		2
{UPTIME,  ASN_TIMETICKS,  RONLY ,  var_systemLog, 2,  { 1,2 }},
#define SYSLOGTFTPSRV		3
{SYSLOGTFTPSRV,  ASN_OCTET_STR,  RWRITE,  var_systemLog, 3,  { 1,3,1 }},
#define SYSLOGTFTPFILE		4
{SYSLOGTFTPFILE,  ASN_OCTET_STR,  RWRITE,  var_systemLog, 3,  { 1,3,2 }},
#define SYSLOGSAVEACT		5
{SYSLOGSAVEACT,  ASN_INTEGER,  RWRITE,  var_systemLog, 3,  { 1,3,3 }},
#define BSSINFOWL2G		6
{BSSINFOWL2G,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 3,  { 2,1,1 }},
#define WL2GREFRESHSTA		7
{WL2GREFRESHSTA,  ASN_INTEGER,  RWRITE,  var_systemLog, 3,  { 2,1,2 }},
#define BSSINFOWL5G		8
{BSSINFOWL5G,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 3,  { 2,2,1 }},
#define WL5GREFRESHSTA		9
{WL5GREFRESHSTA,  ASN_INTEGER,  RWRITE,  var_systemLog, 3,  { 2,2,2 }},
#define IPV6CONNECTIONTYPE		10
{IPV6CONNECTIONTYPE,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 4,1 }},
#define IPV6WANADDRESS		11
{IPV6WANADDRESS,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 4,2 }},
#define IPV6WANGATEWAY		12
{IPV6WANGATEWAY,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 4,3 }},
#define IPV6LANADDRESS		13
{IPV6LANADDRESS,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 4,4 }},
#define IPV6LANLINKLOCALADDRESS		14
{IPV6LANLINKLOCALADDRESS,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 4,5 }},
#define IPV6DHCPPD		15
{IPV6DHCPPD,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 4,6 }},
#define IPV6LANPREFIX		16
{IPV6LANPREFIX,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 4,7 }},
#define IPV6DNSADDRESS		17
{IPV6DNSADDRESS,  ASN_OCTET_STR,  RONLY ,  var_systemLog, 2,  { 4,8 }},

#define WL2GSTATIONINDEX		18
{WL2GSTATIONINDEX,  ASN_INTEGER,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 1 }},
#define WL2GSTATIONMACADDR		19
{WL2GSTATIONMACADDR,  ASN_OCTET_STR,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 2 }},
#define WL2GASSOCIATED		20
{WL2GASSOCIATED,  ASN_OCTET_STR,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 3 }},
#define WL2GAUTHORIZED		21
{WL2GAUTHORIZED,  ASN_OCTET_STR,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 4 }},
#define WL2GRSSI		22
{WL2GRSSI,  ASN_OCTET_STR,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 5 }},
#define WL2GPSM		23
{WL2GPSM,  ASN_OCTET_STR,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 6 }},
#define WL2GTXRATE		24
{WL2GTXRATE,  ASN_OCTET_STR,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 7 }},
#define WL2GRXRATE		25
{WL2GRXRATE,  ASN_OCTET_STR,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 8 }},
#define WL2GSTATIONCONNECTTIME		26
{WL2GSTATIONCONNECTTIME,  ASN_TIMETICKS,  RONLY,   var_wl2gStationTable, 5,  { 2,1,3, 1, 9 }},
#define WL5GSTATIONINDEX		27
{WL5GSTATIONINDEX,  ASN_INTEGER,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 1 }},
#define WL5GSTATIONMACADDR		28
{WL5GSTATIONMACADDR,  ASN_OCTET_STR,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 2 }},
#define WL5GASSOCIATED		29
{WL5GASSOCIATED,  ASN_OCTET_STR,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 3 }},
#define WL5GAUTHORIZED		30
{WL5GAUTHORIZED,  ASN_OCTET_STR,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 4 }},
#define WL5GRSSI		31
{WL5GRSSI,  ASN_OCTET_STR,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 5 }},
#define WL5GPSM		32
{WL5GPSM,  ASN_OCTET_STR,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 6 }},
#define WL5GTXRATE		33
{WL5GTXRATE,  ASN_OCTET_STR,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 7 }},
#define WL5GRXRATE		34
{WL5GRXRATE,  ASN_OCTET_STR,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 8 }},
#define WL5GSTATIONCONNECTTIME		35
{WL5GSTATIONCONNECTTIME,  ASN_TIMETICKS,  RONLY,   var_wl5gStationTable, 5,  { 2,2,3, 1, 9 }},
#define DHCPLEASESINDEX		36
{DHCPLEASESINDEX,  ASN_INTEGER,  RONLY,   var_dhcpLeasesTable, 4,  { 3,1, 1, 1 }},
#define DHCPLEASESHOSTNAME		37
{DHCPLEASESHOSTNAME,  ASN_OCTET_STR,  RONLY,   var_dhcpLeasesTable, 4,  { 3,1, 1, 2 }},
#define DHCPLEASESIPADDR		38
{DHCPLEASESIPADDR,  ASN_OCTET_STR,  RONLY,   var_dhcpLeasesTable, 4,  { 3,1, 1, 3 }},
#define DHCPLEASESMACADDR		39
{DHCPLEASESMACADDR,  ASN_OCTET_STR,  RONLY,   var_dhcpLeasesTable, 4,  { 3,1, 1, 4 }},
#define DHCPLEASESEXPIRES		40
{DHCPLEASESEXPIRES,  ASN_OCTET_STR,  RONLY,   var_dhcpLeasesTable, 4,  { 3,1, 1, 5 }},
#define IPV6LANDEVICEINDEX		41
{IPV6LANDEVICEINDEX,  ASN_INTEGER,  RONLY,   var_ipv6LanDevicesTable, 4,  { 4,9, 1, 1 }},
#define IPV6LANDEVICEHOSTNAME		42
{IPV6LANDEVICEHOSTNAME,  ASN_OCTET_STR,  RONLY,   var_ipv6LanDevicesTable, 4,  { 4,9, 1, 2 }},
#define IPV6LANDEVICEMACADDR		43
{IPV6LANDEVICEMACADDR,  ASN_OCTET_STR,  RONLY,   var_ipv6LanDevicesTable, 4,  { 4,9, 1, 3 }},
#define IPV6LANDEVICEIPV6ADDR		44
{IPV6LANDEVICEIPV6ADDR,  ASN_OCTET_STR,  RONLY,   var_ipv6LanDevicesTable, 4,  { 4,9, 1, 4 }},
#define ROUTINGINDEX		45
{ROUTINGINDEX,  ASN_INTEGER,  RONLY,   var_routingTable, 4,  { 5,1, 1, 1 }},
#define ROUTINGDESTINATION		46
{ROUTINGDESTINATION,  ASN_OCTET_STR,  RONLY,   var_routingTable, 4,  { 5,1, 1, 2 }},
#define ROUTINGGATEWAY		47
{ROUTINGGATEWAY,  ASN_OCTET_STR,  RONLY,   var_routingTable, 4,  { 5,1, 1, 3 }},
#define ROUTINGGENMASK		48
{ROUTINGGENMASK,  ASN_OCTET_STR,  RONLY,   var_routingTable, 4,  { 5,1, 1, 4 }},
#define ROUTINGFLAGS		49
{ROUTINGFLAGS,  ASN_OCTET_STR,  RONLY,   var_routingTable, 4,  { 5,1, 1, 5 }},
#define ROUTINGMETRIC		50
{ROUTINGMETRIC,  ASN_INTEGER,  RONLY,   var_routingTable, 4,  { 5,1, 1, 6 }},
#define ROUTINGREF		51
{ROUTINGREF,  ASN_INTEGER,  RONLY,   var_routingTable, 4,  { 5,1, 1, 7 }},
#define ROUTINGUSE		52
{ROUTINGUSE,  ASN_INTEGER,  RONLY,   var_routingTable, 4,  { 5,1, 1, 8 }},
#define ROUTINGIFACE		53
{ROUTINGIFACE,  ASN_OCTET_STR,  RONLY,   var_routingTable, 4,  { 5,1, 1, 9 }},
#define IPV6ROUTINGINDEX		54
{IPV6ROUTINGINDEX,  ASN_INTEGER,  RONLY,   var_ipv6RoutingTable, 4,  { 5,2, 1, 1 }},
#define IPV6ROUTINGDEST		55
{IPV6ROUTINGDEST,  ASN_OCTET_STR,  RONLY,   var_ipv6RoutingTable, 4,  { 5,2, 1, 2 }},
#define IPV6ROUTINGNEXTHOP		56
{IPV6ROUTINGNEXTHOP,  ASN_OCTET_STR,  RONLY,   var_ipv6RoutingTable, 4,  { 5,2, 1, 3 }},
#define IPV6ROUTINGFLAGS		57
{IPV6ROUTINGFLAGS,  ASN_OCTET_STR,  RONLY,   var_ipv6RoutingTable, 4,  { 5,2, 1, 4 }},
#define IPV6ROUTINGMETRIC		58
{IPV6ROUTINGMETRIC,  ASN_INTEGER,  RONLY,   var_ipv6RoutingTable, 4,  { 5,2, 1, 5 }},
#define IPV6ROUTINGREF		59
{IPV6ROUTINGREF,  ASN_INTEGER,  RONLY,   var_ipv6RoutingTable, 4,  { 5,2, 1, 6 }},
#define IPV6ROUTINGUSE		60
{IPV6ROUTINGUSE,  ASN_INTEGER,  RONLY,   var_ipv6RoutingTable, 4,  { 5,2, 1, 7 }},
#define IPV6ROUTINGIFACE		61
{IPV6ROUTINGIFACE,  ASN_OCTET_STR,  RONLY,   var_ipv6RoutingTable, 4,  { 5,2, 1, 8 }},
#define PORTFORWARDINGLOGINDEX		62
{PORTFORWARDINGLOGINDEX,  ASN_INTEGER,  RONLY,   var_portForwardingLogTable, 4,  { 6,1, 1, 1 }},
#define PORTFORWARDINGLOGDESTINATION		63
{PORTFORWARDINGLOGDESTINATION,  ASN_OCTET_STR,  RONLY,   var_portForwardingLogTable, 4,  { 6,1, 1, 2 }},
#define PORTFORWARDINGLOGPROTOCOL		64
{PORTFORWARDINGLOGPROTOCOL,  ASN_OCTET_STR,  RONLY,   var_portForwardingLogTable, 4,  { 6,1, 1, 3 }},
#define PORTFORWARDINGLOGPORTRANGE		65
{PORTFORWARDINGLOGPORTRANGE,  ASN_OCTET_STR,  RONLY,   var_portForwardingLogTable, 4,  { 6,1, 1, 4 }},
#define PORTFORWARDINGLOGREDIRECTTO		66
{PORTFORWARDINGLOGREDIRECTTO,  ASN_OCTET_STR,  RONLY,   var_portForwardingLogTable, 4,  { 6,1, 1, 5 }},
#define PORTFORWARDINGLOGLOCALPORT		67
{PORTFORWARDINGLOGLOCALPORT,  ASN_OCTET_STR,  RONLY,   var_portForwardingLogTable, 4,  { 6,1, 1, 6 }},
#define ACTIVECONNECTIONINDEX		68
{ACTIVECONNECTIONINDEX,  ASN_INTEGER,  RONLY,   var_activeConnectionTable, 4,  { 7,1, 1, 1 }},
#define ACTIVECONNECTIONPROTO		69
{ACTIVECONNECTIONPROTO,  ASN_OCTET_STR,  RONLY,   var_activeConnectionTable, 4,  { 7,1, 1, 2 }},
#define ACTIVECONNECTIONNATEDADDR		70
{ACTIVECONNECTIONNATEDADDR,  ASN_OCTET_STR,  RONLY,   var_activeConnectionTable, 4,  { 7,1, 1, 3 }},
#define ACTIVECONNECTIONDESTADDR		71
{ACTIVECONNECTIONDESTADDR,  ASN_OCTET_STR,  RONLY,   var_activeConnectionTable, 4,  { 7,1, 1, 4 }},
#define ACTIVECONNECTIONSTATE		72
{ACTIVECONNECTIONSTATE,  ASN_OCTET_STR,  RONLY,   var_activeConnectionTable, 4,  { 7,1, 1, 5 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the systemLog module */
void
init_systemLog(void)
{

    DEBUGMSGTL(("systemLog", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("systemLog", systemLog_variables, variable7,
               systemLog_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_systemLog():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_systemLog(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    char *str = NULL;
    time_t tm;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case SYSTEMTIME:
        time(&tm);
        sprintf(tmpstr, "%s", rfctime(&tm));
    	*var_len = strlen(tmpstr);
      	return ( u_char * )tmpstr;
    case UPTIME:
    	str = file2str("/proc/uptime");
    	if (str) {
    		unsigned int up = atoi(str);
    		free(str);
    		tmpval_u = up*100;
    		*var_len = sizeof( u_long );
    		return ( u_char * ) &tmpval_u;
    	}
        return NULL;
    case SYSLOGTFTPSRV:
        *write_method = write_sysLogTftpSrv;
        *var_len = strlen(tftpsrvip);
        return ( u_char * ) tftpsrvip;
    case SYSLOGTFTPFILE:
        *write_method = write_sysLogTftpFile;
        *var_len = strlen(logfile);
        return ( u_char * ) logfile;
    case SYSLOGSAVEACT:
        *write_method = write_sysLogSaveAct;
        tmpval = 2; /* 1: save   2: nothing*/
        *var_len = sizeof( long );        
        return ( u_char * ) &tmpval;
    case BSSINFOWL2G:
        memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
        bss_status(tmpstr, 0);
    	*var_len = strlen(tmpstr);
      	return ( u_char * )tmpstr;
    case WL2GREFRESHSTA:
        *write_method = write_wl2gRefreshSta;
        tmpval = 2;/* nothing */
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;       
    case BSSINFOWL5G: 
        memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    	bss_status(tmpstr, 1);
    	*var_len = strlen(tmpstr);
      	return ( u_char * )tmpstr;
    case WL5GREFRESHSTA:
        *write_method = write_wl5gRefreshSta;
        tmpval = 2;/* nothing */
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;  
    case IPV6CONNECTIONTYPE:
        if(strcmp(nmp_get("ipv6_service"), "disabled"))
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            if(!strcmp(nmp_get("ipv6_service"), "dhcp6")) /* native with dhcp-pd */
                strcpy(tmpstr, "Native with DHCP-PD");
            else if(!strcmp(nmp_get("ipv6_service"), "6to4")) /* tunnel 6to4 */
                strcpy(tmpstr, "Tunnel 6to4");
            else if(!strcmp(nmp_get("ipv6_service"), "6in4")) /* tunnel 6in4 */
                strcpy(tmpstr, "Tunnel 6in4");
            else if(!strcmp(nmp_get("ipv6_service"), "6rd")) /* tunnel 6rd */
                strcpy(tmpstr, "Tunnel 6rd");
            else if(!strcmp(nmp_get("ipv6_service"), "other")) /* static ipv6 */
                strcpy(tmpstr, "Static");

            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;                   
        }        
        return NULL;
    case IPV6WANADDRESS:
        if(strcmp(nmp_get("ipv6_service"), "disabled"))
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);            
            sprintf(tmpstr, getifaddr((char *) get_wan6face(), AF_INET6, GIF_PREFIXLEN) ? : "");
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;                   
        }   
        return NULL;
    case IPV6WANGATEWAY:
        if(strcmp(nmp_get("ipv6_service"), "disabled"))
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);            
            sprintf(tmpstr, ipv6_gateway_address() ? : "");
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;                   
        }   
        return NULL;
    case IPV6LANADDRESS:
        if(strcmp(nmp_get("ipv6_service"), "disabled"))
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s/%d", nmp_safe_get("ipv6_rtr_addr"), nmp_get_int("ipv6_prefix_length")); 
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;  
        }  
        return NULL;
    case IPV6LANLINKLOCALADDRESS:
        if(strcmp(nmp_get("ipv6_service"), "disabled"))
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", getifaddr(nmp_safe_get("lan_ifname"), AF_INET6, GIF_LINKLOCAL | GIF_PREFIXLEN) ? : ""); 
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;             
        }  
        return NULL;
    case IPV6DHCPPD:
        if(strcmp(nmp_get("ipv6_service"), "disabled"))
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", nmp_get_int("ipv6_dhcp_pd") ? "Enabled" : "Disabled"); 
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;                     
        }  
        return NULL;
    case IPV6LANPREFIX:
        if(strcmp(nmp_get("ipv6_service"), "disabled"))
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s/%d", nmp_safe_get("ipv6_prefix"), nmp_get_int("ipv6_prefix_length")); 
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;             
        }  
        return NULL;
    case IPV6DNSADDRESS:
        if(strcmp(nmp_get("ipv6_service"), "disabled"))
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            if (!strcmp(nmp_get("ipv6_service"), "dhcp6") &&
                nmp_get_int("ipv6_dnsenable")) {
                sprintf(tmpstr, "%s", nmp_safe_get("ipv6_get_dns"));
            } 
            else
            {
                char nvname[sizeof("ipv6_dnsXXX")];
                char *next = tmpstr;
                char *wan_dns;
                int i;                

                tmpstr[0] = '\0';
                for (i = 1; i <= 3; i++) {
                    snprintf(nvname, sizeof(nvname), "ipv6_dns%d", i);
                    wan_dns = nmp_safe_get(nvname);
                    if (*wan_dns)
                        next += sprintf(next, *tmpstr ? " %s" : "%s", wan_dns);
                }
            }  
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;   
        }  
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_wl2gStationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_systemLog above.
 */
unsigned char *
var_wl2gStationTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;


    if(!wireless_2g_flag)   //Get wieless(2.4G) info
    {
        wireless_2g_count = get_wireless_info(&wireless_2g_list, 0);
        wireless_2g_flag = 1;
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_WIRELESS /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WL2GSTATIONINDEX:
        return NULL;
    case WL2GSTATIONMACADDR:
        index = name[*length-1]-1;
    	if(index < wireless_2g_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", wireless_2g_list[index].mac_addr);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case WL2GASSOCIATED:
        index = name[*length-1]-1;
        if(index < wireless_2g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            strcpy(tmpstr, (wireless_2g_list[index].status & 0x1)? "Yes": "");
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL2GAUTHORIZED:
        index = name[*length-1]-1;
        if(index < wireless_2g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            strcpy(tmpstr, (wireless_2g_list[index].status & 0x2)? "Yes": "");
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL2GRSSI:
        index = name[*length-1]-1;
        if(index < wireless_2g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            strcpy(tmpstr, wireless_2g_list[index].rssi);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL2GPSM:
        index = name[*length-1]-1;
        if(index < wireless_2g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            if( wireless_2g_list[index].psm )
                strcpy(tmpstr, "Yes");
            else
                strcpy(tmpstr, "No");
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL2GTXRATE:
        index = name[*length-1]-1;
        if(index < wireless_2g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            if ((wireless_2g_list[index].tx_rate % 1000) == 0)
                sprintf(tmpstr, "%dM", wireless_2g_list[index].tx_rate / 1000);
            else
                sprintf(tmpstr, "%.1fM", (double) wireless_2g_list[index].tx_rate / 1000);            
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL2GRXRATE:
        index = name[*length-1]-1;
        if(index < wireless_2g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            if ((wireless_2g_list[index].rx_rate % 1000) == 0)
                sprintf(tmpstr, "%dM", wireless_2g_list[index].rx_rate / 1000);
            else
                sprintf(tmpstr, "%.1fM", (double) wireless_2g_list[index].rx_rate / 1000);            
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL2GSTATIONCONNECTTIME:
        index = name[*length-1]-1;    
        if(index < wireless_2g_count)
        {
            tmpval_u = wireless_2g_list[index].connect_time*100;
            *var_len = sizeof( u_long );
            return ( u_char * ) &tmpval_u;        
        }    
        wireless_2g_flag = 0;
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_wl5gStationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_system_log above.
 */
unsigned char *
var_wl5gStationTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    if(!wireless_5g_flag)   //Get wieless(2.4G) info
    {
        wireless_5g_count = get_wireless_info(&wireless_5g_list, 1);
        wireless_5g_flag = 1;
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_WIRELESS /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WL5GSTATIONINDEX:
        return NULL;
    case WL5GSTATIONMACADDR:
        index = name[*length-1]-1;
    	if(index < wireless_5g_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", wireless_5g_list[index].mac_addr);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case WL5GASSOCIATED:
        index = name[*length-1]-1;
        if(index < wireless_5g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            strcpy(tmpstr, (wireless_5g_list[index].status & 0x1)? "Yes": "");
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        } 
        return NULL;
    case WL5GAUTHORIZED:
        index = name[*length-1]-1;
        if(index < wireless_5g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            strcpy(tmpstr, (wireless_5g_list[index].status & 0x2)? "Yes": "");
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL5GRSSI:
        index = name[*length-1]-1;
        if(index < wireless_5g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            strcpy(tmpstr, wireless_5g_list[index].rssi);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL5GPSM:
        index = name[*length-1]-1;
        if(index < wireless_5g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            if( wireless_5g_list[index].psm )
                strcpy(tmpstr, "Yes");
            else
                strcpy(tmpstr, "No");
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL5GTXRATE:
        index = name[*length-1]-1;
        if(index < wireless_5g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            if ((wireless_5g_list[index].tx_rate % 1000) == 0)
                sprintf(tmpstr, "%dM", wireless_5g_list[index].tx_rate / 1000);
            else
                sprintf(tmpstr, "%.1fM", (double) wireless_5g_list[index].tx_rate / 1000);            
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL5GRXRATE:
        index = name[*length-1]-1;
        if(index < wireless_5g_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            if ((wireless_5g_list[index].rx_rate % 1000) == 0)
                sprintf(tmpstr, "%dM", wireless_5g_list[index].rx_rate / 1000);
            else
                sprintf(tmpstr, "%.1fM", (double) wireless_5g_list[index].rx_rate / 1000);            
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case WL5GSTATIONCONNECTTIME:
        index = name[*length-1]-1;    
        if(index < wireless_5g_count)
        {
            tmpval_u = wireless_5g_list[index].connect_time*100;
            *var_len = sizeof( u_long );
            return ( u_char * ) &tmpval_u;        
        }    
        wireless_5g_flag = 0;
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_dhcpLeasesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_system_log above.
 */
unsigned char *
var_dhcpLeasesTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)	//Doesn't support in AP and repeater mode
	   return NULL;

    if(!dhcp_lease_flag)	//Get dhcp lease info
    {
        dhcp_lease_count = get_dhcp_lease_info(&dhcp_lease_list);
        dhcp_lease_flag = 1;
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_DHCP_LEASE /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case DHCPLEASESINDEX:
        return NULL;
    case DHCPLEASESHOSTNAME:
        index = name[*length-1]-1;
    	if(index < dhcp_lease_count)
    	{
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", dhcp_lease_list[index].host_name);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case DHCPLEASESIPADDR:
        index = name[*length-1]-1;
    	if(index < dhcp_lease_count)
    	{
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", dhcp_lease_list[index].ip_addr);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
	return NULL;
    case DHCPLEASESMACADDR:
        index = name[*length-1]-1;
    	if(index < dhcp_lease_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", dhcp_lease_list[index].mac_addr);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
	return NULL;
    case DHCPLEASESEXPIRES:
        index = name[*length-1]-1;
    	if(index < dhcp_lease_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", dhcp_lease_list[index].expire);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        dhcp_lease_flag = 0;        
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_ipv6LanDevicesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_systemLog above.
 */
unsigned char *
var_ipv6LanDevicesTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER || !strcmp(nmp_get("ipv6_service"), "disabled"))    //Doesn't support in AP and repeater mode
       return NULL; 


    if(!ipv6Lan_dev_flag)
    {
        ipv6Lan_dev_count = get_lan_ipv6dev_list(&ipv6_landev_info);
        ipv6Lan_dev_flag = 1;
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_IPV6_DEVICES)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case IPV6LANDEVICEINDEX:
        return NULL;
    case IPV6LANDEVICEHOSTNAME:
        index = name[*length-1]-1;
        if(index < ipv6Lan_dev_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", ipv6_landev_info[index].hostname);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case IPV6LANDEVICEMACADDR:
        index = name[*length-1]-1;
        if(index < ipv6Lan_dev_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", ipv6_landev_info[index].mac_addr);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case IPV6LANDEVICEIPV6ADDR:
        index = name[*length-1]-1;
        if(index < ipv6Lan_dev_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", ipv6_landev_info[index].ipv6_addrs);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }    
        ipv6Lan_dev_flag = 0;
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_routingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_system_log above.
 */
unsigned char *
var_routingTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)	//Doesn't support in AP and repeater mode
	   return NULL;

    if(!routing_flag)	//Get routing info
    {
        routing_count = get_routing_info(&routing_list);
        routing_flag = 1;
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_ROUTING /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case ROUTINGINDEX:
        return NULL;
    case ROUTINGDESTINATION:
        index = name[*length-1]-1;
    	if(index < routing_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", routing_list[index].dest);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case ROUTINGGATEWAY:
        index = name[*length-1]-1;
    	if(index < routing_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", routing_list[index].gateway);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case ROUTINGGENMASK:
        index = name[*length-1]-1;
    	if(index < routing_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", routing_list[index].genmask);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case ROUTINGFLAGS:
        index = name[*length-1]-1;
    	if(index < routing_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", routing_list[index].flags);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case ROUTINGMETRIC:
        index = name[*length-1]-1;
    	if(index < routing_count)
    	{
    		tmpval = routing_list[index].metric;
    		*var_len = sizeof( long );
      		return ( u_char * ) &tmpval;			
    	}
        return NULL;
    case ROUTINGREF:
        index = name[*length-1]-1;
    	if(index < routing_count)
    	{
    		tmpval = routing_list[index].ref;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;    		
    	}
        return NULL;
    case ROUTINGUSE:
        index = name[*length-1]-1;
    	if(index < routing_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%d", routing_list[index].use);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case ROUTINGIFACE:
        index = name[*length-1]-1;
    	if(index < routing_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", routing_list[index].iface);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        routing_flag = 0;
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_ipv6RoutingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_systemLog above.
 */
unsigned char *
var_ipv6RoutingTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER || !strcmp(nmp_get("ipv6_service"), "disabled"))    //Doesn't support in AP and repeater mode
       return NULL; 

    if(!ipv6_routing_flag)   //Get routing info
    {
        ipv6_routing_count = get_ipv6_routing_info(&ipv6_routing_info);
        ipv6_routing_flag = 1;
    }


    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_ROUTING)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case IPV6ROUTINGINDEX:
        return NULL;
    case IPV6ROUTINGDEST:
        index = name[*length-1]-1;
        if(index < ipv6_routing_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", ipv6_routing_info[index].dest);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case IPV6ROUTINGNEXTHOP:
        index = name[*length-1]-1;
        if(index < ipv6_routing_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", ipv6_routing_info[index].next_hop);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case IPV6ROUTINGFLAGS:
        index = name[*length-1]-1;
        if(index < ipv6_routing_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", ipv6_routing_info[index].flags);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case IPV6ROUTINGMETRIC:
        index = name[*length-1]-1;    
        if(index < ipv6_routing_count)
        {
            tmpval = ipv6_routing_info[index].metric;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;      
        }
        return NULL;
    case IPV6ROUTINGREF:
        index = name[*length-1]-1;    
        if(index < ipv6_routing_count)
        {
            tmpval = ipv6_routing_info[index].ref;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;      
        }    
        return NULL;
    case IPV6ROUTINGUSE:
        index = name[*length-1]-1;    
        if(index < ipv6_routing_count)
        {
            tmpval = ipv6_routing_info[index].use;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;      
        }      
        return NULL;
    case IPV6ROUTINGIFACE:
        index = name[*length-1]-1;
        if(index < ipv6_routing_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", ipv6_routing_info[index].iface);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        ipv6_routing_flag = 0;
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_portForwardingLogTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_system_log above.
 */
unsigned char *
var_portForwardingLogTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)	//Doesn't support in AP and repeater mode
	return NULL;

    if(!port_forwarding_flag)	//Get port forwarding info
    {
    	port_forwarding_count = get_port_forwarding_info(&port_forwarding_list);
    	port_forwarding_flag = 1;
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_PORT_FORWARDING /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PORTFORWARDINGLOGINDEX:
        return NULL;
    case PORTFORWARDINGLOGDESTINATION:
        index = name[*length-1]-1;
    	if(index < port_forwarding_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", port_forwarding_list[index].dest);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case PORTFORWARDINGLOGPROTOCOL:
        index = name[*length-1]-1;
    	if(index < port_forwarding_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", port_forwarding_list[index].protocol);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case PORTFORWARDINGLOGPORTRANGE:
        index = name[*length-1]-1;
    	if(index < port_forwarding_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", port_forwarding_list[index].port_range);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case PORTFORWARDINGLOGREDIRECTTO:
        index = name[*length-1]-1;
    	if(index < port_forwarding_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", port_forwarding_list[index].redirect_to);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
        return NULL;
    case PORTFORWARDINGLOGLOCALPORT:
        index = name[*length-1]-1;
    	if(index < port_forwarding_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
    		sprintf(tmpstr, "%s", port_forwarding_list[index].local_port);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}
	port_forwarding_flag = 0;
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_activeConnectionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_systemLog above.
 */
unsigned char *
var_activeConnectionTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)    //Doesn't support in AP and repeater mode
       return NULL;     

    if(!active_connection_flag)   //Get port forwarding info
    {
        active_connection_count = get_active_connection_info(&active_connection_list);
        active_connection_flag = 1;
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_ACTIVE_CONNECTIONS)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case ACTIVECONNECTIONINDEX:
        return NULL;
    case ACTIVECONNECTIONPROTO:
        index = name[*length-1]-1;
        if(index < active_connection_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", active_connection_list[index].protocol);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case ACTIVECONNECTIONNATEDADDR:
        index = name[*length-1]-1;
        if(index < active_connection_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", active_connection_list[index].nated_addr);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case ACTIVECONNECTIONDESTADDR:
        index = name[*length-1]-1;
        if(index < active_connection_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", active_connection_list[index].dest);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        return NULL;
    case ACTIVECONNECTIONSTATE:
        index = name[*length-1]-1;
        if(index < active_connection_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN_SYSLOG);
            sprintf(tmpstr, "%s", active_connection_list[index].state);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }
        active_connection_flag = 0;
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_sysLogTftpSrv(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to systemLog not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 0 || var_val_len > 39) {
              fprintf(stderr, "write to systemLog: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tftpsrvip, 0, sizeof(tftpsrvip));
            strncpy(tftpsrvip, (u_char *)var_val, var_val_len);     
            tftpsrvip[var_val_len] = '\0';              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sysLogTftpFile(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to systemLog not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(logfile, 0, sizeof(logfile));
            strncpy(logfile, (u_char *)var_val, var_val_len);
            logfile[var_val_len] = '\0';              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sysLogSaveAct(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to systemLog not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to systemLog: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf ( stderr,"write to systemLog: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if( value == 1 && strcmp(tftpsrvip,""))
            {            
                if(!chdir("/tmp"))/* 0: Success -1: Failure */
                    eval("tftp", "-p", "-l", "syslog.log", "-r", logfile, tftpsrvip);
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wl2gRefreshSta(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to systemLog not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to systemLog: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf ( stderr,"write to systemLog: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               wireless_2g_count = get_wireless_info(&wireless_2g_list, 0); 
               wireless_2g_flag = 1;           
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wl5gRefreshSta(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to systemLog not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to systemLog: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf ( stderr,"write to systemLog: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            wireless_5g_count = get_wireless_info(&wireless_5g_list, 1);
            wireless_5g_flag = 1;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
