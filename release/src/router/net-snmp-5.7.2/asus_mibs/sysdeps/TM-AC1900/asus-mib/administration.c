/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "administration.h"
#include <signal.h>
#include <nmp.h>

#define MAXHTTPCLIENT		4
#define HTTPCLIENTSTRNUM	20
#define MAX_CLIENT_LIST		255
#define MACACCNUM			6
#define MAXACCSTRNUM		128
int mclient_count = 0;
client_list_info_t mclient_list[MAX_CLIENT_LIST];

#define firmwarefile "firmware.trx"
#define configfile   "settings"
#define defcfgfile   "RT-N66U.CFG"

static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static unsigned char tftpsrvip[39];
static unsigned char tftpfile[128];
static unsigned char cfgfile[128];
static int sw_mode = 0;

char *timezonelist[] = {"UTC12", "UTC11", "UTC10", "NAST9DST", "PST8DST","MST7DST_1", "MST7_2", "MST7DST_3", "CST6DST_1", "CST6DST_2",
			"CST6DST_3", "CST6DST_3_1", "UTC6", "EST5DST", "UTC5_1", "UTC5_2", "AST4DST", "UTC4_1", "UTC4DST_2", "NST3.30DST",
			"EBST3DST_1", "UTC3", "EBST3DST_2", "NORO2DST", "EUT1DST", "UTC1", "GMT0", "GMT0DST_1", "GMT0DST_2", "UTC-1DST_1",
			"UTC-1_1_1", "UTC-1_2", "UTC-1_2_1", "MET-1DST", "MET-1DST_1", "MEZ-1DST", "MEZ-1DST_1", "UTC-1_3", "UTC-2DST",
			"EST-2DST", "UTC-2_1", "UTC-2DST_2", "IST-2DST", "SAST-2", "EET-2DST", "UTC-3_1", "UTC-3_2", "IST-3DST",
			"UTC-3.30DST", "UTC-4_2", "UTC-4_3", "UTC-4_1", "UTC-4DST_2", "UTC-4.30", "UTC-5", "UTC-5.30_2",
			"UTC-5.30_1", "UTC-5.30", "UTC-5.45", "RFT-6DST", "UTC-6_1", "UTC-6", "UTC-6.30", "UTC-7", "CST-8_2",
			"CST-8", "CST-8_1", "SST-8", "CCT-8", "WAS-8DST", "UTC-8DST", "UTC-9_1", "JST", "CST-9.30DST", "UTC-9.30",
			"UTC-10_3", "UTC-10_1", "UTC-10_2", "TST-10TDT", "UTC-10_5", "UTC-11_2", "UTC-11", "UTC-11_1", "UTC-12",
			"NZST-12DST", "UTC-13"};

char *syscmd[] = {"commit", "reboot", "resetdefault", "restart_wireless", "restart_net_and_phy", "restart_net", "restart_wan_if", "restart_firewall",
			"restart_ddns", "restart_pppoe_relay", "restart_allnet", "restart_pptpd", "restart_all", "restart_time", "restart_qos",
			"restart_upnp", "restart_ntpc", "restart_snmpd", "wps_apply", "reset_wps"};

/* 
 * administration_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid administration_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,8 };

/* 
 * variable4 administration_variables:
 *   this variable defines function callbacks and type return information 
 *   for the administration mib section 
 */

struct variable7 administration_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define OPERATIONMODE		1
{OPERATIONMODE,  ASN_INTEGER,  RWRITE,  var_administration, 2,  { 1,1 }},
#define ROUTERLOGINNAME		2
{ROUTERLOGINNAME,  ASN_OCTET_STR,  RWRITE,  var_administration, 3,  { 2,1,1 }},
#define NEWPASSWORD		3
{NEWPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_administration, 3,  { 2,1,2 }},
#define WPSBUTTONBEHAVIOR		4
{WPSBUTTONBEHAVIOR,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,1 }},
#define REMOTELOGSERVER		5
{REMOTELOGSERVER,  ASN_IPADDRESS,  RWRITE,  var_administration, 3,  { 2,2,2 }},
#define TIMEZONE		6
{TIMEZONE,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,3 }},
#define MANUALLYSETDAYLIGHTSAVEINGTIME		7
{MANUALLYSETDAYLIGHTSAVEINGTIME,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,4 }},
#define DSTSTARTTIMEMONTH		8
{DSTSTARTTIMEMONTH,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,5 }},
#define DSTSTARTTIMEWEEK		9
{DSTSTARTTIMEWEEK,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,6 }},
#define DSTSTARTTIMEWEEKDAY		10
{DSTSTARTTIMEWEEKDAY,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,7 }},
#define DSTSTARTTIMEHOUR		11
{DSTSTARTTIMEHOUR,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,8 }},
#define DSTENDTIMEMONTH		12
{DSTENDTIMEMONTH,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,9 }},
#define DSTENDTIMEWEEK		13
{DSTENDTIMEWEEK,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,10 }},
#define DSTENDTIMEWEEKDAY		14
{DSTENDTIMEWEEKDAY,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,11 }},
#define DSTENDTIMEHOUR		15
{DSTENDTIMEHOUR,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,12 }},
#define NTPSERVER		16
{NTPSERVER,  ASN_OCTET_STR,  RWRITE,  var_administration, 3,  { 2,2,13 }},
//#define ENABLETELNET		17
//{ENABLETELNET,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,14 }},
#define AUTHENTICATIONMETHOD		18
{AUTHENTICATIONMETHOD,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,15 }},
//#define HTTPSLANPORT		19
//{HTTPSLANPORT,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,16 }},
#define ENABLEWEBACCESSFROMWAN		20
{ENABLEWEBACCESSFROMWAN,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,17 }},
#define HTTPPORTWEBACCESSFROMWAN		21
{HTTPPORTWEBACCESSFROMWAN,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,18 }},
#define HTTPSPORTWEBACCESSFROMWAN		22
{HTTPSPORTWEBACCESSFROMWAN,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,19 }},
#define AUTOLOGOUT		23
{AUTOLOGOUT,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,20 }},
#define ONLYALLOWSPECIFICIP		24
{ONLYALLOWSPECIFICIP,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,21 }},
#define MSCANCLIENTLISTACT		25
{MSCANCLIENTLISTACT,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 2,2,22 }},
#define FTFTPSRV		26
{FTFTPSRV,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 3,1 }},
#define FTFTPFILE		27
{FTFTPFILE,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 3,2 }},
#define FFIRMWAREUPGRADE		28
{FFIRMWAREUPGRADE,  ASN_INTEGER,  RWRITE,  var_administration, 2,  { 3,3 }},
#define STFTPSRV		29
{STFTPSRV,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 4,1 }},
#define STFTPFILE		30
{STFTPFILE,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 4,2 }},
#define STFTPACTION		31
{STFTPACTION,  ASN_INTEGER,  RWRITE,  var_administration, 2,  { 4,3 }},
#define SNMPENABLE		32
{SNMPENABLE,  ASN_INTEGER,  RWRITE,  var_administration, 2,  { 5,1 }},
#define SNSYSTEMNAME		33
{SNSYSTEMNAME,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 5,2 }},
#define SNLOCATION		34
{SNLOCATION,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 5,3 }},
#define SNCONTACT		35
{SNCONTACT,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 5,4 }},
#define SNGETCOMMUNITY		36
{SNGETCOMMUNITY,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 5,5 }},
#define SNSETCOMMUNITY		37
{SNSETCOMMUNITY,  ASN_OCTET_STR,  RWRITE,  var_administration, 2,  { 5,6 }},
#define AUTHPROTOCOL		38
{AUTHPROTOCOL,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 5,7,1 }},
#define AUTHPASS		39
{AUTHPASS,  ASN_OCTET_STR,  RWRITE,  var_administration, 3,  { 5,7,2 }},
#define PRIVPROTOCOL		40
{PRIVPROTOCOL,  ASN_INTEGER,  RWRITE,  var_administration, 3,  { 5,7,3 }},
#define PRIVPASS		41
{PRIVPASS,  ASN_OCTET_STR,  RWRITE,  var_administration, 3,  { 5,7,4 }},
#define SNVERSION		42
{SNVERSION,  ASN_OCTET_STR,  RONLY ,  var_administration, 2,  { 5,8 }},
#define SYSTEMCOMMAND		43
{SYSTEMCOMMAND,  ASN_INTEGER,  RWRITE,  var_administration, 1,  { 6 }},

#define MSCANCLIENTINDEX		44
{MSCANCLIENTINDEX,  ASN_INTEGER,  RONLY,   var_mScanClientTable, 5,  { 2,2,23, 1, 1 }},
#define MSCANCLIENTIPADDR		45
{MSCANCLIENTIPADDR,  ASN_IPADDRESS,  RONLY,   var_mScanClientTable, 5,  { 2,2,23, 1, 2 }},
#define MSCANCLIENTNAME		46
{MSCANCLIENTNAME,  ASN_OCTET_STR,  RONLY,   var_mScanClientTable, 5,  { 2,2,23, 1, 3 }},
#define MCLIENTLISTINDEX		47
{MCLIENTLISTINDEX,  ASN_INTEGER,  RONLY,   var_mClientListTable, 5,  { 2,2,24, 1, 1 }},
#define MCLIENTLISTCLIENT		48
{MCLIENTLISTCLIENT,  ASN_IPADDRESS,  RWRITE,  var_mClientListTable, 5,  { 2,2,24, 1, 2 }},
#define MCLIENTLISTDELENTRY		49
{MCLIENTLISTDELENTRY,  ASN_INTEGER,  RWRITE,  var_mClientListTable, 5,  { 2,2,24, 1, 3 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the administration module */
void
init_administration(void)
{

    DEBUGMSGTL(("administration", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("administration", administration_variables, variable7,
               administration_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * var_administration():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_administration(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    int i;

    sw_mode = nmp_get_int("sw_mode");

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case OPERATIONMODE:
        *write_method = write_operationMode;
        if(nmp_safe_get("sw_mode") != NULL)
		{
			tmpval = nmp_get_int("sw_mode");
			if(tmpval == 3 && !strcmp(nmp_safe_get("wlc_psta"), "1"))
				tmpval = 4;/* Media Bridge */
	      	*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case ROUTERLOGINNAME:
    	*write_method = write_routerLoginName;
	    if(nmp_safe_get("acc_list") != NULL)
	    {
	    	long index;
	    	char acc_list[MACACCNUM][MAXACCSTRNUM];
	    	int i, acc_count = 0;
	    	char *nv, *nvp, *b, *username, *passwd;

	    	for(i = 0; i < MACACCNUM; i++)
	    		memset(acc_list[i], 0x0, MAXACCSTRNUM);
	    
	    	memset(tmpstr, 0x0, SPRINT_MAX_LEN);

		    nv = nvp = strdup(nmp_safe_get("acc_list"));
		    if (nv) {
		    	while ((b = strsep(&nvp, "<")) != NULL) {
		    		if (strlen(b)==0) continue;
		    		strcpy(acc_list[acc_count], b);
		    		acc_count++;		
		    	}
		        free(nv);
		    }

	        if(acc_count > 0) {
	        	if (strlen(acc_list[0])) {
	    			if(vstrsep(acc_list[0], ">", &username, &passwd) != 2) break;
	    			strcpy(tmpstr, username);
	    			*var_len = strlen( tmpstr );
					return ( u_char * ) tmpstr;	
	            }
	        }
		}	        
		else if(nmp_safe_get("http_username") != NULL) {
			strcpy(tmpstr, nmp_safe_get("http_username"));
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		}
		return NULL;
    case NEWPASSWORD:
        *write_method = write_newPassword;
	    if(nmp_safe_get("acc_list") != NULL)
	    {
	    	long index;
	    	char acc_list[MACACCNUM][MAXACCSTRNUM];
	    	int i, acc_count = 0;
	    	char *nv, *nvp, *b, *username, *passwd;

	    	for(i = 0; i < MACACCNUM; i++)
	    		memset(acc_list[i], 0x0, MAXACCSTRNUM);
	    
	    	memset(tmpstr, 0x0, SPRINT_MAX_LEN);

		    nv = nvp = strdup(nmp_safe_get("acc_list"));
		    if (nv) {
		    	while ((b = strsep(&nvp, "<")) != NULL) {
		    		if (strlen(b)==0) continue;
		    		strcpy(acc_list[acc_count], b);
		    		acc_count++;		
		    	}
		        free(nv);
		    }

	        if(acc_count > 0) {
	        	if (strlen(acc_list[0])) {
	    			if(vstrsep(acc_list[0], ">", &username, &passwd) != 2) break;
	    			strcpy(tmpstr, passwd);
	    			*var_len = strlen( tmpstr );
					return ( u_char * ) tmpstr;	
	            }
	        }
		}	        
		else if(nmp_safe_get("http_passwd") != NULL) {
			strcpy(tmpstr, nmp_safe_get("http_passwd"));
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		} 
		return NULL; 
    case WPSBUTTONBEHAVIOR:
        *write_method = write_wpsButtonBehavior;
        if(nmp_safe_get("btn_ez_radiotoggle") != NULL)
		{
			tmpval = nmp_get_int("btn_ez_radiotoggle");
			if(tmpval == 1) /* toggle radio */
				tmpval = 1;
			else if(tmpval == 0) /* activate wps */
				tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case REMOTELOGSERVER:
        *write_method = write_remoteLogServer;
		tmpval_u = 0;
		if(nmp_safe_get("log_ipaddr") != NULL)
		{
			memset(tmpstr, 0x0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("log_ipaddr"));
			if(strlen(tmpstr))
				tmpval_u = inet_addr(tmpstr);
		}
		*var_len = sizeof( unsigned long );
		return ( u_char * ) &tmpval_u;
    case TIMEZONE:
        *write_method = write_timeZone;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("time_zone") != NULL)
        {
			strcpy(tmpstr, nmp_safe_get("time_zone"));
			for(i = 0; i < 85; i++)
			{
				if(!strcmp(tmpstr, timezonelist[i]))
					tmpval = i + 1;
			}
	      	*var_len = sizeof( long );
			return ( u_char * ) &tmpval;	
        }
        return NULL;
    case MANUALLYSETDAYLIGHTSAVEINGTIME:
        *write_method = write_manuallySetDaylightSaveingTime;
        if(nmp_safe_get("time_zone_dst") != NULL)
		{
			tmpval = nmp_get_int("time_zone_dst");
			if(tmpval == 1) /* yes */
				tmpval = 1;
			else if(tmpval == 0) /* no */
				tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case DSTSTARTTIMEMONTH:
        *write_method = write_dstStartTimeMonth;
        if(nmp_safe_get("time_zone_dstoff") != NULL)
      	{
			char *startDstStr, *endDstStr;
			tmpval = 0;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
			if(strlen(tmpstr)) {
				int month, week, weekday, hour;
				if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
				sscanf(startDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);
				tmpval = month;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
			else
				return NULL;
      	}	
        return NULL;
    case DSTSTARTTIMEWEEK:
        *write_method = write_dstStartTimeWeek;
        if(nmp_safe_get("time_zone_dstoff") != NULL)
      	{
			char *startDstStr, *endDstStr;
			tmpval = 0;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
			if(strlen(tmpstr)) {
				int month, week, weekday, hour;
				if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
				sscanf(startDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);
				tmpval = week;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
			else
				return NULL;
      	}	
        return NULL;
    case DSTSTARTTIMEWEEKDAY:
        *write_method = write_dstStartTimeWeekday;
        if(nmp_safe_get("time_zone_dstoff") != NULL)
      	{
			char *startDstStr, *endDstStr;
			tmpval = 0;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
			if(strlen(tmpstr)) {
				int month, week, weekday, hour;
				if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
				sscanf(startDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);
				tmpval = weekday;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
			else
				return NULL;
      	}	
        return NULL;
    case DSTSTARTTIMEHOUR:
        *write_method = write_dstStartTimeHour;
        if(nmp_safe_get("time_zone_dstoff") != NULL)
      	{
			char *startDstStr, *endDstStr;
			tmpval = 0;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
			if(strlen(tmpstr)) {
				int month, week, weekday, hour;
				if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
				sscanf(startDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);
				tmpval = hour;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
			else
				return NULL;
      	}	
        return NULL;
    case DSTENDTIMEMONTH:
        *write_method = write_dstEndTimeMonth;
        if(nmp_safe_get("time_zone_dstoff") != NULL)
      	{
			char *startDstStr, *endDstStr;
			tmpval = 0;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
			if(strlen(tmpstr)) {
				int month, week, weekday, hour;
				if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
				sscanf(endDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);
				tmpval = month;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
			else
				return NULL;
      	}	
        return NULL;
    case DSTENDTIMEWEEK:
        *write_method = write_dstEndTimeWeek;
        if(nmp_safe_get("time_zone_dstoff") != NULL)
      	{
			char *startDstStr, *endDstStr;
			tmpval = 0;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
			if(strlen(tmpstr)) {
				int month, week, weekday, hour;
				if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
				sscanf(endDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);
				tmpval = week;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
			else
				return NULL;
      	}	
        return NULL;
    case DSTENDTIMEWEEKDAY:
        *write_method = write_dstEndTimeWeekday;
        if(nmp_safe_get("time_zone_dstoff") != NULL)
      	{
			char *startDstStr, *endDstStr;
			tmpval = 0;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
			if(strlen(tmpstr)) {
				int month, week, weekday, hour;
				if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
				sscanf(endDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);
				tmpval = weekday;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
			else
				return NULL;
      	}	
        return NULL;
    case DSTENDTIMEHOUR:
        *write_method = write_dstEndTimeHour;
        if(nmp_safe_get("time_zone_dstoff") != NULL)
      	{
			char *startDstStr, *endDstStr;
			tmpval = 0;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
			if(strlen(tmpstr)) {
				int month, week, weekday, hour;
				if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
				sscanf(endDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);
				tmpval = hour;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
			else
				return NULL;
      	}	
        return NULL;
    case NTPSERVER:
        *write_method = write_ntpServer;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ntp_server0") != NULL)
        {
			strcpy(tmpstr, nmp_safe_get("ntp_server0"));
			tmpstr[strlen(tmpstr)] = '\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
        }
        return NULL;
#if 0	// TMO disable it
    case ENABLETELNET:
        *write_method = write_enableTelnet;
        if(nmp_safe_get("telnetd_enable") != NULL)
		{
			tmpval = nmp_get_int("telnetd_enable");
			if(tmpval == 1) /* yes */
				tmpval = 1;
			else if(tmpval == 0) /* no */
				tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
#endif
    case AUTHENTICATIONMETHOD:
        *write_method = write_authenticationMethod;
        if(nmp_safe_get("http_enable") != NULL)
		{
			tmpval = nmp_get_int("http_enable");
			if(tmpval == 0) /* http */
				tmpval = 1;
			else if(tmpval == 1) /* https */
				tmpval = 2;
			else if(tmpval == 2) /* both */
				tmpval = 3;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
/*	// TMO disable it
    case HTTPSLANPORT:
        *write_method = write_httpsLanPort;
        if(nmp_safe_get("https_lanport") != NULL)
      	{
		tmpval = nmp_get_int("https_lanport");
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
      	}
        return NULL;
*/
    case ENABLEWEBACCESSFROMWAN:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_enableWebAccessfromWAN;
			if(nmp_safe_get("misc_http_x") != NULL)
			{
				tmpval = nmp_get_int("misc_http_x");
				if(tmpval == 1) /* yes */
					tmpval = 1;
				else if(tmpval == 0) /* no */
					tmpval = 2;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case HTTPPORTWEBACCESSFROMWAN:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_httpPortWebAccessfromWAN;
			if(nmp_safe_get("misc_httpport_x") != NULL)
		      	{
				tmpval = nmp_get_int("misc_httpport_x");
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
		      	}
		}
        return NULL;
    case HTTPSPORTWEBACCESSFROMWAN:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_httpsPortWebAccessfromWAN;
			if(nmp_safe_get("misc_httpsport_x") != NULL)
		    {
				tmpval = nmp_get_int("misc_httpsport_x");
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
		    }
		}
	    return NULL;
    case AUTOLOGOUT:
        *write_method = write_autoLogout;
		if(nmp_safe_get("http_autologout") != NULL)
		{
			tmpval = nmp_get_int("http_autologout");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
        return NULL;
    case ONLYALLOWSPECIFICIP:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_onlyAllowSpecificIP;
			if(nmp_safe_get("http_client") != NULL)
			{
				tmpval = nmp_get_int("http_client");
				if(tmpval == 1) /* yes */
					tmpval = 1;
				else if(tmpval == 0) /* no */
					tmpval = 2;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case MSCANCLIENTLISTACT:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_mScanClientListAct;
			*var_len = sizeof( long );
			tmpval = 2; /* 1: scan	2: nothing */
			return ( u_char * ) &tmpval;
		}
	return NULL;
    case FTFTPSRV:
        *write_method = write_fTftpSrv;
       	*var_len = strlen(tftpsrvip);
        return ( u_char * ) tftpsrvip;
    case FTFTPFILE:
        *write_method = write_fTftpFile;
        *var_len = strlen(tftpfile);
        return ( u_char * ) tftpfile;
    case FFIRMWAREUPGRADE:
        *write_method = write_fFirmwareUpgrade;
        *var_len = sizeof( long );
        tmpval = 2; /*1: upgrade	2: nothing*/
        return ( u_char * ) &tmpval;
    case STFTPSRV:
        *write_method = write_sTftpSrv;
       	*var_len = strlen(tftpsrvip);
        return ( u_char * ) tftpsrvip;
    case STFTPFILE:
        *write_method = write_sTftpFile;
        *var_len = strlen(cfgfile);
        return ( u_char * ) cfgfile;
    case STFTPACTION:
        *write_method = write_sTftpAction;
        tmpval = 3; /* 1: get	2: put	  3:nothing*/
        *var_len = sizeof( long );        
        return ( u_char * ) &tmpval;
    case SNMPENABLE:
        *write_method = write_snmpEnable;
		if(nmp_safe_get("snmpd_enable") != NULL)
		{
			tmpval = nmp_get_int("snmpd_enable");
			if(tmpval == 0)//no
				tmpval = 2;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
    case SNSYSTEMNAME:
        *write_method = write_snSystemName;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("sysName")!=NULL)
		{
			strcpy(tmpstr, nmp_safe_get("sysName"));
			tmpstr[strlen( tmpstr )] ='\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		}	 
        return NULL;
    case SNLOCATION:
        *write_method = write_snLocation;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("sysLocation")!=NULL)
		{
			strcpy(tmpstr, nmp_safe_get("sysLocation"));
			tmpstr[strlen( tmpstr )] ='\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		}	 
        return NULL;
    case SNCONTACT:
        *write_method = write_snContact;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("sysContact")!=NULL)
		{
			strcpy(tmpstr, nmp_safe_get("sysContact"));
			tmpstr[strlen( tmpstr )] ='\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		}	 
        return NULL;
    case SNGETCOMMUNITY:
        *write_method = write_snGetCommunity;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("roCommunity")!=NULL)
		{
			strcpy(tmpstr, nmp_safe_get("roCommunity"));
			tmpstr[strlen( tmpstr )] ='\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		}	 
        return NULL;
    case SNSETCOMMUNITY:
        *write_method = write_snSetCommunity;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("rwCommunity")!=NULL)
		{
			strcpy(tmpstr, nmp_safe_get("rwCommunity"));
			tmpstr[strlen( tmpstr )] ='\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		}	 
        return NULL;
    case AUTHPROTOCOL:
        *write_method = write_authProtocol;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        tmpval = 0;        
        if(nmp_safe_get("v3_auth_type") != NULL )
        {
			strcpy(tmpstr, nmp_safe_get("v3_auth_type"));
			
			if( !strcmp( tmpstr, "NONE") )
				tmpval = 1;
			else if( !strcmp( tmpstr, "MD5") )
				tmpval = 2;
			else if( !strcmp( tmpstr, "SHA") )
				tmpval = 3;		
																	
			if( tmpval>=1 && tmpval<=3 ){
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}	
        }	
        return NULL;
    case AUTHPASS:
        *write_method = write_authPass;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("v3_auth_passwd")!=NULL)
		{
			strcpy(tmpstr, nmp_safe_get("v3_auth_passwd"));
			tmpstr[strlen( tmpstr )] ='\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		}	 
        return NULL;
    case PRIVPROTOCOL:
        *write_method = write_privProtocol;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        tmpval = 0;        
        if(nmp_safe_get("v3_priv_type") != NULL )
        {
			strcpy(tmpstr, nmp_safe_get("v3_priv_type"));
			
			if( !strcmp( tmpstr, "NONE") )
				tmpval = 1;
			else if( !strcmp( tmpstr, "DES") )
				tmpval = 2;
			else if( !strcmp( tmpstr, "AES") )
				tmpval = 3;			
																	
			if( tmpval>=1 && tmpval<=3 ){
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
        }
        return NULL;
    case PRIVPASS:
        *write_method = write_privPass;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("v3_priv_passwd")!=NULL)
		{
			strcpy(tmpstr, nmp_safe_get("v3_priv_passwd"));
			tmpstr[strlen( tmpstr )] ='\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
		}	 
        return NULL;
    case SNVERSION:
    	memset(tmpstr, 0, SPRINT_MAX_LEN);
        sprintf(tmpstr, "v1 v2 v3");
        *var_len = strlen(tmpstr);
        return ( u_char * ) tmpstr;
    case SYSTEMCOMMAND:
        *write_method = write_systemCommand;
        *var_len = sizeof( long );
        tmpval = 21;	/* nothing */
		return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_mScanClientTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_administration above.
 */
unsigned char *
var_mScanClientTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    long index = 0;

    sw_mode = nmp_get_int("sw_mode");  

    if(sw_mode == SW_MODE_AP)	//Doesn't support in AP mode
	return NULL;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_CLIENT_LIST /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case MSCANCLIENTINDEX:
        return NULL;
    case MSCANCLIENTIPADDR:
        index = name[*length-1]-1;
    	if(index < mclient_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%d.%d.%d.%d", mclient_list[index].ip_addr[0],
						mclient_list[index].ip_addr[1],
						mclient_list[index].ip_addr[2],
						mclient_list[index].ip_addr[3]);

			tmpval_u = inet_addr(tmpstr);
			*var_len = sizeof( unsigned long );
			return ( u_char * ) &tmpval_u;			
    	}	
        return NULL;
    case MSCANCLIENTNAME:
        index = name[*length-1]-1;
    	if(index < mclient_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%s", mclient_list[index].device_name);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_mClientListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_administration above.
 */
unsigned char *
var_mClientListTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    long index;
    char http_clientlist[MAXHTTPCLIENT][HTTPCLIENTSTRNUM];
    int i, http_clientlist_count = 0;
    char *nv, *nvp, *b;

    sw_mode = nmp_get_int("sw_mode");  

    if(sw_mode == SW_MODE_AP)	//Doesn't support in AP mode
	return NULL;

    for(i = 0; i < MAXHTTPCLIENT; i++)
    	memset(http_clientlist[i], 0x0, HTTPCLIENTSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of http_clientlist
    nv = nvp = strdup(nmp_safe_get("http_clientlist"));
    if (nv) {
		while ((b = strsep(&nvp, "<")) != NULL) {
			if (strlen(b)==0) continue;
			strcpy(http_clientlist[http_clientlist_count], b);
			http_clientlist_count++;		
		}
		free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXHTTPCLIENT /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case MCLIENTLISTINDEX:
        return NULL;
    case MCLIENTLISTCLIENT:
        *write_method = write_mClientListClient;
        tmpval_u = 0;
		index = name[*length-1]-1;
        if(index <= http_clientlist_count-1) {
        	if (strlen(http_clientlist[index])) {
				tmpval_u = inet_addr(http_clientlist[index]);
			}
    	}
		*var_len = sizeof( unsigned long );
		return ( u_char * ) &tmpval_u;    	
    case MCLIENTLISTDELENTRY:
        *write_method = write_mClientListDelEntry;
		index = name[*length-1]-1;
	    tmpval = 2; /* no */
	 	*var_len = sizeof( long );
	    return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_operationMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 4){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if(value == 4)/* Media Bridge */
			{              
				nmp_set("sw_mode", "3");
				nmp_set("wlc_psta", "1");
			}
			else
				nmp_set_int("sw_mode", value);		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_routerLoginName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 20 ) {
              fprintf(stderr, "write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 20)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
		tmpstr[var_val_len] = '\0';
        	nmp_set("http_username", tmpstr); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_newPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 16 ) {
              fprintf(stderr, "write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 16)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
		tmpstr[var_val_len] = '\0';
        	nmp_set("http_passwd", tmpstr); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpsButtonBehavior(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("btn_ez_radiotoggle", "1");
             	else if(value == 2)
			nmp_set("btn_ez_radiotoggle", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_remoteLogServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to administration not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("log_ipaddr", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_timeZone(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 86){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if(value >= 1 && value <= 85)
			nmp_set("time_zone", timezonelist[value-1]);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_manuallySetDaylightSaveingTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		nmp_set_int("time_zone_dst", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dstStartTimeMonth(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char *startDstStr, *endDstStr;
    int month, week, weekday, hour;
    char dstTimeStr[32];

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 12){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(dstTimeStr, 0, sizeof(dstTimeStr));
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
		if(strlen(tmpstr)) {
			if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
			sscanf(startDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);

			sprintf(dstTimeStr, "M%d.%d.%d/%d,%s", value, week, weekday, hour, endDstStr);
		}
		else
			sprintf(dstTimeStr, "M%d.1.0/0,M12.5.6/23", value);
		
		if(strlen(dstTimeStr))
			nmp_set("time_zone_dstoff", dstTimeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dstStartTimeWeek(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char *startDstStr, *endDstStr;
    int month, week, weekday, hour;
    char dstTimeStr[32];

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 5){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(dstTimeStr, 0, sizeof(dstTimeStr));
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
		if(strlen(tmpstr)) {
			if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
			sscanf(startDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);

			sprintf(dstTimeStr, "M%d.%d.%d/%d,%s", month, value, weekday, hour, endDstStr);
		}
		else
			sprintf(dstTimeStr, "M1.%d.0/0,M12.5.6/23", value);
		
		if(strlen(dstTimeStr))
			nmp_set("time_zone_dstoff", dstTimeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dstStartTimeWeekday(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char *startDstStr, *endDstStr;
    int month, week, weekday, hour;
    char dstTimeStr[32];

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 6){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(dstTimeStr, 0, sizeof(dstTimeStr));
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
		if(strlen(tmpstr)) {
			if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
			sscanf(startDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);

			sprintf(dstTimeStr, "M%d.%d.%d/%d,%s", month, week, value, hour, endDstStr);
		}
		else
			sprintf(dstTimeStr, "M1.1.%d/0,M12.5.6/23", value);
		
		if(strlen(dstTimeStr))
			nmp_set("time_zone_dstoff", dstTimeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dstStartTimeHour(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char *startDstStr, *endDstStr;
    int month, week, weekday, hour;
    char dstTimeStr[32];

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 23){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(dstTimeStr, 0, sizeof(dstTimeStr));
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
		if(strlen(tmpstr)) {
			if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
			sscanf(startDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);

			sprintf(dstTimeStr, "M%d.%d.%d/%d,%s", month, week, weekday, value, endDstStr);
		}
		else
			sprintf(dstTimeStr, "M1.1.0/%d,M12.5.6/23", value);
		
		if(strlen(dstTimeStr))
			nmp_set("time_zone_dstoff", dstTimeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dstEndTimeMonth(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char *startDstStr, *endDstStr;
    int month, week, weekday, hour;
    char dstTimeStr[32];

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 12){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(dstTimeStr, 0, sizeof(dstTimeStr));
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
		if(strlen(tmpstr)) {
			if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
			sscanf(endDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);

			sprintf(dstTimeStr, "%s,M%d.%d.%d/%d", startDstStr, value, week, weekday, hour);
		}
		else
			sprintf(dstTimeStr, "M1.1.0/0,M%d.5.6/23", value);
		
		if(strlen(dstTimeStr))
			nmp_set("time_zone_dstoff", dstTimeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dstEndTimeWeek(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char *startDstStr, *endDstStr;
    int month, week, weekday, hour;
    char dstTimeStr[32];

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 5){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(dstTimeStr, 0, sizeof(dstTimeStr));
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
		if(strlen(tmpstr)) {
			if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
			sscanf(endDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);

			sprintf(dstTimeStr, "%s,M%d.%d.%d/%d", startDstStr, month, value, weekday, hour);
		}
		else
			sprintf(dstTimeStr, "M1.1.0/0,M12.%d.6/23", value);
		
		if(strlen(dstTimeStr))
			nmp_set("time_zone_dstoff", dstTimeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dstEndTimeWeekday(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char *startDstStr, *endDstStr;
    int month, week, weekday, hour;
    char dstTimeStr[32];

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 6){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(dstTimeStr, 0, sizeof(dstTimeStr));
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
		if(strlen(tmpstr)) {
			if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
			sscanf(endDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);

			sprintf(dstTimeStr, "%s,M%d.%d.%d/%d", startDstStr, month, week, value, hour);
		}
		else
			sprintf(dstTimeStr, "M1.1.0/0,M12.5.%d/23", value);
		
		if(strlen(dstTimeStr))
			nmp_set("time_zone_dstoff", dstTimeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dstEndTimeHour(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char *startDstStr, *endDstStr;
    int month, week, weekday, hour;
    char dstTimeStr[32];

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 23){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(dstTimeStr, 0, sizeof(dstTimeStr));
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("time_zone_dstoff"));
		if(strlen(tmpstr)) {
			if((vstrsep(tmpstr, ",", &startDstStr, &endDstStr) != 2)) return NULL;
			sscanf(endDstStr, "M%d.%d.%d/%d", &month, &week, &weekday, &hour);

			sprintf(dstTimeStr, "%s,M%d.%d.%d/%d", startDstStr, month, week, weekday, value);
		}
		else
			sprintf(dstTimeStr, "M1.1.0/0,M12.5.6/%d", value);
		
		if(strlen(dstTimeStr))
			nmp_set("time_zone_dstoff", dstTimeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ntpServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 256 ) {
              fprintf(stderr, "write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 256)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
		tmpstr[var_val_len] = '\0';
        	nmp_set("ntp_server0", tmpstr); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if 0	// TMO disable it
int
write_enableTelnet(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("telnetd_enable", "1");
             	else if(value == 2)
			nmp_set("telnetd_enable", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_authenticationMethod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3) {
              fprintf(stderr, "write to administration: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3) {
      		switch(value)
      		{
      			case 1:/* http */
				nmp_set("http_enable", "0");
				break;
      			case 2:/* https */
				nmp_set("http_enable", "1");
				break;
      			case 3:/* both */
				nmp_set("http_enable", "2");
				break;
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if 0	// TMO disable it
int
write_httpsLanPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("https_lanport", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_enableWebAccessfromWAN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("misc_http_x", "1");
             	else if(value == 2)
			nmp_set("misc_http_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_httpPortWebAccessfromWAN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("misc_httpport_x", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_httpsPortWebAccessfromWAN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("misc_httpsport_x", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_autoLogout(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 999){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              nmp_set_int("http_autologout", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_onlyAllowSpecificIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
         	if(value == 1)
				nmp_set("http_client", "1");
			else if(value == 2)
				nmp_set("http_client", "0");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_mScanClientListAct(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1) {
             	mclient_count = get_client_detail_info(&mclient_list);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_fTftpSrv(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 0 || var_val_len > 39) {
              fprintf(stderr, "write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if ( var_val_len >= 0 && var_val_len <= 39 ) {
			memset(tftpsrvip, 0, sizeof(tftpsrvip));
			strncpy(tftpsrvip, (u_char *)var_val, var_val_len);
			tftpsrvip[var_val_len] = '\0';
		}    
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_fTftpFile(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			memset(tftpfile, 0, sizeof(tftpfile));
			strncpy(tftpfile, (u_char *)var_val, var_val_len);    
			tftpfile[var_val_len] = '\0';  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_fFirmwareUpgrade(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          } 
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if( *(long *)var_val == 1 )
		{
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			if(strcmp(tftpsrvip,"") && strcmp(tftpfile,""))
			{	
				//sprintf(tmpstr,"%s:%s", tftpsrvip, tftpfile);
				if(!chdir("/tmp"))
				{
					//eval("tftp", "get", tmpstr, firmwarefile);
					//eval("write","/tmp/firmware.trx","/dev/mtd/1");
					eval("tftp", "-g", "-l", firmwarefile, "-r", tftpfile, tftpsrvip);
					eval("mtd-write", "-i", "/tmp/firmware.trx", "-d", "linux");
					kill(1, SIGTERM);
				}
			}
			else
				return SNMP_ERR_GENERR;			
		}      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sTftpSrv(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 0 || var_val_len > 39) {
              fprintf(stderr, "write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if ( var_val_len >= 0 && var_val_len <= 39 ) {
				memset(tftpsrvip, 0, sizeof(tftpsrvip));
				strncpy(tftpsrvip, (u_char *)var_val, var_val_len); 
				tftpsrvip[var_val_len] = '\0';
			}      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sTftpFile(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			memset(cfgfile, 0, sizeof(cfgfile));
			strncpy(cfgfile, (u_char *)var_val, var_val_len);
			cfgfile[var_val_len] = '\0';
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sTftpAction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3) {
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			value = *(long *)var_val;  
			switch ( value )
			{		
				case 1:/* get */
					memset(tmpstr,0,SPRINT_MAX_LEN);
					if( strcmp(tftpsrvip,"")&& strcmp(cfgfile,""))
					{
						if(!chdir("/tmp"))/* 0: Success -1: Failure */
						{				
							eval("tftp", "-g", "-l", configfile, "-r", cfgfile, tftpsrvip);
							eval("nvram", "restore", configfile);
							nmp_commit();
							kill(1, SIGTERM);
						}
					}
					else
						return SNMP_ERR_GENERR;
					break;
				
				case 2:/* put */
					memset(tmpstr,0,SPRINT_MAX_LEN);
					nmp_commit();
					if(!strcmp(cfgfile,""))
						strcpy(cfgfile, defcfgfile);
					else if(!strchr(cfgfile,'.'))
					{
						sprintf(tmpstr,"%s.%s",cfgfile,"CFG");
						strcpy(cfgfile, tmpstr);
					}	
					if( strcmp(tftpsrvip,""))
					{
						if(!chdir("/tmp"))/* 0: Success -1: Failure */
						{				
							eval("nvram", "save", configfile);
							eval("tftp", "-p", "-l", configfile, "-r", cfgfile, tftpsrvip);
						}	
					}
					else
						return SNMP_ERR_GENERR;
					break;	

				case 3:/* do nothing */
					break;
			}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snmpEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 2)//no
            	value = 0;
            nmp_set_int("snmpd_enable", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snSystemName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 255) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			strncpy(tmpstr, (u_char *)var_val, var_val_len); 
			tmpstr[var_val_len]='\0';
			nmp_set("sysName", tmpstr);         
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snLocation(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 255) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if(var_val_len <= 255){
			strncpy(tmpstr, (u_char *)var_val, var_val_len); 
			tmpstr[var_val_len]='\0';
			nmp_set("sysLocation", tmpstr);         
		}	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snContact(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 255) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if(var_val_len <= 255){
			strncpy(tmpstr, (u_char *)var_val, var_val_len); 
			tmpstr[var_val_len]='\0';
			nmp_set("sysContact", tmpstr);	         
		}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snGetCommunity(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			strncpy(tmpstr, (u_char *)var_val, var_val_len); 
			tmpstr[var_val_len]='\0';
			nmp_set("roCommunity", tmpstr);  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_snSetCommunity(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
		tmpstr[var_val_len]='\0';         
		nmp_set("rwCommunity", tmpstr);	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_authProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3) {
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          } 
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if ( value >= 1 && value <= 3 )
			nmp_set("v3_auth_type", (value == 1 ? "NONE": (value == 2 ? "MD5": "SHA")));
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_authPass(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 8 || var_val_len > 64) {
              fprintf(stderr, "write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if( var_val_len >= 8 || var_val_len <= 64 ){ 
			strncpy(tmpstr, (u_char *)var_val, var_val_len); 
			tmpstr[var_val_len]='\0';
			nmp_set("v3_auth_passwd", tmpstr);       
		}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_privProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          } 
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if ( value >= 1 && value <= 3 )	
		  	nmp_set("v3_priv_type", (value == 1? "NONE": (value == 2? "DES": "AES")));
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_privPass(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to administration not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 8 || var_val_len > 64) {
              fprintf(stderr, "write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if( var_val_len >= 8 || var_val_len <= 64 ){ 
			strncpy(tmpstr, (u_char *)var_val, var_val_len); 
			tmpstr[var_val_len]='\0';
			nmp_set("v3_priv_passwd", tmpstr);       
		}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_systemCommand(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 21){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          } 
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		switch(value)
		{
			case 1: /* commit */
				nmp_commit();
				break;
#if 0
			case 2: /* reboot */				
			case 3:	/* factory default */
			case 4:	/* restart wireless */
			case 5:	/* restart net and phy */
			case 6: /* restart net */
			case 7: /* restart wan if */
			case 8: /* restart firewall */
			case 9:	/* restart ddns */
			case 10:/* restart pppoe relay */
			case 11:/* restart allnet */
			case 12:/* restart pptpd */
			case 13:/* restart all */
			case 14:/* restart time */
			case 15:/* restart qos */
#endif
			case 2 ... 20:
				nmp_notify_rc(syscmd[value-1]);
				break;
			case 21: /* nothing */
				break;	
		}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_mClientListClient(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    static struct in_addr addr;
    char http_clientlist[MAXHTTPCLIENT][HTTPCLIENTSTRNUM];
    int i, http_clientlist_count = 0;
    char *nv, *nvp, *b;
    char clientStr[20];

    for(i = 0; i < MAXHTTPCLIENT; i++)
    	memset(http_clientlist[i], 0x0, HTTPCLIENTSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of http_clientlist
    nv = nvp = strdup(nmp_safe_get("http_clientlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(http_clientlist[http_clientlist_count], b);
		http_clientlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to administration not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
         	memset(clientStr, 0, sizeof(clientStr));
             	tmpval_u = *(u_long *)var_val;
             	addr.s_addr = tmpval_u;
             	strcpy(clientStr, (char *)inet_ntoa(addr)); 

		if((index+1) > http_clientlist_count)
			real_index = http_clientlist_count;
		else
			real_index = index;
	
		strcpy(http_clientlist[real_index], clientStr);
             	
		//Re-generate http_clientlist
		for(i = 0; i < MAXHTTPCLIENT; i++)
		{
			char entry_str[HTTPCLIENTSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(http_clientlist[i][0]) {
				sprintf(entry_str, "<%s", http_clientlist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("http_clientlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_mClientListDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char http_clientlist[MAXHTTPCLIENT][HTTPCLIENTSTRNUM];
    int i, http_clientlist_count = 0;
    char *nv, *nvp, *b;
    char clientStr[20];

    for(i = 0; i < MAXHTTPCLIENT; i++)
    	memset(http_clientlist[i], 0x0, HTTPCLIENTSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] -1;

    //Compute the number of http_clientlist
    nv = nvp = strdup(nmp_safe_get("http_clientlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(http_clientlist[http_clientlist_count], b);
		http_clientlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to administration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to administration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to administration: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < http_clientlist_count)
             {
        	memset(http_clientlist[index], 0x0, HTTPCLIENTSTRNUM);

		//Re-generate http_clientlist
		for(i = 0; i < MAXHTTPCLIENT; i++)
		{
			char entry_str[HTTPCLIENTSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(http_clientlist[i][0]) {
				sprintf(entry_str, "<%s", http_clientlist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("http_clientlist", tmpstr);
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

