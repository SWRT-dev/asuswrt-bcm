/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "vpn.h"
#include <nmp.h>

#define MAXVPNCLIENT  16
#define VPNCLIENTSTRNUM 64
#define MAXVPNSERVER  10
#define VPNSERVERSTRNUM 512
#define LENGTH128     128
#define configfile   "client.ovpn" 
#define VPN_CLIENT_UPLOAD  "/tmp/openvpn_file"
static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0, importFileType = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;
static unsigned char tftpsrvip[39], ovpn_tftpsrvip[39], filename[LENGTH128];//'tftpsrvip' is used to store tftp server ip of oVPNCfgFileTftpSrv
                                                       //'ovpn_tftpsrvip' is used to store tftp server ip of openVPNTftpSrv

/* 
 * vpn_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid vpn_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,6 };

/* 
 * variable4 vpn_variables:
 *   this variable defines function callbacks and type return information 
 *   for the vpn mib section 
 */

struct variable7 vpn_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define ENABLEVPNSERVER		1
{ENABLEVPNSERVER,  ASN_INTEGER,  RWRITE,  var_vpn, 4,  { 1,1,1,1 }},
#define VPNSERVERMODE		2
{VPNSERVERMODE,  ASN_INTEGER,  RWRITE,  var_vpn, 4,  { 1,1,1,2 }},
#define SAMBASUPPORT		3
{SAMBASUPPORT,  ASN_INTEGER,  RWRITE,  var_vpn, 4,  { 1,1,1,3 }},
#define OVPNCFGFILETFTPSRV		4
{OVPNCFGFILETFTPSRV,  ASN_OCTET_STR,  RWRITE,  var_vpn, 5,  { 1,1,1,4,1 }},
#define OVPNCFGFILEEXPORT		5
{OVPNCFGFILEEXPORT,  ASN_INTEGER,  RWRITE,  var_vpn, 5,  { 1,1,1,4,2 }},
#define VBROADCASTSUPPORT		6
{VBROADCASTSUPPORT,  ASN_INTEGER,  RWRITE,  var_vpn, 3,  { 1,2,1 }},
#define VAUTHENTICATION		7
{VAUTHENTICATION,  ASN_INTEGER,  RWRITE,  var_vpn, 3,  { 1,2,2 }},
#define VMPPEENCRYPTION		8
{VMPPEENCRYPTION,  ASN_OCTET_STR,  RWRITE,  var_vpn, 3,  { 1,2,3 }},
#define VCONNECTTODNSSERVERAUTO		9
{VCONNECTTODNSSERVERAUTO,  ASN_INTEGER,  RWRITE,  var_vpn, 3,  { 1,2,4 }},
#define VDNSSERVER1		10
{VDNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_vpn, 3,  { 1,2,5 }},
#define VDNSSERVER2		11
{VDNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_vpn, 3,  { 1,2,6 }},
#define VCONNECTTOWINSSERVERAUTO		12
{VCONNECTTOWINSSERVERAUTO,  ASN_INTEGER,  RWRITE,  var_vpn, 3,  { 1,2,7 }},
#define VWINSSERVER1		13
{VWINSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_vpn, 3,  { 1,2,8 }},
#define VWINSSERVER2		14
{VWINSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_vpn, 3,  { 1,2,9 }},
#define VMRU		15
{VMRU,  ASN_INTEGER,  RWRITE,  var_vpn, 3,  { 1,2,10 }},
#define VMTU		16
{VMTU,  ASN_INTEGER,  RWRITE,  var_vpn, 3,  { 1,2,11 }},
#define VCLIENTSTARTIPADDRESS		17
{VCLIENTSTARTIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_vpn, 3,  { 1,2,12 }},
#define VCLIENTENDIPADDRESS		18
{VCLIENTENDIPADDRESS,  ASN_INTEGER,  RWRITE,  var_vpn, 3,  { 1,2,13 }},
#define OPENVPNTFTPSRV		19
{OPENVPNTFTPSRV,  ASN_OCTET_STR,  RWRITE,  var_vpn, 4,  { 2,2,1,1 }},
#define OPENVPNFILETYPE		20
{OPENVPNFILETYPE,  ASN_INTEGER,  RWRITE,  var_vpn, 4,  { 2,2,1,2 }},
#define OPENVPNFILENAME		21
{OPENVPNFILENAME,  ASN_OCTET_STR,  RWRITE,  var_vpn, 4,  { 2,2,1,3 }},
#define OPENVPNFILEIMPORT		22
{OPENVPNFILEIMPORT,  ASN_INTEGER,  RWRITE,  var_vpn, 4,  { 2,2,1,4 }},
#define OPENVPNCERTAUTH		23
{OPENVPNCERTAUTH,  ASN_OCTET_STR,  RWRITE,  var_vpn, 4,  { 2,2,2,1 }},
#define OPENVPNCLIENTCERT		24
{OPENVPNCLIENTCERT,  ASN_OCTET_STR,  RWRITE,  var_vpn, 4,  { 2,2,2,2 }},
#define OPENVPNCLIENTKEY		25
{OPENVPNCLIENTKEY,  ASN_OCTET_STR,  RWRITE,  var_vpn, 4,  { 2,2,2,3 }},
#define OPENVPNSTATICKEY		26
{OPENVPNSTATICKEY,  ASN_OCTET_STR,  RWRITE,  var_vpn, 4,  { 2,2,2,4 }},

#define VPNUSERINDEX		27
{VPNUSERINDEX,  ASN_INTEGER,  RONLY,   var_vpnUserTable, 6,  { 1,1,2,1, 1, 1 }},
#define VPNUSERUSERNAME		28
{VPNUSERUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_vpnUserTable, 6,  { 1,1,2,1, 1, 2 }},
#define VPNUSERPASSWORD		29
{VPNUSERPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_vpnUserTable, 6,  { 1,1,2,1, 1, 3 }},
#define VPNCONNECTIONSTATUS		30
{VPNCONNECTIONSTATUS,  ASN_INTEGER,  RONLY,  var_vpnUserTable, 6,  { 1,1,2,1, 1, 4 }},
#define VPNIP		31
{VPNIP,  ASN_OCTET_STR,  RONLY,   var_vpnUserTable, 6,  { 1,1,2,1, 1, 5 }},
#define VPNREMOTEIP		32
{VPNREMOTEIP,  ASN_OCTET_STR,  RONLY,   var_vpnUserTable, 6,  { 1,1,2,1, 1, 6 }},
#define VPNUSERDELENTRY		33
{VPNUSERDELENTRY,  ASN_INTEGER,  RWRITE,  var_vpnUserTable, 6,  { 1,1,2,1, 1, 7 }},
#define VPNSERVERINDEX		34
{VPNSERVERINDEX,  ASN_INTEGER,  RONLY,   var_vpnServerTable, 4,  { 2,1, 1, 1 }},
#define VPNSERVERDESC		35
{VPNSERVERDESC,  ASN_OCTET_STR,  RWRITE,  var_vpnServerTable, 4,  { 2,1, 1, 2 }},
#define VPNSERVERTYPE		36
{VPNSERVERTYPE,  ASN_INTEGER,  RWRITE,  var_vpnServerTable, 4,  { 2,1, 1, 3 }},
#define VPNSERVERIP		37
{VPNSERVERIP,  ASN_OCTET_STR,  RWRITE,  var_vpnServerTable, 4,  { 2,1, 1, 4 }},
#define VPNSERVERUSERNAME		38
{VPNSERVERUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_vpnServerTable, 4,  { 2,1, 1, 5 }},
#define VPNSERVERPWD		39
{VPNSERVERPWD,  ASN_OCTET_STR,  RWRITE,  var_vpnServerTable, 4,  { 2,1, 1, 6 }},
#define VPNSERVERCONNECTIONSTATUS		40
{VPNSERVERCONNECTIONSTATUS,  ASN_INTEGER,  RONLY,  var_vpnServerTable, 4,  { 2,1, 1, 7 }},
#define VPNSERVERDELENTRY		41
{VPNSERVERDELENTRY,  ASN_INTEGER,  RWRITE,  var_vpnServerTable, 4,  { 2,1, 1, 8 }},
#define VPNSERVERCONNECT		42
{VPNSERVERCONNECT,  ASN_INTEGER,  RWRITE,  var_vpnServerTable, 4,  { 2,1, 1, 9 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the vpn module */
void
init_vpn(void)
{

    DEBUGMSGTL(("vpn", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vpn", vpn_variables, variable7,
               vpn_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");    
}

/*
 * var_vpn():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_vpn(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static unsigned char string[SPRINT_MAX_LEN];
    char *startIP, *endIP, *unit;    
    char nv[32] = {0};         

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)  //Doesn't support in AP and repeater mode
        return NULL;
    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
        return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case ENABLEVPNSERVER:
        *write_method = write_enableVPNServer;
        if(nmp_safe_get("VPNServer_enable") != NULL)
        {        
            tmpval = nmp_get_int("VPNServer_enable");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case VPNSERVERMODE:
        *write_method = write_vpnServerMode;
        if(nmp_safe_get("VPNServer_mode") != NULL)
        {        
            if(!strcmp(nmp_get("VPNServer_mode"), "pptpd"))
                tmpval = 1;
            else if(!strcmp(nmp_get("VPNServer_mode"), "openvpn"))
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case SAMBASUPPORT:
        *write_method = write_sambaSupport;
        if(nmp_safe_get("pptpd_broadcast") != NULL)
        {        
            if(!strcmp(nmp_get("pptpd_broadcast"), "disable"))//no
                tmpval = 2; 
            else if(!strcmp(nmp_get("pptpd_broadcast"), "ppp"))//yes
                tmpval = 1; 
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case OVPNCFGFILETFTPSRV:
        *write_method = write_oVPNCfgFileTftpSrv;
        if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))
        {   
            *var_len = strlen(tftpsrvip);
            return ( u_char * ) tftpsrvip;
        }
        return NULL;
    case OVPNCFGFILEEXPORT:
        *write_method = write_oVPNCfgFileExport;
        if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))
        {                       
            tmpval = 2; /* 1: export   2:nothing*/
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;    
        }
        return NULL;
    case VBROADCASTSUPPORT:
        *write_method = write_vbroadcastSupport;
        if(nmp_safe_get("pptpd_broadcast") != NULL)
        {
            if(!strcmp(nmp_get("pptpd_broadcast"), "disable")) /* disable */
                tmpval = 1;
            else if(!strcmp(nmp_get("pptpd_broadcast"), "br0")) /* lan-to-vpn-client */
                tmpval = 2;
            else if(!strcmp(nmp_get("pptpd_broadcast"), "ppp")) /* vpn-client-to-lan */
                tmpval = 3;
            else if(!strcmp(nmp_get("pptpd_broadcast"), "br0ppp")) /* both */
                tmpval = 4;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        } 
        return NULL;
    case VAUTHENTICATION:
        *write_method = write_vAuthentication;
        {
            tmpval = nmp_get_int("pptpd_chap");
            if(tmpval == 0) /* auto */
                tmpval = 1;
            else if(tmpval == 1) /* ms-chapv1 */
                tmpval = 2;
            else if(tmpval == 2) /* ms-chapv2 */
                tmpval = 3;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case VMPPEENCRYPTION:
        *write_method = write_vmppeEncryption;
        if(nmp_safe_get("pptpd_mppe") != NULL)
        {
            tmpval = 0;
            if(nmp_get_int("pptpd_mppe") & 1) tmpval += (1 << 7);
            if(nmp_get_int("pptpd_mppe") & (1<<2)) tmpval += (1 << 6);
            if(nmp_get_int("pptpd_mppe") & (1<<3)) tmpval += (1 << 5);
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }           
        return NULL;
    case VCONNECTTODNSSERVERAUTO:
        *write_method = write_vconnectToDNSServerAuto;
        if(strlen(nmp_safe_get("pptpd_dns1")) || strlen(nmp_safe_get("pptpd_dns2")))
            tmpval = 2;
        else
            tmpval = 1;
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case VDNSSERVER1:
        *write_method = write_vDNSServer1;
        if(nmp_safe_get("pptpd_dns1") != NULL)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get("pptpd_dns1"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case VDNSSERVER2:
        *write_method = write_vDNSServer2;
        if(nmp_safe_get("pptpd_dns2") != NULL)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get("pptpd_dns2"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case VCONNECTTOWINSSERVERAUTO:
        *write_method = write_vconnectToWINSServerAuto;
        if(strlen(nmp_safe_get("pptpd_wins1")) || strlen(nmp_safe_get("pptpd_wins2")))
            tmpval = 2;
        else
            tmpval = 1;
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case VWINSSERVER1:
        *write_method = write_vWINSServer1;
        if(nmp_safe_get("pptpd_wins1") != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get("pptpd_wins1"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case VWINSSERVER2:
        *write_method = write_vWINSServer2;
        if(nmp_safe_get("pptpd_wins2") != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get("pptpd_wins2"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case VMRU:
        *write_method = write_vMRU;
        if(nmp_safe_get("pptpd_mru") != NULL)
        {
            tmpval = nmp_get_int("pptpd_mru");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case VMTU:
        *write_method = write_vMTU;
        if(nmp_safe_get("pptpd_mtu") != NULL)
        {
            tmpval = nmp_get_int("pptpd_mtu");
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case VCLIENTSTARTIPADDRESS:
        *write_method = write_vclientStartIPAddress;
        if(nmp_safe_get("pptpd_clients") != NULL)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr, "%s", nmp_safe_get("pptpd_clients"));
            if(vstrsep(tmpstr, "-", &startIP, &endIP) != 2) return NULL;
            tmpval_u = inet_addr(startIP);
            *var_len = sizeof( unsigned long ); 
            return ( u_char * ) &tmpval_u;
        }
        return NULL;
    case VCLIENTENDIPADDRESS:
        *write_method = write_vclientEndIPAddress;
        if(nmp_safe_get("pptpd_clients") != NULL)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr, "%s", nmp_safe_get("pptpd_clients"));
            if(vstrsep(tmpstr, "-", &startIP, &endIP) != 2) return NULL;
            tmpval = atoi(endIP);
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case OPENVPNTFTPSRV:
        *write_method = write_openVPNTftpSrv;
        *var_len = strlen(ovpn_tftpsrvip);
        return ( u_char * ) ovpn_tftpsrvip;
    case OPENVPNFILETYPE:
        *write_method = write_openVPNFileType;
        *var_len = sizeof( long );
        return ( u_char * ) &importFileType;
    case OPENVPNFILENAME:
        *write_method = write_openVPNFileName;
        *var_len = strlen( filename );
        return ( u_char * ) filename; 
    case OPENVPNFILEIMPORT:
        *write_method = write_openVPNFileImport;
        tmpval = 2; /* nothing */
        *var_len = sizeof( long );
        return ( u_char * )&tmpval;
    case OPENVPNCERTAUTH:
        *write_method = write_openVPNCertAuth;
        unit = nvram_safe_get("vpn_client_unit");        
        sprintf(nv, "vpn_crt_client%s_ca", unit);        
        if(nmp_safe_get(nv) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get(nv));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case OPENVPNCLIENTCERT:
        *write_method = write_openVPNClientCert;
        unit = nvram_safe_get("vpn_client_unit");        
        sprintf(nv, "vpn_crt_client%s_crt", unit);           
        if(nmp_safe_get(nv) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get(nv));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case OPENVPNCLIENTKEY:
        *write_method = write_openVPNClientKey;
        unit = nvram_safe_get("vpn_client_unit");        
        sprintf(nv, "vpn_crt_client%s_key", unit);          
        if(nmp_safe_get(nv) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get(nv));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case OPENVPNSTATICKEY:
        *write_method = write_openVPNStaticKey;
        unit = nvram_safe_get("vpn_client_unit");        
        sprintf(nv, "vpn_crt_client%s_static", unit);            
        if(nmp_safe_get(nv) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get(nv));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_vpnUserTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_vpn above.
 */
unsigned char *
var_vpnUserTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char clientlist[MAXVPNCLIENT][VPNCLIENTSTRNUM];
    int i, clientlist_count = 0;
    char *nv, *nvp, *b, *username, *passwd;
    FILE *fp;    

    for(i = 0; i < MAXVPNCLIENT; i++)
        memset(clientlist[i], 0x0, VPNCLIENTSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of vpn client list
    if(!strcmp(nmp_safe_get("VPNServer_mode"), "pptpd"))
        nv = nvp = strdup(nmp_safe_get("pptpd_clientlist"));
    else if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))
        nv = nvp = strdup(nmp_safe_get("vpn_server_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(clientlist[clientlist_count], b);
            clientlist_count++;       
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXVPNCLIENT)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case VPNUSERINDEX:
        return NULL;
    case VPNUSERUSERNAME:
        *write_method = write_vpnUserUserName;
        index = name[*length-1]-1;
        if(index <= clientlist_count-1) {
            if (strlen(clientlist[index])) {
                if(vstrsep(clientlist[index], ">", &username, &passwd) != 2) break;
                strcpy(tmpstr, username);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case VPNUSERPASSWORD:
        *write_method = write_vpnUserPassword;
        index = name[*length-1]-1;
        if(index <= clientlist_count-1) {
            if (strlen(clientlist[index])) {
                if(vstrsep(clientlist[index], ">", &username, &passwd) != 2) break;
                strcpy(tmpstr, passwd);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;        
    case VPNCONNECTIONSTATUS:
        index = name[*length-1]-1;
        if(index <= clientlist_count-1) {
            char *id, *iface, *vpnIp, *remoteIp, *username, *passwd, *conUser;       
            char str[SPRINT_MAX_LEN];    

            memset(str, 0x0, SPRINT_MAX_LEN);                  
            if (strlen(clientlist[index])) {
                if(vstrsep(clientlist[index], ">", &username, &passwd) != 2) break;
                if(strlen(username))
                {
                    tmpval = 2;
                    fp = fopen("/tmp/pptp_connected", "r");
                    if (fp != NULL)
                    {
                        while (fgets(str, SPRINT_MAX_LEN, fp)!=NULL)
                        {                                                  
                            if(str[strlen(str)-1] == '\n')
                                str[strlen(str)-1] = '\0';

                            if((vstrsep(str, " ", &id, &iface, &vpnIp, &remoteIp, &conUser) != 5)) break;                            
                            if(!strcmp(username, conUser))
                            {    
                                tmpval = 1;                               
                                break;
                            }
                        }            
                        fclose(fp);
                    }
                    *var_len = sizeof( long );
                    return ( u_char * ) &tmpval;  
                }                                     
            }       
        }
        return NULL;
    case VPNIP:
        index = name[*length-1]-1;
        if(index <= clientlist_count-1) {
            char *id, *iface, *vpnIp, *remoteIp, *username, *passwd, *conUser;       
            char str[SPRINT_MAX_LEN];    

            memset(str, 0x0, SPRINT_MAX_LEN); 
            if (strlen(clientlist[index])) {
                if(vstrsep(clientlist[index], ">", &username, &passwd) != 2) break;
                if(strlen(username))
                {
                    tmpval = 2;
                    fp = fopen("/tmp/pptp_connected", "r");
                    if (fp != NULL)
                    {
                        while (fgets(str, SPRINT_MAX_LEN, fp)!=NULL)
                        {
                            if(str[strlen(str)-1] == '\n')
                                str[strlen(str)-1] = '\0';

                            if((vstrsep(str, " ", &id, &iface, &vpnIp, &remoteIp, &conUser) != 5)) break;
                            if(!strcmp(username, conUser))
                            {    
                                sprintf(tmpstr, "%s", vpnIp);
                                break;
                            }
                        }            
                        fclose(fp);
                    }
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr;   
                }                                     
            }       
        }
        return NULL;
    case VPNREMOTEIP:
        index = name[*length-1]-1;
        if(index <= clientlist_count-1) {
            char *id, *iface, *vpnIp, *remoteIp, *username, *passwd, *conUser;       
            char str[SPRINT_MAX_LEN];    

            memset(str, 0x0, SPRINT_MAX_LEN); 
            if (strlen(clientlist[index])) {
                if(vstrsep(clientlist[index], ">", &username, &passwd) != 2) break;
                if(strlen(username))
                {
                    tmpval = 2;
                    fp = fopen("/tmp/pptp_connected", "r");
                    if (fp != NULL)
                    {
                        while (fgets(str, SPRINT_MAX_LEN, fp)!=NULL)
                        {
                            if(str[strlen(str)-1] == '\n')
                                str[strlen(str)-1] = '\0';

                            if(vstrsep(str, " ", &id, &iface, &vpnIp, &remoteIp, &conUser) != 5) break;
                            if(!strcmp(username, conUser))
                            {    
                                sprintf(tmpstr, "%s", remoteIp);                              
                                break;
                            }
                        }            
                        fclose(fp);
                    }
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr;   
                }                                     
            }       
        }
        return NULL;
    case VPNUSERDELENTRY:
        *write_method = write_vpnUserDelEntry;
        tmpval = 2; /* no */
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_vpnServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_vpn above.
 */
unsigned char *
var_vpnServerTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0;
    char *nv, *nvp, *b, *desc, *proto, *ip, *username, *passwd; 

    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXVPNSERVER)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case VPNSERVERINDEX:
        return NULL;
    case VPNSERVERDESC:
        *write_method = write_vpnServerDesc;
        index = name[*length-1]-1;
        if(index <= serverlist_count-1) {
            if (strlen(serverlist[index])) {
                if(vstrsep(serverlist[index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                strcpy(tmpstr, desc);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case VPNSERVERTYPE:
        *write_method = write_vpnServerType;
        tmpval = 0;        
        index = name[*length-1]-1;
        if(index <= serverlist_count-1) {
            if (strlen(serverlist[index])) {
                if(vstrsep(serverlist[index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                if(!strcmp(proto, "PPTP"))
                    tmpval = 1;
                else if(!strcmp(proto, "L2TP"))
                    tmpval = 2;   
                else if(!strcmp(proto, "OpenVPN"))
                    tmpval = 3;   
            }
        }
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;  
    case VPNSERVERIP:
        *write_method = write_vpnServerIP;
        index = name[*length-1]-1;        
        if(index <= serverlist_count-1) {
            if (strlen(serverlist[index])) {
                if(vstrsep(serverlist[index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                if(!strcmp(proto, "PPTP") || !strcmp(proto, "L2TP"))
                    strcpy(tmpstr, ip);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case VPNSERVERUSERNAME:
        *write_method = write_vpnServerUsername;
        index = name[*length-1]-1;        
        if(index <= serverlist_count-1) {
            if (strlen(serverlist[index])) {
                if(vstrsep(serverlist[index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                strcpy(tmpstr, username);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case VPNSERVERPWD:
        *write_method = write_vpnServerPwd;
        index = name[*length-1]-1;        
        if(index <= serverlist_count-1) {
            if (strlen(serverlist[index])) {
                if(vstrsep(serverlist[index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                strcpy(tmpstr, passwd);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case VPNSERVERCONNECTIONSTATUS:
        index = name[*length-1]-1;   
        tmpval = 2;     
        if(index <= serverlist_count-1) {
            if (strlen(serverlist[index])) {
                if(vstrsep(serverlist[index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                if(!strcmp(proto, "OpenVPN")){
                    if(!strcmp(nmp_safe_get("vpnc_proto"), "openvpn")) {
                        char *unit = nvram_safe_get("vpn_client_unit");        
                        char nv[32] = {0};

                        sprintf(nv, "vpn_client%s_state", unit);
                        if(nmp_get_int(nv) == 2)
                            tmpval = 1;
                    }
                }
                else{
                    char protostr[8];

                    memset(protostr, 0x0, 8);
                    strcpy(protostr, proto);
                    for(i = 0; i < strlen(protostr); i++)
                        protostr[i] = tolower(protostr[i]);

                    if( !strcmp(protostr, nmp_safe_get("vpnc_proto")) && 
                        !strcmp(nmp_safe_get("vpnc_heartbeat_x"), ip) && 
                        !strcmp(nmp_safe_get("vpnc_pppoe_username"), username)){
                        if(nmp_get_int("vpnc_state_t") == 2)
                            tmpval = 1;
                    }
                }
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }            
        return NULL;
    case VPNSERVERDELENTRY:
        *write_method = write_vpnServerDelEntry;
        tmpval = 2; /* no */
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case VPNSERVERCONNECT:
        *write_method = write_vpnServerConnect;
        tmpval = 3; /* nothing */
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_enableVPNServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 1) {
              fprintf(stderr, "write to vpn: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }             
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int("VPNServer_enable", value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vpnServerMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf(stderr, "write to vpn: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }              
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if( value == 1 )
            {
                nmp_set("VPNServer_mode", "pptpd");
                nmp_set("pptpd_enable", "1");
            }                    
            else if( value == 2 )
            {
                nmp_set("VPNServer_mode", "openvpn");
                nmp_set("pptpd_enable", "0");               
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sambaSupport(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf(stderr, "write to vpn: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if( value == 1 )//yes
                nmp_set("pptpd_broadcast", "ppp");              
            else if( value == 2 )//no
                nmp_set("pptpd_broadcast", "disable");                   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_oVPNCfgFileTftpSrv(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    if(strcmp(nmp_get("VPNServer_mode"), "openvpn"))
        return SNMP_ERR_NOACCESS;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 0 || var_val_len > 39) {
              fprintf(stderr, "write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */            
                memset(tftpsrvip, 0, sizeof(tftpsrvip));
                strncpy(tftpsrvip, (u_char *)var_val, var_val_len);
                tftpsrvip[var_val_len] = '\0';         
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_oVPNCfgFileExport(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char dir[32];

    if(strcmp(nmp_get("VPNServer_mode"), "openvpn"))
        return SNMP_ERR_NOACCESS;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf ( stderr,"write to vpn: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)//export        
            {
                memset(tmpstr, 0x0, SPRINT_MAX_LEN);         
                sprintf(tmpstr, "vpn_server%s_state", nmp_safe_get("vpn_server_unit"));
                if(!strcmp(nmp_safe_get(tmpstr), "2"))
                {        
                    if(strcmp(tftpsrvip,""))
                    {
                        memset(dir, 0x0, 32);
                        sprintf(dir, "/tmp/etc/openvpn/server%s", nmp_safe_get("vpn_server_unit"));
                        if(!chdir(dir))/* 0: Success -1: Failure */            
                            eval("tftp", "-p", "-l", configfile, "-r", configfile, tftpsrvip);
                    }        
                }
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vbroadcastSupport(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 4) {
              fprintf(stderr, "write to vpn: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* disable */
                    nmp_set("pptpd_broadcast", "disable");
                    break;
                case 2:/* lan-to-vpn-client */
                    nmp_set("pptpd_broadcast", "br0");
                    break;
                case 3:/* vpn-client-to-lan */
                    nmp_set("pptpd_broadcast", "ppp");
                    break;
                case 4:/* both */
                    nmp_set("pptpd_broadcast", "br0ppp");
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vAuthentication(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3) {
              fprintf(stderr, "write to vpn: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* auto */
                    nmp_set("pptpd_chap", "0");
                    break;
                case 2:/* ms-chapv1 */
                    nmp_set("pptpd_chap", "1");
                    break;
                case 3:/* ms-chapv2 */
                    nmp_set("pptpd_chap", "2");
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vmppeEncryption(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int mppeEnc = 0;

    value = * (char *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              (value & (1 << 7)) ? mppeEnc += 1 : NULL;
              (value & (1 << 6)) ? mppeEnc += 4 : NULL;
              (value & (1 << 5)) ? mppeEnc += 8 : NULL;
              nmp_set_int("pptpd_mppe", mppeEnc);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vconnectToDNSServerAuto(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf(stderr, "write to vpn_server: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* auto */
                    nmp_set("pptpd_dns1", "");
                    nmp_set("pptpd_dns2", "");
                    break;
                case 2:/* manual */
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vDNSServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("pptpd_dns1", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vDNSServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("pptpd_dns2", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vconnectToWINSServerAuto(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf(stderr, "write to vpn_server: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* auto */
                    nmp_set("pptpd_wins1", "");
                    nmp_set("pptpd_wins2", "");
                    break;
                case 2:/* manual */
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vWINSServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("pptpd_wins1", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vWINSServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("pptpd_wins2", tmpstr);                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vMRU(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int("pptpd_mru", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vMTU(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int("pptpd_mtu", value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vclientStartIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;
    int ip[4];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to vpn not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             sscanf((char *)inet_ntoa(addr), "%d.%d.%d.%d", &ip[0], &ip[1], &ip[2], &ip[3]);
             if((ip[3]+9) > 255)
                sprintf(tmpstr, "%s-255", (char *)inet_ntoa(addr)); 
             else
                sprintf(tmpstr, "%s-%d", (char *)inet_ntoa(addr), ip[3]+9);
             nmp_set("pptpd_clients", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vclientEndIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char pptpClientStr[32];
    char *startIP, *endIP;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 255){
              fprintf ( stderr,"write to vpn: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             memset(pptpClientStr, 0, sizeof(pptpClientStr));
             sprintf(pptpClientStr, "%s", nmp_safe_get("pptpd_clients"));
             if(vstrsep(pptpClientStr, "-", &startIP, &endIP) != 2) break;
             sprintf(tmpstr, "%s-%d", startIP, value);
             nmp_set("pptpd_clients", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_openVPNTftpSrv(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 0 || var_val_len > 39) {
              fprintf(stderr, "write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(ovpn_tftpsrvip, 0x0, sizeof(ovpn_tftpsrvip));
            strncpy(ovpn_tftpsrvip, (u_char *)var_val, var_val_len);
            ovpn_tftpsrvip[var_val_len] = '\0';                      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_openVPNFileType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1|| *(long *)var_val > 5){
              fprintf ( stderr,"write to vpn: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              importFileType = value;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_openVPNFileName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 128) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(filename, 0x0, sizeof(filename));                  
            strncpy(filename, (u_char *)var_val, var_val_len);
            filename[var_val_len] = '\0';                           
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_openVPNFileImport(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    //int state;
    char *unit;
    char nv[32] = {0};          
 
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to vpn: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)//import        
            {           
                if(strcmp(ovpn_tftpsrvip,""))
                {    
                    unit = nmp_safe_get("vpn_client_unit");
                    eval("tftp", "-g", "-l", VPN_CLIENT_UPLOAD, "-r", filename, ovpn_tftpsrvip);
                    if(importFileType == 1) {//ovpn
                        reset_client_setting(atoi(unit));
                        read_config_file(VPN_CLIENT_UPLOAD, atoi(unit));
                    }
                    else if(importFileType == 2) {//Certificate Authority
                        sprintf(nv, "vpn_crt_client%s_ca", unit);
                        set_crt_parsed(nv, VPN_CLIENT_UPLOAD);
                    }
                    else if(importFileType == 3) {//Client Certificate
                        sprintf(nv, "vpn_crt_client%s_crt", unit);
                        set_crt_parsed(nv, VPN_CLIENT_UPLOAD);
                    }
                    else if(importFileType == 4) {//Client Key
                        sprintf(nv, "vpn_crt_client%s_key", unit);
                        set_crt_parsed(nv, VPN_CLIENT_UPLOAD);
                    }
                    else if(importFileType == 5) {//static key
                        sprintf(nv, "vpn_crt_client%s_static", unit);
                        set_crt_parsed(nv, VPN_CLIENT_UPLOAD);
                    }                                                    

                    unlink(VPN_CLIENT_UPLOAD);
                }
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_openVPNCertAuth(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char *unit;        
    char nv[32] = {0};    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            unit = nmp_safe_get("vpn_client_unit");
            sprintf(nv, "vpn_crt_client%s_ca", unit);
            nmp_set(nv, tmpstr);                  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_openVPNClientCert(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char *unit;        
    char nv[32] = {0};    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            unit = nmp_safe_get("vpn_client_unit");
            sprintf(nv, "vpn_crt_client%s_crt", unit);
            nmp_set(nv, tmpstr);                           
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_openVPNClientKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char *unit;        
    char nv[32] = {0};    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            unit = nmp_safe_get("vpn_client_unit");
            sprintf(nv, "vpn_crt_client%s_key", unit);
            nmp_set(nv, tmpstr);                               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_openVPNStaticKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char *unit;        
    char nv[32] = {0};    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            unit = nvram_safe_get("vpn_client_unit");
            sprintf(nv, "vpn_crt_client%s_static", unit);
            nmp_set(nv, tmpstr);                  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_vpnUserUserName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char clientlist[MAXVPNCLIENT][VPNCLIENTSTRNUM];
    int i, clientlist_count = 0;
    char *nv, *nvp, *b, *username, *passwd;
    char usernamestr[40], string[VPNCLIENTSTRNUM];

    for(i = 0; i < MAXVPNCLIENT; i++)
        memset(clientlist[i], 0x0, VPNCLIENTSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;    

    //Compute the number of vpn client list
    if(!strcmp(nmp_safe_get("VPNServer_mode"), "pptpd"))
        nv = nvp = strdup(nmp_safe_get("pptpd_clientlist"));
    else if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))
        nv = nvp = strdup(nmp_safe_get("vpn_server_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(clientlist[clientlist_count], b);
            clientlist_count++;       
        }
        free(nv);
    }   

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(usernamestr, 0x0, 40);
            strncpy(usernamestr, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, VPNCLIENTSTRNUM);
            if((index+1) > clientlist_count)
                real_index = clientlist_count;
            else
                real_index = index;

            if(clientlist[real_index][0]) {
                if(vstrsep(clientlist[real_index], ">", &username, &passwd) != 2) break;
                sprintf(string, "%s>%s", usernamestr, passwd);
            }
            else
                sprintf(string, "%s>", usernamestr);  

            strcpy(clientlist[real_index], string);
                    
            //Re-generate vpn client list
            for(i = 0; i < MAXVPNCLIENT; i++)
            {
                char entry_str[VPNCLIENTSTRNUM];
                memset(entry_str, 0x0, VPNCLIENTSTRNUM);
                if(clientlist[i][0]) {
                    sprintf(entry_str, "<%s", clientlist[i]);
                    strcat(tmpstr, entry_str);
                }
            }

            if(!strcmp(nmp_safe_get("VPNServer_mode"), "pptpd"))
                nmp_set("pptpd_clientlist", tmpstr);
            else if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))
                nmp_set("vpn_server_clientlist", tmpstr);                      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_vpnUserPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char clientlist[MAXVPNCLIENT][VPNCLIENTSTRNUM];
    int i, clientlist_count = 0;
    char *nv, *nvp, *b, *username, *passwd;
    char password[32], string[VPNCLIENTSTRNUM];

    for(i = 0; i < MAXVPNCLIENT; i++)
        memset(clientlist[i], 0x0, VPNCLIENTSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;    

    //Compute the number of vpn client list
    if(!strcmp(nmp_safe_get("VPNServer_mode"), "pptpd"))
        nv = nvp = strdup(nmp_safe_get("pptpd_clientlist"));
    else if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))
        nv = nvp = strdup(nmp_safe_get("vpn_server_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(clientlist[clientlist_count], b);
            clientlist_count++;       
        }
        free(nv);
    }   

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 16) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(password, 0x0, 32);
            strncpy(password, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, VPNCLIENTSTRNUM);
            if((index+1) > clientlist_count)
                real_index = clientlist_count;
            else
                real_index = index;

            if(clientlist[real_index][0]) {
                if(vstrsep(clientlist[real_index], ">", &username, &passwd) != 2) break;
                sprintf(string, "%s>%s", username, password);
            }
            else
                sprintf(string, ">%s", password);  

            strcpy(clientlist[real_index], string);
                    
            //Re-generate vpn client list
            for(i = 0; i < MAXVPNCLIENT; i++)
            {
                char entry_str[VPNCLIENTSTRNUM];
                memset(entry_str, 0x0, VPNCLIENTSTRNUM);
                if(clientlist[i][0]) {
                    sprintf(entry_str, "<%s", clientlist[i]);
                    strcat(tmpstr, entry_str);
                }
            }

            if(!strcmp(nmp_safe_get("VPNServer_mode"), "pptpd"))
                nmp_set("pptpd_clientlist", tmpstr);
            else if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))
                nmp_set("vpn_server_clientlist", tmpstr);          
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vpnUserDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char clientlist[MAXVPNCLIENT][VPNCLIENTSTRNUM];
    int i, clientlist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXVPNCLIENT; i++)
        memset(clientlist[i], 0x0, VPNCLIENTSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] -1;    

    //Compute the number of vpn client list
    if(!strcmp(nmp_safe_get("VPNServer_mode"), "pptpd"))
        nv = nvp = strdup(nmp_safe_get("pptpd_clientlist"));
    else if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))
        nv = nvp = strdup(nmp_safe_get("vpn_server_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(clientlist[clientlist_count], b);
            clientlist_count++;       
        }
        free(nv);
    }    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to vpn: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < clientlist_count)
             {
                memset(clientlist[index], 0x0, VPNCLIENTSTRNUM);
    
                //Re-generate vpn client list
                for(i = 0; i < MAXVPNCLIENT; i++)
                {
                    char entry_str[VPNCLIENTSTRNUM];
                    memset(entry_str, 0x0, VPNCLIENTSTRNUM);
                    if(clientlist[i][0]) {
                        sprintf(entry_str, "<%s", clientlist[i]);
                        strcat(tmpstr, entry_str);
                    }
                }

                if(!strcmp(nmp_safe_get("VPNServer_mode"), "pptpd"))
                    nmp_set("pptpd_clientlist", tmpstr);
                else if(!strcmp(nmp_safe_get("VPNServer_mode"), "openvpn"))                
                    nmp_set("vpn_server_clientlist", tmpstr);
             }                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int check_openvpn_server()//-1: There is no OpenVPN profile   N: OpenVPN profile is in the index N.
{
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0;
    char *nv, *nvp, *b, *desc, *proto, *ip, *username, *passwd;      

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }    

    for(i = 0; i < serverlist_count; i++) {
        if(vstrsep(serverlist[i], ">", &desc, &proto, &ip, &username, &passwd) != 5) return -1;
        if(!strcmp(proto, "OpenVPN"))
            return i;
    }

    return -1;
}

int
write_vpnServerDesc(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0;
    char *nv, *nvp, *b, *desc, *proto, *ip, *username, *passwd;
    char descStr[128], string[VPNSERVERSTRNUM];
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;        

    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(descStr, 0x0, 128);
            strncpy(descStr, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, VPNSERVERSTRNUM);
            if((index+1) > serverlist_count)
                real_index = serverlist_count;
            else
                real_index = index; 
            
            if(serverlist[real_index][0]) {
                if(vstrsep(serverlist[real_index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", descStr, proto, ip, username, passwd);
            }
            else
                sprintf(string, "%s>>>>", descStr);  

            strcpy(serverlist[real_index], string);
                    
            //Re-generate vpn server list
            for(i = 0; i < MAXVPNSERVER; i++)
            {
                char entry_str[VPNSERVERSTRNUM];
                memset(entry_str, 0x0, VPNSERVERSTRNUM);
                if(serverlist[i][0]) {
                    if(i==0)
                        sprintf(entry_str, "%s", serverlist[i]);
                    else
                        sprintf(entry_str, "<%s", serverlist[i]);

                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("vpnc_clientlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vpnServerType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index, real_index;
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0, ovpn_idx = -1;
    char *nv, *nvp, *b, *desc, *proto, *ip, *username, *passwd;
    char typeStr[16], string[VPNSERVERSTRNUM];
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;   
    value = * (long *) var_val;

    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 3 ){
              fprintf ( stderr,"write to vpn: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(string, 0x0, VPNSERVERSTRNUM);
            if((index+1) > serverlist_count)
                real_index = serverlist_count;
            else
                real_index = index; 

            memset(typeStr, 0x0, 16);
            if( value == 1 )
                strcpy(typeStr, "PPTP");
            else if( value == 2 )
                strcpy(typeStr, "L2TP");
            else if( value == 3 ){              
                ovpn_idx = check_openvpn_server();                
                if( (ovpn_idx != -1) && (ovpn_idx != real_index))
                    return SNMP_ERR_WRONGVALUE;
                else
                    strcpy(typeStr, "OpenVPN");
            }              

            if(serverlist[real_index][0]) {
                if(vstrsep(serverlist[real_index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", desc, typeStr, ip, username, passwd);
            }
            else
                sprintf(string, ">%s>>>", typeStr);  

            strcpy(serverlist[real_index], string);
                    
            //Re-generate vpn server list
            for(i = 0; i < MAXVPNSERVER; i++)
            {
                char entry_str[VPNSERVERSTRNUM];
                memset(entry_str, 0x0, VPNSERVERSTRNUM);
                if(serverlist[i][0]) {
                    if(i==0)
                        sprintf(entry_str, "%s", serverlist[i]);
                    else
                        sprintf(entry_str, "<%s", serverlist[i]);

                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("vpnc_clientlist", tmpstr);            
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vpnServerIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0;
    char *nv, *nvp, *b, *desc, *proto, *ip, *username, *passwd;
    char ipstr[256], string[VPNSERVERSTRNUM];
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;   

    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 255) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(ipstr, 0x0, 256);      
            strncpy(ipstr, (u_char *)var_val, var_val_len);   

            memset(string, 0x0, VPNSERVERSTRNUM);
            if((index+1) > serverlist_count)
                real_index = serverlist_count;
            else
                real_index = index; 
            
            if(serverlist[real_index][0]) {
                if(vstrsep(serverlist[real_index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", desc, proto, ipstr, username, passwd);
            }
            else
                sprintf(string, ">>%s>>", ipstr);  

            strcpy(serverlist[real_index], string);
                    
            //Re-generate vpn server list
            for(i = 0; i < MAXVPNSERVER; i++)
            {
                char entry_str[VPNSERVERSTRNUM];
                memset(entry_str, 0x0, VPNSERVERSTRNUM);
                if(serverlist[i][0]) {
                    if(i==0)
                        sprintf(entry_str, "%s", serverlist[i]);
                    else
                        sprintf(entry_str, "<%s", serverlist[i]);

                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("vpnc_clientlist", tmpstr);      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vpnServerUsername(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0;
    char *nv, *nvp, *b, *desc, *proto, *ip, *username, *passwd;
    char usernamestr[128], string[VPNSERVERSTRNUM];
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;        

    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(usernamestr, 0x0, 128);
            strncpy(usernamestr, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, VPNSERVERSTRNUM);
            if((index+1) > serverlist_count)
                real_index = serverlist_count;
            else
                real_index = index; 
            
            if(serverlist[real_index][0]) {
                if(vstrsep(serverlist[real_index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", desc, proto, ip, usernamestr, passwd);
            }
            else
                sprintf(string, ">>>%s>", usernamestr);  

            strcpy(serverlist[real_index], string);
                    
            //Re-generate vpn server list
            for(i = 0; i < MAXVPNSERVER; i++)
            {
                char entry_str[VPNSERVERSTRNUM];
                memset(entry_str, 0x0, VPNSERVERSTRNUM);
                if(serverlist[i][0]) {
                    if(i==0)
                        sprintf(entry_str, "%s", serverlist[i]);
                    else
                        sprintf(entry_str, "<%s", serverlist[i]);

                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("vpnc_clientlist", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_vpnServerPwd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0;
    char *nv, *nvp, *b, *desc, *proto, *ip, *username, *passwd;
    char passwdstr[128], string[VPNSERVERSTRNUM];
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;        

    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to vpn not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(passwdstr, 0x0, 128);
            strncpy(passwdstr, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, VPNSERVERSTRNUM);
            if((index+1) > serverlist_count)
                real_index = serverlist_count;
            else
                real_index = index; 
            
            if(serverlist[real_index][0]) {
                if(vstrsep(serverlist[real_index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", desc, proto, ip, username, passwdstr);
            }
            else
                sprintf(string, ">>>>%s", passwdstr);  

            strcpy(serverlist[real_index], string);
                    
            //Re-generate vpn server list
            for(i = 0; i < MAXVPNSERVER; i++)
            {
                char entry_str[VPNSERVERSTRNUM];
                memset(entry_str, 0x0, VPNSERVERSTRNUM);
                if(serverlist[i][0]) {
                    if(i==0)
                        sprintf(entry_str, "%s", serverlist[i]);
                    else
                        sprintf(entry_str, "<%s", serverlist[i]);

                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("vpnc_clientlist", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vpnServerDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0;
    char *nv, *nvp, *b;

    index = name[name_len-1] -1;        
    value = * (long *) var_val;    

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to vpn: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1 && index < serverlist_count)
            {
                memset(serverlist[index], 0x0, VPNSERVERSTRNUM);              

                //Re-generate vpn server list
                for(i = 0; i < MAXVPNSERVER; i++)
                {
                    char entry_str[VPNSERVERSTRNUM];
                    memset(entry_str, 0x0, VPNSERVERSTRNUM);
                    if(serverlist[i][0]) {
                        if(i==0)
                            sprintf(entry_str, "%s", serverlist[i]);
                        else
                            sprintf(entry_str, "<%s", serverlist[i]);

                        strcat(tmpstr, entry_str);
                    }
                }

                nmp_set("vpnc_clientlist", tmpstr); 
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_vpnServerConnect(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char serverlist[MAXVPNSERVER][VPNSERVERSTRNUM];
    int i, serverlist_count = 0;
    char *nv, *nvp, *b, *desc, *proto, *ip, *username, *passwd;

    index = name[name_len-1] -1;        
    value = * (long *) var_val;    

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    for(i = 0; i < MAXVPNSERVER; i++)
        memset(serverlist[i], 0x0, VPNSERVERSTRNUM);

    //Compute the number of vpn server list
    nv = nvp = strdup(nmp_safe_get("vpnc_clientlist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(serverlist[serverlist_count], b);
            serverlist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to vpn not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to vpn: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 3 ){
              fprintf ( stderr,"write to vpn: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(serverlist[index][0]) {
                if(vstrsep(serverlist[index], ">", &desc, &proto, &ip, &username, &passwd) != 5) break;
                if( value == 1)//connect
                {
                    if(!strcmp(proto, "OpenVPN"))
                    {
                        nmp_set("vpnc_proto", "openvpn");
                        nmp_set("vpn_client_unit", ip);//ip is the value of client unit when the VPN type is OpenVPN.
                        sprintf(tmpstr, "vpn_client%s_username", ip);
                        nmp_set(tmpstr, username);
                        sprintf(tmpstr, "vpn_client%s_password", ip);
                        nmp_set(tmpstr, passwd);
                    }
                    else
                    {
                        if(!strcmp(proto, "PPTP"))
                             nmp_set("vpnc_proto", "pptp");
                        else if(!strcmp(proto, "L2TP"))
                             nmp_set("vpnc_proto", "l2tp");
                        nmp_set("vpnc_heartbeat_x", ip);
                        nmp_set("vpnc_pppoe_username", username);
                        nmp_set("vpnc_pppoe_passwd", passwd);
                    }
                    nmp_set("vpnc_dnsenable_x", "1");
                }
                else if( value ==2 )//disconnect
                {
                    nmp_set("vpnc_proto", "disable");
                    if(!strcmp(proto, "OpenVPN"))
                    {
                        nmp_set("vpn_client_unit", "");
                        sprintf(tmpstr, "vpn_client%s_username", ip);
                        nmp_set(tmpstr, "");
                        sprintf(tmpstr, "vpn_client%s_password", ip);
                        nmp_set(tmpstr, "");
                    }
                    else
                    {
                        nmp_set("vpnc_heartbeat_x", "");
                        nmp_set("vpnc_pppoe_username", "");
                        nmp_set("vpnc_pppoe_passwd", "");
                    }
                }
                nmp_notify_rc("restart_vpncall");                
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
