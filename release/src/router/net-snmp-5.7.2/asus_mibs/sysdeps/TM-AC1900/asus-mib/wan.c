/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "wan.h"
#include <nmp.h>

#define MACSTRNUM		18
#define MAXPORTTRIGGER		32
#define PORTTRIGGERSTRNUM	60
#define MAXPORTFORWARDING	32
#define PORTFORWARDINGSTRNUM	80
#define MAX_CLIENT_LIST		255
#define MAXROUTINGRULES		32
#define MAXROUTINGSTRNUM	64

//#define wan_prefix(unit, prefix)	snprintf(prefix, sizeof(prefix), "wan%d_", unit)

int wclient_count = 0;
client_list_info_t wclient_list[MAX_CLIENT_LIST];
static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;

char adpater_list[][64] = {"AUTO"
                            , "Samsung U200"
                            , "ASUS-T500"
                            , "BandLuxe-C120"
                            , "BandLuxe-C170"
                            , "BandLuxe-C339"
                            , "Huawei-E1550"
                            , "Huawei-E160G"
                            , "Huawei-E161"
                            , "Huawei-E169"
                            , "Huawei-E176"
                            , "Huawei-E220"
                            , "Huawei-K3520"
                            , "Huawei-ET128"
                            , "Huawei-E1800"
                            , "Huawei-K4505"
                            , "Huawei-E172"
                            , "Huawei-E372"
                            , "Huawei-E122"
                            , "Huawei-E160E"
                            , "Huawei-E1552"
                            , "Huawei-E173"
                            , "Huawei-E1823"
                            , "Huawei-E1762"
                            , "Huawei-E1750C"
                            , "Huawei-E1752Cu"
                            , "Alcatel-X200"
                            , "Alcatel-Oune-touch-X220S"
                            , "AnyData-ADU-510A"
                            , "AnyData-ADU-500A"
                            , "Onda-MT833UP"
                            , "Onda-MW833UP"
                            , "MTS-AC2746"
                            , "ZTE-AC5710"
                            , "ZTE-MU351"
                            , "ZTE-MF100"
                            , "ZTE-MF636"
                            , "ZTE-MF622"
                            , "ZTE-MF626"
                            , "ZTE-MF632"
                            , "ZTE-MF112"
                            , "ZTE-MFK3570-Z"
                            , "CS15"
                            , "CS17"
                            , "ICON401" };

/* 
 * wan_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid wan_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,4 };

/* 
 * variable7 wan_variables:
 *   this variable defines function callbacks and type return information 
 *   for the wan mib section 
 */

struct variable7 wan_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define WWANCONNECTIONTYPE		1
{WWANCONNECTIONTYPE,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,1,1 }},
#define WENABLEWAN		2
{WENABLEWAN,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,1,2 }},
#define WENABLENAT		3
{WENABLENAT,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,1,3 }},
#define WENABLEUPNP		4
{WENABLEUPNP,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,1,4 }},
#define WGETWANIPAUTO		5
{WGETWANIPAUTO,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,2,1 }},
#define WWIPADDRESS		6
{WWIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_wan, 4,  { 1,1,2,2 }},
#define WWSUBNETMASK		7
{WWSUBNETMASK,  ASN_IPADDRESS,  RWRITE,  var_wan, 4,  { 1,1,2,3 }},
#define WWDEFAULTGATEWAY		8
{WWDEFAULTGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_wan, 4,  { 1,1,2,4 }},
#define WCONNECTDNSSERVERAUTO		9
{WCONNECTDNSSERVERAUTO,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,3,1 }},
#define WDNSSERVER1		10
{WDNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,3,2 }},
#define WDNSSERVER2		11
{WDNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,3,3 }},
#define WAUTHENTICATION		12
{WAUTHENTICATION,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,4,1 }},
#define WUSERNAME		13
{WUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,4,2 }},
#define WPASSWORD		14
{WPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,4,3 }},
#define WIDLEDISCONNECTTIME		15
{WIDLEDISCONNECTTIME,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,4,4 }},
#define WMTU		16
{WMTU,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,4,5 }},
#define WMRU		17
{WMRU,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,4,6 }},
#define WSERVICENAME		18
{WSERVICENAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,4,7 }},
#define WACCESSCONCENTRATORNAME		19
{WACCESSCONCENTRATORNAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,4,8 }},
#define WPPTPOPTIONS		20
{WPPTPOPTIONS,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,4,9 }},
#define WADDITIONALPPPDOPTIONS		21
{WADDITIONALPPPDOPTIONS,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,4,10 }},
#define WVPNSERVER		22
{WVPNSERVER,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,5,1 }},
#define WENABLEVPNANDDHCPCONNECTION		23
{WENABLEVPNANDDHCPCONNECTION,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,5,2 }},
#define WHOSTNAME		24
{WHOSTNAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,5,3 }},
#define WMACADDRESS		25
{WMACADDRESS,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,1,5,4 }},
#define WDHCPQUERYFREQUENCY		26
{WDHCPQUERYFREQUENCY,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,1,5,5 }},
#define LWANCONNECTIONTYPE		27
{LWANCONNECTIONTYPE,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,1,1 }},
#define LENABLEWAN		28
{LENABLEWAN,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,1,2 }},
#define LENABLENAT		29
{LENABLENAT,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,1,3 }},
#define LENABLEUPNP		30
{LENABLEUPNP,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,1,4 }},
#define LGETWANIPAUTO		31
{LGETWANIPAUTO,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,2,1 }},
#define LWIPADDRESS		32
{LWIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_wan, 4,  { 1,2,2,2 }},
#define LWSUBNETMASK		33
{LWSUBNETMASK,  ASN_IPADDRESS,  RWRITE,  var_wan, 4,  { 1,2,2,3 }},
#define LWDEFAULTGATEWAY		34
{LWDEFAULTGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_wan, 4,  { 1,2,2,4 }},
#define LWCONNECTDNSSERVERAUTO		35
{LWCONNECTDNSSERVERAUTO,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,3,1 }},
#define LWDNSSERVER1		36
{LWDNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,3,2 }},
#define LWDNSSERVER2		37
{LWDNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,3,3 }},
#define LAUTHENTICATION		38
{LAUTHENTICATION,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,4,1 }},
#define LUSERNAME		39
{LUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,4,2 }},
#define LPASSWORD		40
{LPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,4,3 }},
#define LIDLEDISCONNECTTIME		41
{LIDLEDISCONNECTTIME,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,4,4 }},
#define LMTU		42
{LMTU,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,4,5 }},
#define LMRU		43
{LMRU,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,4,6 }},
#define LSERVICENAME		44
{LSERVICENAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,4,7 }},
#define LACCESSCONCENTRATORNAME		45
{LACCESSCONCENTRATORNAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,4,8 }},
#define LPPTPOPTIONS		46
{LPPTPOPTIONS,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,4,9 }},
#define LADDITIONALPPPDOPTIONS		47
{LADDITIONALPPPDOPTIONS,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,4,10 }},
#define LVPNSERVER		48
{LVPNSERVER,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,5,1 }},
#define LENABLEVPNANDDHCPCONNECTION		49
{LENABLEVPNANDDHCPCONNECTION,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,5,2 }},
#define LHOSTNAME		50
{LHOSTNAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,5,3 }},
#define LMACADDRESS		51
{LMACADDRESS,  ASN_OCTET_STR,  RWRITE,  var_wan, 4,  { 1,2,5,4 }},
#define LDHCPQUERYFREQUENCY		52
{LDHCPQUERYFREQUENCY,  ASN_INTEGER,  RWRITE,  var_wan, 4,  { 1,2,5,5 }},
#define UENABLEUSBMODEM		53
{UENABLEUSBMODEM,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 1,3,1 }},
#define UUSBMODEM		54
{UUSBMODEM,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 1,3,2 }},
#define UNETWORKTYPE		55
{UNETWORKTYPE,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 1,3,3 }},
#define UAPNSERVICE		56
{UAPNSERVICE,  ASN_OCTET_STR,  RWRITE,  var_wan, 3,  { 1,3,4 }},
#define UDIALNUMBER		57
{UDIALNUMBER,  ASN_OCTET_STR,  RWRITE,  var_wan, 3,  { 1,3,5 }},
#define UPINCODE		58
{UPINCODE,  ASN_OCTET_STR,  RWRITE,  var_wan, 3,  { 1,3,6 }},
#define UUSERNAME		59
{UUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 3,  { 1,3,7 }},
#define UPASSWORD		60
{UPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_wan, 3,  { 1,3,8 }},
#define UEMAIL		61
{UEMAIL,  ASN_OCTET_STR,  RWRITE,  var_wan, 3,  { 1,3,9 }},
#define UUSBADAPTER		62
{UUSBADAPTER,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 1,3,10 }},
#define DWPRIMARYWAN		63
{DWPRIMARYWAN,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,1,1 }},
#define DWPWLANPORT		64
{DWPWLANPORT,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,1,2 }},
#define DWSECONDARYWAN		65
{DWSECONDARYWAN,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,1,3 }},
#define DWSWLANPORT		66
{DWSWLANPORT,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,1,4 }},
#define DWDUALWANMODE		67
{DWDUALWANMODE,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,1,5 }},
#define DWLOADBALANCECFGPRI		68
{DWLOADBALANCECFGPRI,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,1,6 }},
#define DWLOADBALANCECFGSEC		69
{DWLOADBALANCECFGSEC,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,1,7 }},
#define DWALLOWFAILBACK		70
{DWALLOWFAILBACK,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,1,8 }},
#define DWPINGINTERVAL		71
{DWPINGINTERVAL,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,2,1 }},
#define DWPINGDELAY		72
{DWPINGDELAY,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,2,2 }},
#define DWPINGFAILCOUNT		73
{DWPINGFAILCOUNT,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,2,3 }},
#define DWPINGFBCOUNT		74
{DWPINGFBCOUNT,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,2,4 }},
#define DWPINGENABLEWATCHDOG		75
{DWPINGENABLEWATCHDOG,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,2,5 }},
#define DWPINGTARGET		76
{DWPINGTARGET,  ASN_OCTET_STR,  RWRITE,  var_wan, 3,  { 2,2,6 }},
#define DWENABLEROUTINGRULES		77
{DWENABLEROUTINGRULES,  ASN_INTEGER,  RWRITE,  var_wan, 3,  { 2,3,1 }},
#define ENABLEPORTTRIGGER		78
{ENABLEPORTTRIGGER,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 3,1 }},
#define ENABLEPORTFORWARDING		79
{ENABLEPORTFORWARDING,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 4,1 }},
#define FTPSERVERPORT		80
{FTPSERVERPORT,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 4,2 }},
#define WCLIENTLISTACT		81
{WCLIENTLISTACT,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 4,3 }},
#define ENABLEDMZ		82
{ENABLEDMZ,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 5,1 }},
#define EXPOSEDSTATIONIPADDR		83
{EXPOSEDSTATIONIPADDR,  ASN_OCTET_STR,  RWRITE,  var_wan, 2,  { 5,2 }},
#define ENABLEDDNSCLIENT		84
{ENABLEDDNSCLIENT,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 6,1 }},
#define DDNSSERVER		85
{DDNSSERVER,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 6,2 }},
#define DDNSHOSTNAME		86
{DDNSHOSTNAME,  ASN_OCTET_STR,  RWRITE,  var_wan, 2,  { 6,3 }},
#define DDNSUSERNAMEORMAIL		87
{DDNSUSERNAMEORMAIL,  ASN_OCTET_STR,  RWRITE,  var_wan, 2,  { 6,4 }},
#define DDNSPASSWORDORKEY		88
{DDNSPASSWORDORKEY,  ASN_OCTET_STR,  RWRITE,  var_wan, 2,  { 6,5 }},
#define ENABLEWILDCARD		89
{ENABLEWILDCARD,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 6,6 }},
#define PPTPPASSTHROUGH		90
{PPTPPASSTHROUGH,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 7,1 }},
#define L2TPPASSTHROUGH		91
{L2TPPASSTHROUGH,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 7,2 }},
#define IPSECPASSTHROUGH		92
{IPSECPASSTHROUGH,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 7,3 }},
#define RTSPPASSTHROUGH		93
{RTSPPASSTHROUGH,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 7,4 }},
#define H323PASSTHROUGH		94
{H323PASSTHROUGH,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 7,5 }},
#define SIPPASSTHROUGH		95
{SIPPASSTHROUGH,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 7,6 }},
#define PPPOERELAY		96
{PPPOERELAY,  ASN_INTEGER,  RWRITE,  var_wan, 2,  { 7,7 }},

#define DWROUTINGRULEINDEX		97
{DWROUTINGRULEINDEX,  ASN_INTEGER,  RONLY,   var_dwRoutingRulesTable, 5,  { 2,3,2, 1, 1 }},
#define DWSOURCEIP		98
{DWSOURCEIP,  ASN_IPADDRESS,  RWRITE,   var_dwRoutingRulesTable, 5,  { 2,3,2, 1, 2 }},
#define DWDESTINATIONIP		99
{DWDESTINATIONIP,  ASN_IPADDRESS,  RWRITE,   var_dwRoutingRulesTable, 5,  { 2,3,2, 1, 3 }},
#define DWWANUNIT		100
{DWWANUNIT,  ASN_INTEGER,  RWRITE,  var_dwRoutingRulesTable, 5,  { 2,3,2, 1, 4 }},
#define DWROUTINGRULEDELENTRY		101
{DWROUTINGRULEDELENTRY,  ASN_INTEGER,  RWRITE,  var_dwRoutingRulesTable, 5,  { 2,3,2, 1, 5 }},
#define PORTTRIGGERINDEX		102
{PORTTRIGGERINDEX,  ASN_INTEGER,  RONLY,   var_portTriggerTable, 4,  { 3,2, 1, 1 }},
#define PORTTRIGGERDESCRIPTION		103
{PORTTRIGGERDESCRIPTION,  ASN_OCTET_STR,  RWRITE,  var_portTriggerTable, 4,  { 3,2, 1, 2 }},
#define PORTTRIGGERPORT		104
{PORTTRIGGERPORT,  ASN_OCTET_STR,  RWRITE,  var_portTriggerTable, 4,  { 3,2, 1, 3 }},
#define PORTTRIGGERPROTOCOL		105
{PORTTRIGGERPROTOCOL,  ASN_INTEGER,  RWRITE,  var_portTriggerTable, 4,  { 3,2, 1, 4 }},
#define PORTTRIGGERINCOMINGPORT		106
{PORTTRIGGERINCOMINGPORT,  ASN_OCTET_STR,  RWRITE,  var_portTriggerTable, 4,  { 3,2, 1, 5 }},
#define PORTTRIGGERINCOMINGPROTOCOL		107
{PORTTRIGGERINCOMINGPROTOCOL,  ASN_INTEGER,  RWRITE,  var_portTriggerTable, 4,  { 3,2, 1, 6 }},
#define PORTTRIGGERDELENTRY		108
{PORTTRIGGERDELENTRY,  ASN_INTEGER,  RWRITE,  var_portTriggerTable, 4,  { 3,2, 1, 7 }},
#define WCLIENTINDEX		109
{WCLIENTINDEX,  ASN_INTEGER,  RONLY,   var_wClientTable, 4,  { 4,4, 1, 1 }},
#define WCLIENTIPADDR		110
{WCLIENTIPADDR,  ASN_IPADDRESS,  RONLY,   var_wClientTable, 4,  { 4,4, 1, 2 }},
#define WCLIENTNAME		111
{WCLIENTNAME,  ASN_OCTET_STR,  RONLY,   var_wClientTable, 4,  { 4,4, 1, 3 }},
#define PORTFORWARDINGINDEX		112
{PORTFORWARDINGINDEX,  ASN_INTEGER,  RONLY,   var_portForwardingTable, 4,  { 4,5, 1, 1 }},
#define PORTFORWARDINGSERVICENAME		113
{PORTFORWARDINGSERVICENAME,  ASN_OCTET_STR,  RWRITE,  var_portForwardingTable, 4,  { 4,5, 1, 2 }},
#define PORTFORWARDINGPORTRANGE		114
{PORTFORWARDINGPORTRANGE,  ASN_OCTET_STR,  RWRITE,  var_portForwardingTable, 4,  { 4,5, 1, 3 }},
#define PORTFORWARDINGLOCALIP		115
{PORTFORWARDINGLOCALIP,  ASN_IPADDRESS,  RWRITE,  var_portForwardingTable, 4,  { 4,5, 1, 4 }},
#define PORTFORWARDINGLOCALPORT		116
{PORTFORWARDINGLOCALPORT,  ASN_INTEGER,  RWRITE,  var_portForwardingTable, 4,  { 4,5, 1, 5 }},
#define PORTFORWARDINGPROTOCOL		117
{PORTFORWARDINGPROTOCOL,  ASN_INTEGER,  RWRITE,  var_portForwardingTable, 4,  { 4,5, 1, 6 }},
#define PORTFORWARDINGDELENTRY		118
{PORTFORWARDINGDELENTRY,  ASN_INTEGER,  RWRITE,  var_portForwardingTable, 4,  { 4,5, 1, 7 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the wan module */
void
init_wan(void)
{

    DEBUGMSGTL(("wan", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("wan", wan_variables, variable7,
               wan_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_wan():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_wan(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    char macstr[MACSTRNUM], varstr[32];
    char *priWan, *secWan;
    int wwan_unit = -1, lwan_unit = -1;

    if(sw_mode == SW_MODE_AP)	//Doesn't support in AP mode
	return NULL;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wwan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wwan_unit = 1;

    if(!strcmp(priWan, "lan"))
        lwan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        lwan_unit = 1;


    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WWANCONNECTIONTYPE:
        *write_method = write_wwanConnectionType;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "proto")) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            sprintf(tmpstr, nmp_safe_get(varstr));
            if(!strcmp(tmpstr, "dhcp")) /* dhcp */
                tmpval = 1;
            else if(!strcmp(tmpstr, "pppoe")) /* pppoe */
                tmpval = 2;
            else if(!strcmp(tmpstr, "static")) /* static */
                tmpval = 3;
            else if(!strcmp(tmpstr, "pptp")) /* pptp */
                tmpval = 4;
            else if(!strcmp(tmpstr, "l2tp")) /* l2tp */
                tmpval = 5;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
      	}	
        return NULL;

    case WENABLEWAN:
        *write_method = write_wenableWAN;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "enable")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* enable */
                tmpval = 1;
            else if(tmpval == 0) /* disable */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case WENABLENAT:
        *write_method = write_wenableNAT;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "nat_x")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* enable */
                tmpval = 1;
            else if(tmpval == 0) /* disable */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case WENABLEUPNP:
        *write_method = write_wenableUPnP;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "upnp_enable")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* enable */
                tmpval = 1;
            else if(tmpval == 0) /* disable */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case WGETWANIPAUTO:
        *write_method = write_wgetWanIPAuto;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "dhcpenable_x")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case WWIPADDRESS:
        *write_method = write_wwIPAddress;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "ipaddr_x")) != NULL)
        {
            tmpval_u = inet_addr(nmp_safe_get(varstr));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;

    case WWSUBNETMASK:
        *write_method = write_wwSubnetMask;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "netmask_x")) != NULL)
        {
            tmpval_u = inet_addr(nmp_safe_get(varstr));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;

    case WWDEFAULTGATEWAY:
        *write_method = write_wwDefaultGateway;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;        
        if(nmp_safe_get(strcat(varstr, "gateway_x")) != NULL)
        {
            tmpval_u = inet_addr(nmp_safe_get(varstr));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;

    case WCONNECTDNSSERVERAUTO:
        *write_method = write_wconnectDNSServerAuto;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;           
        if(nmp_safe_get(strcat(varstr, "dnsenable_x")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case WDNSSERVER1:
        *write_method = write_wdnsServer1;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "dns1_x")) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WDNSSERVER2:
        *write_method = write_wdnsServer2;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "dns2_x")) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WAUTHENTICATION:
        *write_method = write_wAuthentication;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "auth_x")) != NULL)
        {
            if(!strcmp(nmp_get(varstr), "")) /* none */
                tmpval = 1;
            else if(!strcmp(nmp_get(varstr), "8021x-md5")) /* 802.1x md5 */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case WUSERNAME:
        *write_method = write_wUserName;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_username")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WPASSWORD:
        *write_method = write_wPassword;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_passwd")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WIDLEDISCONNECTTIME:
        *write_method = write_widleDisconnectTime;    
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;        
        if(nmp_safe_get(strcat(varstr, "pppoe_idletime")) != NULL)
      	{
            tmpval = nmp_get_int(varstr);
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
      	}
        return NULL;

    case WMTU:
        *write_method = write_wmtu;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "pppoe_mtu")) != NULL)
      	{
            tmpval = nmp_get_int(varstr);
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
      	}
        return NULL;

    case WMRU:
        *write_method = write_wmru;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "pppoe_mru")) != NULL)
      	{
            tmpval = nmp_get_int(varstr);
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
      	}
        return NULL;

    case WSERVICENAME:
        *write_method = write_wserviceName;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_service")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WACCESSCONCENTRATORNAME:
        *write_method = write_waccessConcentratorName;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_ac")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WPPTPOPTIONS:
        *write_method = write_wpptpOptions;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "pptp_options_x")) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            sprintf(tmpstr, nmp_safe_get(varstr));
            if(!strcmp(tmpstr, "")) /* auto */
                tmpval = 1;
            else if(!strcmp(tmpstr, "-mppc")) /* no encryption */
                tmpval = 2;
            else if(!strcmp(tmpstr, "+mppe-40")) /* mppe-40 */
                tmpval = 3;
            else if(!strcmp(tmpstr, "+mppe-128")) /* mppe-128 */
                tmpval = 4;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case WADDITIONALPPPDOPTIONS:
        *write_method = write_wadditionalPppdOptions;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_options_x")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WVPNSERVER:
        *write_method = write_wvpnServer;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "heartbeat_x")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WENABLEVPNANDDHCPCONNECTION:
        *write_method = write_wenableVPNandDHCPConnection;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "vpndhcp")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case WHOSTNAME:
        *write_method = write_wHostName;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "hostname")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;

    case WMACADDRESS:
        *write_method = write_wMacAddress;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);
	    memset(macstr, 0x0, sizeof(macstr));
	    if(nmp_safe_get(strcat(varstr, "hwaddr_x")) != NULL)
	    {
            strcpy(macstr, nmp_safe_get(varstr));
            ether_atoe(macstr, tmpstr);
            *var_len = 6;
            return ( u_char * )tmpstr;
        }
        return NULL;

    case WDHCPQUERYFREQUENCY:
        *write_method = write_wdhcpQueryFrequency;
        if(wwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(wwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get("dhcpc_mode") != NULL)
        {
            tmpval = nmp_get_int("dhcpc_mode");
            if(tmpval == 0) /* normal mode */
                tmpval = 1;
            else if(tmpval == 1) /* aggressive mode */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

case LWANCONNECTIONTYPE:
        *write_method = write_lwanConnectionType;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;                  
        if(nmp_safe_get(strcat(varstr, "proto")) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            sprintf(tmpstr, nmp_safe_get(varstr));
            if(!strcmp(tmpstr, "dhcp")) /* dhcp */
                tmpval = 1;
            else if(!strcmp(tmpstr, "pppoe")) /* pppoe */
                tmpval = 2;
            else if(!strcmp(tmpstr, "static")) /* static */
                tmpval = 3;
            else if(!strcmp(tmpstr, "pptp")) /* pptp */
                tmpval = 4;
            else if(!strcmp(tmpstr, "l2tp")) /* l2tp */
                tmpval = 5;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }        
        return NULL;

    case LENABLEWAN:
        *write_method = write_lenableWAN;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "enable")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* enable */
                tmpval = 1;
            else if(tmpval == 0) /* disable */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LENABLENAT:
        *write_method = write_lenableNAT;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "nat_x")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* enable */
                tmpval = 1;
            else if(tmpval == 0) /* disable */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LENABLEUPNP:
        *write_method = write_lenableUPnP;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "upnp_enable")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* enable */
                tmpval = 1;
            else if(tmpval == 0) /* disable */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
        
    case LGETWANIPAUTO:
        *write_method = write_lgetWanIPAuto;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "dhcpenable_x")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LWIPADDRESS:
        *write_method = write_lwIPAddress;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "ipaddr_x")) != NULL)
        {
            tmpval_u = inet_addr(nmp_safe_get(varstr));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;

    case LWSUBNETMASK:
        *write_method = write_lwSubnetMask;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;
        if(nmp_safe_get(strcat(varstr, "netmask_x")) != NULL)
        {
            tmpval_u = inet_addr(nmp_safe_get(varstr));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;

    case LWDEFAULTGATEWAY:
        *write_method = write_lwDefaultGateway;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;        
        if(nmp_safe_get(strcat(varstr, "gateway_x")) != NULL)
        {
            tmpval_u = inet_addr(nmp_safe_get(varstr));
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;
        }
        return NULL;

    case LWCONNECTDNSSERVERAUTO:
        *write_method = write_lwconnectDNSServerAuto;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;           
        if(nmp_safe_get(strcat(varstr, "dnsenable_x")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LWDNSSERVER1:
        *write_method = write_lwdnsServer1;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "dns1_x")) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;

    case LWDNSSERVER2:
        *write_method = write_lwdnsServer2;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "dns2_x")) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;       

    case LAUTHENTICATION:
        *write_method = write_lAuthentication;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "auth_x")) != NULL)
        {
            if(!strcmp(nmp_get(varstr), "")) /* none */
                tmpval = 1;
            else if(!strcmp(nmp_get(varstr), "8021x-md5")) /* 802.1x md5 */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LUSERNAME:
        *write_method = write_lUserName;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_username")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;

    case LPASSWORD:
        *write_method = write_lPassword;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_passwd")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;

    case LIDLEDISCONNECTTIME:
        *write_method = write_lidleDisconnectTime;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;        
        if(nmp_safe_get(strcat(varstr, "pppoe_idletime")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LMTU:
        *write_method = write_lmtu;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "pppoe_mtu")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LMRU:
        *write_method = write_lmru;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "pppoe_mru")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LSERVICENAME:
        *write_method = write_lserviceName;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_service")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;

    case LACCESSCONCENTRATORNAME:        
        *write_method = write_laccessConcentratorName;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_ac")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;

    case LPPTPOPTIONS:
        *write_method = write_lpptpOptions;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "pptp_options_x")) != NULL)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            sprintf(tmpstr, nmp_safe_get(varstr));
            if(!strcmp(tmpstr, "")) /* auto */
                tmpval = 1;
            else if(!strcmp(tmpstr, "-mppc")) /* no encryption */
                tmpval = 2;
            else if(!strcmp(tmpstr, "+mppe-40")) /* mppe-40 */
                tmpval = 3;
            else if(!strcmp(tmpstr, "+mppe-128")) /* mppe-128 */
                tmpval = 4;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LADDITIONALPPPDOPTIONS:
        *write_method = write_ladditionalPppdOptions;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "pppoe_options_x")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;

    case LVPNSERVER:
        *write_method = write_lvpnServer;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "heartbeat_x")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;

    case LENABLEVPNANDDHCPCONNECTION:
        *write_method = write_lenableVPNandDHCPConnection;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get(strcat(varstr, "vpndhcp")) != NULL)
        {
            tmpval = nmp_get_int(varstr);
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case LHOSTNAME:
        *write_method = write_lHostName;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(strcat(varstr, "hostname")) != NULL)
        {
            strcpy(tmpstr, nmp_safe_get(varstr));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;

    case LMACADDRESS:
        *write_method = write_lMacAddress;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);
        memset(macstr, 0x0, sizeof(macstr));
        if(nmp_safe_get(strcat(varstr, "hwaddr_x")) != NULL)
        {
            strcpy(macstr, nmp_safe_get(varstr));
            ether_atoe(macstr, tmpstr);
            *var_len = 6;
            return ( u_char * )tmpstr;
        }
        return NULL;

    case LDHCPQUERYFREQUENCY:
        *write_method = write_ldhcpQueryFrequency;
        if(lwan_unit != -1)
        {
            memset(varstr, 0, 32);
            wan_prefix(lwan_unit, varstr);
        }   
        else
            return NULL;            
        if(nmp_safe_get("dhcpc_mode") != NULL)
        {
            tmpval = nmp_get_int("dhcpc_mode");
            if(tmpval == 0) /* normal mode */
                tmpval = 1;
            else if(tmpval == 1) /* aggressive mode */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case UENABLEUSBMODEM:
        *write_method = write_uEnableUSBModem;
        if(nmp_safe_get("modem_enable") != NULL)
        {
            tmpval = nmp_get_int("modem_enable");
            if(tmpval >= 1) /* yes */
                tmpval = 1;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case UUSBMODEM:
        *write_method = write_uUsbModem;
        if(nmp_safe_get("modem_enable") != NULL)
        {
            tmpval = nmp_get_int("modem_enable");
            if(tmpval >= 1)
            {
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;
    case UNETWORKTYPE:
        *write_method = write_uNetworkType;
        if(nmp_safe_get("modem_mode") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("modem_mode"));
            if(!strcmp(tmpstr, "0"))
                tmpval = 1;
            else if(!strcmp(tmpstr, "43"))
                tmpval = 2;    
            else if(!strcmp(tmpstr, "4"))
                tmpval = 3; 
            else if(!strcmp(tmpstr, "3"))
                tmpval = 4; 
            else if(!strcmp(tmpstr, "2"))
                tmpval = 5;                 
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case UAPNSERVICE:
        *write_method = write_uAPNService;
        if(nmp_safe_get("modem_apn") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("modem_apn"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case UDIALNUMBER:
        *write_method = write_uDialNumber;
        if(nmp_safe_get("modem_dialnum") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("modem_dialnum"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case UPINCODE:
        *write_method = write_uPinCode;
        if(nmp_safe_get("modem_pincode") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("modem_pincode"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case UUSERNAME:
        *write_method = write_uUsername;
        if(nmp_safe_get("modem_user") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("modem_user"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case UPASSWORD:
        *write_method = write_uPassword;
        if(nmp_safe_get("modem_pass") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("modem_pass"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;
    case UEMAIL:
        *write_method = write_uEmail;
        if(nmp_safe_get("modem_ttlsid") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("modem_ttlsid"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr; 
        }
        return NULL;        
    case UUSBADAPTER:
        *write_method = write_uUSBAdapter;
        if(nmp_safe_get("Dev3G") != NULL)
        {
            int i = 0;
            strcpy(tmpstr, nmp_safe_get("Dev3G"));
            tmpstr[strlen(tmpstr)] = '\0';
            while(adpater_list[i] != NULL)
            {
                if(!strcmp(adpater_list[i], tmpstr))
                {
                    tmpval = i;
                    *var_len = sizeof( long );
                    return ( u_char * ) &tmpval;
                }
                else
                    i++;
            }                       
        }
        return NULL;
    case DWPRIMARYWAN:
        *write_method = write_dwPrimaryWAN;
        if(nmp_safe_get("wans_dualwan") != NULL)
        {
            char *pri, *sec;
	        sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
		    if(vstrsep(tmpstr, " ", &pri, &sec) != 2) return NULL;
		    if(!strcmp(pri, "wan"))
			     tmpval = 1;
		    else if(!strcmp(pri, "usb"))
			     tmpval = 2;
	 	    else if(!strcmp(pri, "lan"))
			     tmpval = 3;
		    *var_len = sizeof( long );
		    return ( u_char * ) &tmpval;
        }
        return NULL;
    case DWPWLANPORT:
        *write_method = write_dwPWLanPort;
        if(nmp_safe_get("wanports") != NULL)
        {
		    tmpval = nmp_get_int("wanports");
            if( (tmpval >= 1) && (tmpval <= 4) )
            {
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;

    case DWSECONDARYWAN:
        *write_method = write_dwSecondaryWAN;
        if(nmp_safe_get("wans_dualwan") != NULL)
        {
            char *pri, *sec;
            sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
            if(vstrsep(tmpstr, " ", &pri, &sec) != 2) return NULL;
            if(!strcmp(sec, "none"))
                tmpval = 0;
            else if(!strcmp(sec, "wan"))
                tmpval = 1;
            else if(!strcmp(sec, "usb"))
                tmpval = 2;
            else if(!strcmp(sec, "lan"))
                tmpval = 3;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;

    case DWSWLANPORT:
        *write_method = write_dwSWLanPort;
        if(nmp_safe_get("wan1ports") != NULL)
        {
            tmpval = nmp_get_int("wan1ports");
            if( (tmpval >= 1) && (tmpval <= 4) )
            {
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;
    case DWDUALWANMODE:
        *write_method = write_dwDualWANMode;
        if(nmp_safe_get("wans_mode") != NULL)
        {
            sprintf(tmpstr, "%s", nmp_safe_get("wans_mode"));
            if(!strcmp(tmpstr, "fo"))
                tmpval = 1;
            else if(!strcmp(tmpstr, "lb"))
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case DWLOADBALANCECFGPRI:
        *write_method = write_dwLoadBalanceCfgPri;
    	if(nmp_safe_get("wans_lb_ratio") != NULL)
    	{
    		char *priRatio, *secRatio;
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%s", nmp_safe_get("wans_lb_ratio"));
    		if(vstrsep(tmpstr, ":", &priRatio, &secRatio) != 2) return NULL;
    		tmpval = atoi(priRatio);
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case DWLOADBALANCECFGSEC:
        *write_method = write_dwLoadBalanceCfgSec;
    	if(nmp_safe_get("wans_lb_ratio") != NULL)
    	{
    		char *priRatio, *secRatio;
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%s", nmp_safe_get("wans_lb_ratio"));
    		if(vstrsep(tmpstr, ":", &priRatio, &secRatio) != 2) return NULL;
    		tmpval = atoi(secRatio);
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case DWALLOWFAILBACK:
        *write_method = write_dwAllowFailBack;
    	if(nmp_safe_get("wans_mode") != NULL)
    	{
    		sprintf(tmpstr, "%s", nmp_safe_get("wans_mode"));
    		if(!strcmp(tmpstr, "fb"))
    			tmpval = 1;//Yes
    		else
    			tmpval = 2;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case DWPINGINTERVAL:
        *write_method = write_dwPingInterval;
        if(nmp_safe_get("wandog_interval") != NULL)
    	{
    		tmpval = nmp_get_int("wandog_interval");
            *var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case DWPINGDELAY:
        *write_method = write_dwPingDelay;
        if(nmp_safe_get("wandog_delay") != NULL)
    	{
    		tmpval = nmp_get_int("wandog_delay");
            *var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case DWPINGFAILCOUNT:
        *write_method = write_dwPingFailCount;
        if(nmp_safe_get("wandog_maxfail") != NULL)
    	{
    		tmpval = nmp_get_int("wandog_maxfail");
          	*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case DWPINGFBCOUNT:
        *write_method = write_dwPingFbCount;
        if(nmp_safe_get("wandog_fb_count") != NULL)
    	{
    		tmpval = nmp_get_int("wandog_fb_count");
          	*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case DWPINGENABLEWATCHDOG:
        *write_method = write_dwPingEnableWatchdog;
        if(nmp_safe_get("wandog_enable") != NULL)
    	{
    		tmpval = nmp_get_int("wandog_enable");
    		if(tmpval == 1) /* yes */
    			tmpval = 1;
    		else if(tmpval == 0) /* no */
    			tmpval = 2;
          	*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case DWPINGTARGET:
        *write_method = write_dwPingTarget;
    	if(nmp_safe_get("wandog_target") != NULL)
    	{
    		strcpy(tmpstr, nmp_safe_get("wandog_target"));
    		tmpstr[strlen(tmpstr)] = '\0';
    		*var_len = strlen( tmpstr );
    		return ( u_char * ) tmpstr;	
    	}
        return NULL;
    case DWENABLEROUTINGRULES:
        *write_method = write_dwEnableRoutingRules;
        if(nmp_safe_get("wans_routing_enable") != NULL)
    	{
    		tmpval = nmp_get_int("wans_routing_enable");
    		if(tmpval == 1) /* yes */
    			tmpval = 1;
    		else if(tmpval == 0) /* no */
    			tmpval = 2;
          	*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case ENABLEPORTTRIGGER:
        *write_method = write_enablePortTrigger;
        if(nmp_safe_get("autofw_enable_x") != NULL)
    	{
    		tmpval = nmp_get_int("autofw_enable_x");
    		if(tmpval == 1) /* yes */
    			tmpval = 1;
    		else if(tmpval == 0) /* no */
    			tmpval = 2;
          	*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
        return NULL;
    case ENABLEPORTFORWARDING:
        *write_method = write_enablePortForwarding;
        if(nmp_safe_get("vts_enable_x") != NULL)
        {
            tmpval = nmp_get_int("vts_enable_x");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case FTPSERVERPORT:
        *write_method = write_ftpServerPort;
        if(nmp_safe_get("vts_ftpport") != NULL)
      	{
		tmpval = nmp_get_int("vts_ftpport");
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case WCLIENTLISTACT:
        *write_method = write_wClientListAct;
        *var_len = sizeof( long );
        tmpval = 2; /* 1: scan	2: nothing */
        return ( u_char * ) &tmpval;
    case ENABLEDMZ:
        *write_method = write_enableDMZ;
        if(strlen(nmp_safe_get("dmz_ip")))
            tmpval = 1;
        else
            tmpval = 2;
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case EXPOSEDSTATIONIPADDR:
        *write_method = write_exposedStationIPAddr;
        if(nmp_safe_get("dmz_ip") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("dmz_ip"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;
        }
        return NULL;
    case ENABLEDDNSCLIENT:
        *write_method = write_enableDDNSClient;
        if(nmp_safe_get("ddns_enable_x") != NULL)
        {
            tmpval = nmp_get_int("ddns_enable_x");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case DDNSSERVER:
        *write_method = write_ddnsServer;
        if(nmp_safe_get("ddns_server_x") != NULL)
        {
            if(!strcmp(nmp_get("ddns_server_x"), "WWW.ASUS.COM")) /* WWW.ASUS.COM */
                tmpval = 1;
            else if(!strcmp(nmp_get("ddns_server_x"), "WWW.DYNDNS.ORG")) /* WWW.DYNDNS.ORG */
                tmpval = 2;
            else if(!strcmp(nmp_get("ddns_server_x"), "WWW.DYNDNS.ORG(CUSTOM)")) /* WWW.DYNDNS.ORG(CUSTOM) */
                tmpval = 3;
            else if(!strcmp(nmp_get("ddns_server_x"), "WWW.DYNDNS.ORG(STATIC)")) /* WWW.DYNDNS.ORG(STATIC) */
                tmpval = 4;
            else if(!strcmp(nmp_get("ddns_server_x"), "WWW.TZO.COM")) /* WWW.TZO.COM */
                tmpval = 5;
            else if(!strcmp(nmp_get("ddns_server_x"), "WWW.ZONEEDIT.COM")) /* WWW.ZONEEDIT.COM */
                tmpval = 6;
            else if(!strcmp(nmp_get("ddns_server_x"), "WWW.DNSOMATIC.COM")) /* WWW.DNSOMATIC.COM */
                tmpval = 7;
            else if(!strcmp(nmp_get("ddns_server_x"), "WWW.TUNNELBROKER.NET")) /* WWW.TUNNELBROKER.NET */
                tmpval = 8;
            else if(!strcmp(nmp_get("ddns_server_x"), "WWW.NO-IP.COM")) /* WWW.NO-IP.COM */
                tmpval = 9;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case DDNSHOSTNAME:
        *write_method = write_ddnsHostName;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ddns_hostname_x") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ddns_hostname_x"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;
    case DDNSUSERNAMEORMAIL:
        *write_method = write_ddnsUserNameOrMail;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ddns_username_x") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ddns_username_x"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;
    case DDNSPASSWORDORKEY:
        *write_method = write_ddnsPasswordOrKey;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("ddns_passwd_x") != NULL)
        {
            strcpy(tmpstr, nmp_safe_get("ddns_passwd_x"));
            tmpstr[strlen(tmpstr)] = '\0';
            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;	
        }
        return NULL;
    case ENABLEWILDCARD:
        *write_method = write_enableWildcard;
        if(nmp_safe_get("ddns_wildcard_x") != NULL)
        {
            tmpval = nmp_get_int("ddns_wildcard_x");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }  
        return NULL;
    case PPTPPASSTHROUGH:
        *write_method = write_pptpPassthrough;
        if(nmp_safe_get("fw_pt_pptp") != NULL)
        {
            tmpval = nmp_get_int("fw_pt_pptp");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case L2TPPASSTHROUGH:
        *write_method = write_l2tpPassthrough;
        if(nmp_safe_get("fw_pt_l2tp") != NULL)
        {
            tmpval = nmp_get_int("fw_pt_l2tp");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case IPSECPASSTHROUGH:
        *write_method = write_ipsecPassthrough;
        if(nmp_safe_get("fw_pt_ipsec") != NULL)
        {
            tmpval = nmp_get_int("fw_pt_ipsec");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case RTSPPASSTHROUGH:
        *write_method = write_rtspPassthrough;
        if(nmp_safe_get("fw_pt_rtsp") != NULL)
        {
            tmpval = nmp_get_int("fw_pt_rtsp");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case H323PASSTHROUGH:
        *write_method = write_h323Passthrough;
        if(nmp_safe_get("fw_pt_h323") != NULL)
        {
            tmpval = nmp_get_int("fw_pt_h323");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case SIPPASSTHROUGH:
        *write_method = write_sipPassthrough;
        if(nmp_safe_get("fw_pt_sip") != NULL)
        {
            tmpval = nmp_get_int("fw_pt_sip");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case PPPOERELAY:
        *write_method = write_pppoeRelay;
        if(nmp_safe_get("fw_pt_pppoerelay") != NULL)
        {
            tmpval = nmp_get_int("fw_pt_pppoerelay");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_dwRoutingRulesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wan above.
 */
unsigned char *
var_dwRoutingRulesTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char dwRoutingRulelist[MAXROUTINGRULES][MAXROUTINGSTRNUM];
    int i, dwRoutingRulelist_count = 0;
    char *nv, *nvp, *b, *sourceIp, *destIp, *wanUnit;

    for(i = 0; i < MAXROUTINGRULES; i++)
    	memset(dwRoutingRulelist[i], 0x0, MAXROUTINGSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("wans_routing_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(dwRoutingRulelist[dwRoutingRulelist_count], b);
    		dwRoutingRulelist_count++;		
    	}
    	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXROUTINGRULES)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case DWROUTINGRULEINDEX:
        return NULL;
    case DWSOURCEIP:
        *write_method = write_dwSourceIP;
        sourceIp = "0.0.0.0";
        index = name[*length-1]-1;
        if(index <= dwRoutingRulelist_count-1) {
            if (strlen(dwRoutingRulelist[index])) {
                if((vstrsep(dwRoutingRulelist[index], ">", &sourceIp, &destIp, &wanUnit) != 3)) break;
            }
    	}
        tmpval_u = inet_addr(sourceIp);
        *var_len = sizeof( unsigned long );
        return ( u_char * ) &tmpval_u;
    case DWDESTINATIONIP:
        *write_method = write_dwDestinationIP;
        destIp = "0.0.0.0";
        index = name[*length-1]-1;
        if(index <= dwRoutingRulelist_count-1) {
            if (strlen(dwRoutingRulelist[index])) {
                if((vstrsep(dwRoutingRulelist[index], ">", &sourceIp, &destIp, &wanUnit) != 3)) break;
            }
    	}
        tmpval_u = inet_addr(destIp);
        *var_len = sizeof( unsigned long );
        return ( u_char * ) &tmpval_u;
    case DWWANUNIT:
        *write_method = write_dwWANUnit;
        tmpval = 0; //default value
        index = name[*length-1]-1;
        if(index <= dwRoutingRulelist_count-1) {
            if (strlen(dwRoutingRulelist[index])) {
                if((vstrsep(dwRoutingRulelist[index], ">", &sourceIp, &destIp, &wanUnit) != 3)) break;
                if(!strcmp(wanUnit, "0"))
                    tmpval = 1;
                else if(!strcmp(wanUnit, "1"))
                    tmpval = 2;
            }
    	}
        *var_len = sizeof( unsigned long );
        return ( u_char * ) &tmpval;
    case DWROUTINGRULEDELENTRY:
        *write_method = write_dwRoutingRuleDelEntry;
    	tmpval = 2; /* no */
        *var_len = sizeof(unsigned long);
      	return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_portTriggerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wan above.
 */
unsigned char *
var_portTriggerTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char autofw_rulelist[MAXPORTTRIGGER][PORTTRIGGERSTRNUM];
    int i, autofw_rulelist_count = 0;
    char *nv, *nvp, *b, *desc, *triggerPort, *triggerProto, *incomingPort, *incomingProto;

    for(i = 0; i < MAXPORTTRIGGER; i++)
    	memset(autofw_rulelist[i], 0x0, PORTTRIGGERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("autofw_rulelist"));
    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(autofw_rulelist[autofw_rulelist_count], b);
            autofw_rulelist_count++;		
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXPORTTRIGGER /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PORTTRIGGERINDEX:
        return NULL;
    case PORTTRIGGERDESCRIPTION:
        *write_method = write_portTriggerDescription;
        index = name[*length-1]-1;
        if(index <= autofw_rulelist_count-1) {
        	if (strlen(autofw_rulelist[index])) {
    			if((vstrsep(autofw_rulelist[index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;
    			strcpy(tmpstr, desc);
    		}
    	}
    	*var_len = strlen(tmpstr);
    	return ( u_char * )tmpstr;
    case PORTTRIGGERPORT:
        *write_method = write_portTriggerPort;
        index = name[*length-1]-1;
        if(index <= autofw_rulelist_count-1) {
        	if (strlen(autofw_rulelist[index])) {
    			if((vstrsep(autofw_rulelist[index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;
    			strcpy(tmpstr, triggerPort);
    		}
    	}
    	*var_len = strlen(tmpstr);
    	return ( u_char * )tmpstr;
    case PORTTRIGGERPROTOCOL:
        *write_method = write_portTriggerProtocol;
	tmpval = 1; //default value
	index = name[*length-1]-1;
        if(index <= autofw_rulelist_count-1) {
        	if (strlen(autofw_rulelist[index])) {
			if((vstrsep(autofw_rulelist[index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;

			if(!strcmp(triggerProto, "TCP"))
				tmpval = 1;
			else if(!strcmp(triggerProto, "UDP"))
				tmpval = 2;
		}
    	}
	*var_len = sizeof( unsigned long );
	return ( u_char * ) &tmpval;

    case PORTTRIGGERINCOMINGPORT:
        *write_method = write_portTriggerIncomingPort;
	index = name[*length-1]-1;
        if(index <= autofw_rulelist_count-1) {
        	if (strlen(autofw_rulelist[index])) {
			if((vstrsep(autofw_rulelist[index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;
			strcpy(tmpstr, incomingPort);
		}
    	}
	*var_len = strlen(tmpstr);
	return ( u_char * )tmpstr;
    case PORTTRIGGERINCOMINGPROTOCOL:
        *write_method = write_portTriggerIncomingProtocol;
	tmpval = 1; //default value
	index = name[*length-1]-1;
        if(index <= autofw_rulelist_count-1) {
        	if (strlen(autofw_rulelist[index])) {
			if((vstrsep(autofw_rulelist[index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;

			if(!strcmp(incomingProto, "TCP"))
				tmpval = 1;
			else if(!strcmp(incomingProto, "UDP"))
				tmpval = 2;
		}
    	}
	*var_len = sizeof( unsigned long );
	return ( u_char * ) &tmpval;
    case PORTTRIGGERDELENTRY:
        *write_method = write_portTriggerDelEntry;
    	tmpval = 2; /* no */
 	*var_len = sizeof(unsigned long);
      	return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_wClientTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wan above.
 */
unsigned char *
var_wClientTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_CLIENT_LIST /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WCLIENTINDEX:
        return NULL;
    case WCLIENTIPADDR:
        index = name[*length-1]-1;
    	if(index < wclient_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%d.%d.%d.%d", wclient_list[index].ip_addr[0],
						wclient_list[index].ip_addr[1],
						wclient_list[index].ip_addr[2],
						wclient_list[index].ip_addr[3]);

    		tmpval_u = inet_addr(tmpstr);
    		*var_len = sizeof( unsigned long );
    		return ( u_char * ) &tmpval_u;			
    	}	
        return NULL;
    case WCLIENTNAME:
        index = name[*length-1]-1;
    	if(index < wclient_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%s", wclient_list[index].device_name);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_portForwardingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wan above.
 */
unsigned char *
var_portForwardingTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char vts_rulelist[MAXPORTFORWARDING][PORTFORWARDINGSTRNUM];
    int i, vts_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *portRange, *localIP, *localPort, *protocol;

    for(i = 0; i < MAXPORTFORWARDING; i++)
    	memset(vts_rulelist[i], 0x0, PORTFORWARDINGSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of vts_rulelist
    nv = nvp = strdup(nmp_safe_get("vts_rulelist"));
    if (nv) {
	   while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(vts_rulelist[vts_rulelist_count], b);
            vts_rulelist_count++;		
	   }
	   free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXPORTFORWARDING /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PORTFORWARDINGINDEX:
	return NULL;
    case PORTFORWARDINGSERVICENAME:
        *write_method = write_portForwardingServiceName;
        index = name[*length-1]-1;
        if(index <= vts_rulelist_count-1) {
            if (strlen(vts_rulelist[index])) {
                if((vstrsep(vts_rulelist[index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
                    strcpy(tmpstr, serviceName);
            }
    	}
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PORTFORWARDINGPORTRANGE:
        *write_method = write_portForwardingPortRange;
        index = name[*length-1]-1;
        if(index <= vts_rulelist_count-1) {
            if (strlen(vts_rulelist[index])) {
                if((vstrsep(vts_rulelist[index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
                    strcpy(tmpstr, portRange);
            }
    	}
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PORTFORWARDINGLOCALIP:
        *write_method = write_portForwardingLocalIP;
        localIP = "0.0.0.0";
        index = name[*length-1]-1;
        if(index <= vts_rulelist_count-1) {
            if (strlen(vts_rulelist[index])) {
                if((vstrsep(vts_rulelist[index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
            }
    	}
        tmpval_u = inet_addr(localIP);
        *var_len = sizeof( unsigned long );
        return ( u_char * ) &tmpval_u;
    case PORTFORWARDINGLOCALPORT:
        *write_method = write_portForwardingLocalPort;
        tmpval = 0;
        index = name[*length-1]-1;
        if(index <= vts_rulelist_count-1) {
            if (strlen(vts_rulelist[index])) {
                if((vstrsep(vts_rulelist[index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
                tmpval = atoi(localPort);
            }
    	}
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case PORTFORWARDINGPROTOCOL:
        *write_method = write_portForwardingProtocol;
        tmpval = 1; //default value
        index = name[*length-1]-1;
        if(index <= vts_rulelist_count-1) {
            if (strlen(vts_rulelist[index])) {
                if((vstrsep(vts_rulelist[index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
                if(!strcmp(protocol, "TCP")) tmpval = 1;
                else if(!strcmp(protocol, "UDP")) tmpval = 2;
                else if(!strcmp(protocol, "BOTH")) tmpval = 3;
                else if(!strcmp(protocol, "OTHER")) tmpval = 4;
            }
    	}
        *var_len = sizeof( unsigned long );
        return ( u_char * ) &tmpval;
    case PORTFORWARDINGDELENTRY:
        *write_method = write_portForwardingDelEntry;
    	tmpval = 2; /* no */
        *var_len = sizeof(unsigned long);
      	return ( u_char * )&tmpval;
    default:
        ERROR_MSG("");
    }
    return NULL;
}



int
write_wwanConnectionType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char varstr[32], *priWan, *secWan;

    memset(varstr, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, varstr);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wwanConnectionType not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wwanConnectionType: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 5) {
              fprintf(stderr, "write to wwanConnectionType: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 5) {
      		    switch(value)
      		    {
      			   case 1:/* dhcp */
				        nmp_set(strcat(varstr, "proto"), "dhcp");
				    break;
      			   case 2:/* pppoe */
				        nmp_set(strcat(varstr, "proto"), "pppoe");
				    break;
      			   case 3:	/* static */
				        nmp_set(strcat(varstr, "proto"), "static");
				    break;
                    case 4:/* pptp */
				        nmp_set(strcat(varstr, "proto"), "pptp");
				    break;
                    case 5:/* l2tp */
				        nmp_set(strcat(varstr, "proto"), "l2tp");
				    break;
                }
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wenableWAN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char varstr[32], *priWan, *secWan;

    memset(varstr, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, varstr);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wenableWAN not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wenableWAN: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wenableWAN: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set(strcat(varstr, "enable"), "1");
             	else if(value == 2)
			nmp_set(strcat(varstr, "enable"), "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wenableNAT(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char varstr[32], *priWan, *secWan;

    memset(varstr, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, varstr);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wenableNAT not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wenableNAT: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wenableNAT: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set(strcat(varstr, "nat_x"), "1");
             	else if(value == 2)
			nmp_set(strcat(varstr, "nat_x"), "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wenableUPnP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char varstr[32], *priWan, *secWan;

    memset(varstr, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, varstr);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wenableUPnP not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wenableUPnP: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wenableUPnP: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set(strcat(varstr, "upnp_enable"), "1");
             	else if(value == 2)
			nmp_set(strcat(varstr, "upnp_enable"), "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wgetWanIPAuto(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wgetWanIPAuto not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wgetWanIPAuto: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wgetWanIPAuto: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set(strcat(wan_prefix, "dhcpenable_x"), "1");
             	else if(value == 2)
			nmp_set(strcat(wan_prefix, "dhcpenable_x"), "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wwIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);    
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wwIPAddress not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wwIPAddress: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set(strcat(wan_prefix, "ipaddr_x"), tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wwSubnetMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);    
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wwSubnetMask not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wwSubnetMask: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set(strcat(wan_prefix, "netmask_x"), tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wwDefaultGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wwDefaultGateway not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wwDefaultGateway: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set(strcat(wan_prefix, "gateway_x"), tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wconnectDNSServerAuto(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);    
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wconnectDNSServerAuto not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wconnectDNSServerAuto: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wconnectDNSServerAuto: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            sprintf(tmpstr, "wan%d_dhcpenable_x", wan_unit);
            if(!strcmp(nmp_get(tmpstr), "0")){
                if(value == 1)
                    return SNMP_ERR_WRONGVALUE;
                else
                    nmp_set(strcat(wan_prefix, "dnsenable_x"), "0");
            }
            else{
                if(value == 1)
                    nmp_set(strcat(wan_prefix, "dnsenable_x"), "1");
                else if(value == 2)
                    nmp_set(strcat(wan_prefix, "dnsenable_x"), "0");
            } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wdnsServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wdnsServer1 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to wdnsServer1: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "dns1_x"), tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wdnsServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wdnsServer2 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to wdnsServer2: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "dns2_x"), tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wAuthentication(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wAuthentication not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wAuthentication: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wAuthentication: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set(strcat(wan_prefix, "auth_x"), "");
             	else if(value == 2)
			nmp_set(strcat(wan_prefix, "auth_x"), "8021x-md5");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wUserName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wUserName not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to wUserName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len >= 1 || var_val_len <= 64)
            {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set(strcat(wan_prefix, "pppoe_username"), tmpstr);
            }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wPassword not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to wPassword: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len >= 1 || var_val_len <= 64)
            {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set(strcat(wan_prefix, "pppoe_passwd"), tmpstr); 			
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_widleDisconnectTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to widleDisconnectTime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to widleDisconnectTime: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int(strcat(wan_prefix, "pppoe_idletime"), value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wmtu(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wmtu not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wmtu: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int(strcat(wan_prefix, "pppoe_mtu"), value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wmru(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wmru not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wmru: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int(strcat(wan_prefix, "pppoe_mru"), value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wserviceName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wserviceName not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to wserviceName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
        	nmp_set(strcat(wan_prefix, "pppoe_service"), tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_waccessConcentratorName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to waccessConcentratorName: not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to waccessConcentratorName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "pppoe_ac"), tmpstr); 			
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpptpOptions(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wpptpOptions: not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wpptpOptions: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 4) {
              fprintf(stderr, "write to wpptpOptions: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 4) {
      		    switch(value)
      		    {
      			   case 1:/* auto */
				    nmp_set(strcat(wan_prefix, "pptp_options_x"), "");
				    break;
      			   case 2:/* no encryption */
				    nmp_set(strcat(wan_prefix, "pptp_options_x"), "-mppc");
				    break;
      			   case 3:	/* mppe-40 */
				    nmp_set(strcat(wan_prefix, "pptp_options_x"), "+mppe-40");
				    break;
                    case 4:/* mppe-128 */
				    nmp_set(strcat(wan_prefix, "pptp_options_x"), "+mppe-128");
				    break;
                }
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wadditionalPppdOptions(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wadditionalPppdOptions: not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to wadditionalPppdOptions: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len >= 1 || var_val_len <= 32)
            {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set(strcat(wan_prefix, "pppoe_options_x"), tmpstr); 			
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wvpnServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wvpnServer not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 256 ) {
              fprintf(stderr, "write to wvpnServer: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len >= 1 && var_val_len <= 256)
            {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set(strcat(wan_prefix, "heartbeat_x"), tmpstr); 			
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wenableVPNandDHCPConnection(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wenableVPNandDHCPConnection not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wenableVPNandDHCPConnection: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wenableVPNandDHCPConnection: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set(strcat(wan_prefix, "vpndhcp"), "1");
             	else if(value == 2)
                nmp_set(strcat(wan_prefix, "vpndhcp"), "0");
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wHostName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wHostName not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to wHostName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len >= 1 && var_val_len <= 32)
            {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set(strcat(wan_prefix, "hostname"), tmpstr); 			
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wMacAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char macaddr[MACSTRNUM];
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "wan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "wan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wMacAddress not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to wMacAddress: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(macaddr, 0, MACSTRNUM);
             ether_etoa(var_val, macaddr);
             if(strcmp("00:00:00:00:00:00", macaddr))
		          nmp_set(strcat(wan_prefix, "hwaddr_x"), macaddr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wdhcpQueryFrequency(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wdhcpQueryFrequency not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wdhcpQueryFrequency: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf(stderr, "write to wdhcpQueryFrequency: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set("dhcpc_mode", "0");
                else if(value == 2)
                    nmp_set("dhcpc_mode", "1");
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lwanConnectionType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char varstr[32], *priWan, *secWan;

    memset(varstr, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, varstr);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lwanConnectionType not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lwanConnectionType: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 5) {
              fprintf(stderr, "write to lwanConnectionType: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 5) {
                switch(value)
                {
                   case 1:/* dhcp */
                        nmp_set(strcat(varstr, "proto"), "dhcp");
                    break;
                   case 2:/* pppoe */
                        nmp_set(strcat(varstr, "proto"), "pppoe");
                    break;
                   case 3:  /* static */
                        nmp_set(strcat(varstr, "proto"), "static");
                    break;
                    case 4:/* pptp */
                        nmp_set(strcat(varstr, "proto"), "pptp");
                    break;
                    case 5:/* l2tp */
                        nmp_set(strcat(varstr, "proto"), "l2tp");
                    break;
                }
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lenableWAN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char varstr[32], *priWan, *secWan;

    memset(varstr, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, varstr);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lenableWAN not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lenableWAN: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lenableWAN: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set(strcat(varstr, "enable"), "1");
                else if(value == 2)
                    nmp_set(strcat(varstr, "enable"), "0");
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lenableNAT(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char varstr[32], *priWan, *secWan;

    memset(varstr, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, varstr);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lenableNAT not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lenableNAT: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lenableNAT: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set(strcat(varstr, "nat_x"), "1");
                else if(value == 2)
                    nmp_set(strcat(varstr, "nat_x"), "0");
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lenableUPnP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char varstr[32], *priWan, *secWan;

    memset(varstr, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, varstr);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lenableUPnP not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lenableUPnP: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lenableUPnP: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set(strcat(varstr, "upnp_enable"), "1");
                else if(value == 2)
                    nmp_set(strcat(varstr, "upnp_enable"), "0");
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lgetWanIPAuto(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lgetWanIPAuto not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lgetWanIPAuto: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lgetWanIPAuto: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 2) {
                if(value == 1)//yes
                    nmp_set(strcat(wan_prefix, "dhcpenable_x"), "1");
                else if(value == 2)//no
                    nmp_set(strcat(wan_prefix, "dhcpenable_x"), "0");
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lwIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);    
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lwIPAddress not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lwIPAddress: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set(strcat(wan_prefix, "ipaddr_x"), tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lwSubnetMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);    
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lwSubnetMask not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lwSubnetMask: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set(strcat(wan_prefix, "netmask_x"), tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lwDefaultGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lwDefaultGateway not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lwDefaultGateway: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set(strcat(wan_prefix, "gateway_x"), tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lwconnectDNSServerAuto(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);    
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lwconnectDNSServerAuto not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lwconnectDNSServerAuto: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lwconnectDNSServerAuto: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            sprintf(tmpstr, "wan%d_dhcpenable_x", wan_unit);
            if(!strcmp(nmp_get(tmpstr), "0")){
                if(value == 1)
                    return SNMP_ERR_WRONGVALUE;
                else
                    nmp_set(strcat(wan_prefix, "dnsenable_x"), "0");
            }
            else{
                if(value == 1)
                    nmp_set(strcat(wan_prefix, "dnsenable_x"), "1");
                else if(value == 2)
                    nmp_set(strcat(wan_prefix, "dnsenable_x"), "0");
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lwdnsServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lwdnsServer1 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to lwdnsServer1: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "dns1_x"), tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lwdnsServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lwdnsServer2 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to lwdnsServer2: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "dns2_x"), tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lAuthentication(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lAuthentication not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lAuthentication: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lAuthentication: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 2) {
                if(value == 1)
                    nmp_set(strcat(wan_prefix, "auth_x"), "");
                else if(value == 2)
                    nmp_set(strcat(wan_prefix, "auth_x"), "8021x-md5");
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lUserName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lUserName not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to lUserName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len >= 1 && var_val_len <= 64)
            {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set(strcat(wan_prefix, "pppoe_username"), tmpstr);
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lPassword not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to lPassword: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len >= 1 && var_val_len <= 64)
            {
                strncpy(tmpstr, (u_char *)var_val, var_val_len); 
                tmpstr[var_val_len] = '\0';
                nmp_set(strcat(wan_prefix, "pppoe_passwd"), tmpstr);            
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lidleDisconnectTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lidleDisconnectTime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lidleDisconnectTime: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int(strcat(wan_prefix, "pppoe_idletime"), value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lmtu(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lmtu not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lmtu: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int(strcat(wan_prefix, "pppoe_mtu"), value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lmru(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lmru not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lmru: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int(strcat(wan_prefix, "pppoe_mru"), value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lserviceName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to serviceName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "pppoe_service"), tmpstr);                      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_laccessConcentratorName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to laccessConcentratorName not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to laccessConcentratorName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "pppoe_ac"), tmpstr);                  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lpptpOptions(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lpptpOptions not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lpptpOptions: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 4) {
              fprintf(stderr, "write to lpptpOptions: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 4) {
                switch(value)
                {
                   case 1:/* auto */
                    nmp_set(strcat(wan_prefix, "pptp_options_x"), "");
                    break;
                   case 2:/* no encryption */
                    nmp_set(strcat(wan_prefix, "pptp_options_x"), "-mppc");
                    break;
                   case 3:  /* mppe-40 */
                    nmp_set(strcat(wan_prefix, "pptp_options_x"), "+mppe-40");
                    break;
                    case 4:/* mppe-128 */
                    nmp_set(strcat(wan_prefix, "pptp_options_x"), "+mppe-128");
                    break;
                }
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ladditionalPppdOptions(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ladditionalPppdOptions not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to ladditionalPppdOptions: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "pppoe_options_x"), tmpstr);                        
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lvpnServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lvpnServer not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 256 ) {
              fprintf(stderr, "write to lvpnServer: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "heartbeat_x"), tmpstr);                       
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lenableVPNandDHCPConnection(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lenableVPNandDHCPConnection not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lenableVPNandDHCPConnection: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lenableVPNandDHCPConnection: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)
                nmp_set(strcat(wan_prefix, "vpndhcp"), "1");
            else if(value == 2)
                nmp_set(strcat(wan_prefix, "vpndhcp"), "0");              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lHostName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lHostName not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to lHostName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set(strcat(wan_prefix, "hostname"), tmpstr);                  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lMacAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char macaddr[MACSTRNUM];
    int wan_unit = -1;
    char wan_prefix[32], *priWan, *secWan;

    memset(wan_prefix, 0, 32);
    memset(tmpstr, 0, SPRINT_MAX_LEN);
    sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
    if(vstrsep(tmpstr, " ", &priWan, &secWan) != 2) return NULL;
    
    if(!strcmp(priWan, "lan"))
        wan_unit = 0;
    else if(!strcmp(secWan, "lan"))
        wan_unit = 1;

    if(wan_unit == -1)
        return SNMP_ERR_NOACCESS;

    wan_prefix(wan_unit, wan_prefix);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lMacAddress not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to lMacAddress: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             ether_etoa(var_val, macaddr);
             if(strcmp("00:00:00:00:00:00", macaddr))
                  nmp_set(strcat(wan_prefix, "hwaddr_x"), macaddr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ldhcpQueryFrequency(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to ldhcpQueryFrequency not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to ldhcpQueryFrequency: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf(stderr, "write to ldhcpQueryFrequency: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)
                nmp_set("dhcpc_mode", "0");
            else if(value == 2)
                nmp_set("dhcpc_mode", "1");              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uEnableUSBModem(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to uEnableUSBModem not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to uEnableUSBModem: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to uEnableUSBModem: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }             
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */           
            nmp_set_int("modem_enable", value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uUsbModem(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to uUsbModem not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to uUsbModem: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ){
              fprintf(stderr, "write to uUsbModem: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }             
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int("modem_enable", value);                  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uNetworkType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to uNetworkType not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to uNetworkType: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 5 ){
              fprintf(stderr, "write to uNetworkType: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if( value == 1 )//auto
                nmp_set("modem_mode", "0");
            else if( value == 2 )//4g/3g
                nmp_set("modem_mode", "43");
            else if( value == 3 )
                nmp_set("modem_mode", "4");
            else if( value == 4 )
                nmp_set("modem_mode", "3");
            else if( value == 5 )
                nmp_set("modem_mode", "2");            
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uAPNService(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to uAPNService not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              memset(tmpstr, 0, SPRINT_MAX_LEN);
              strncpy(tmpstr, (u_char *)var_val, var_val_len);
              nmp_set("modem_apn", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uDialNumber(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to uDialNumber not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              memset(tmpstr, 0, SPRINT_MAX_LEN);
              strncpy(tmpstr, (u_char *)var_val, var_val_len);
              nmp_set("modem_dialnum", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uPinCode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to uPinCode not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 0 && (var_val_len < 4 || var_val_len > 8)) {
              fprintf(stderr,"write to uPinCode: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              memset(tmpstr, 0, SPRINT_MAX_LEN);
              strncpy(tmpstr, (u_char *)var_val, var_val_len);
              nmp_set("modem_pincode", tmpstr);  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uUsername(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to uUsername not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              memset(tmpstr, 0, SPRINT_MAX_LEN);
              strncpy(tmpstr, (u_char *)var_val, var_val_len);
              nmp_set("modem_user", tmpstr);                 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to uPassword not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              memset(tmpstr, 0, SPRINT_MAX_LEN);
              strncpy(tmpstr, (u_char *)var_val, var_val_len);
              nmp_set("modem_pass", tmpstr);                     
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uEmail(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to uEmail not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              memset(tmpstr, 0, SPRINT_MAX_LEN);
              strncpy(tmpstr, (u_char *)var_val, var_val_len);
              nmp_set("modem_ttlsid", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_uUSBAdapter(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to uUSBAdapter not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to uUSBAdapter: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ((*(long *)var_val < 0 || *(long *)var_val > 44) || 
             (!strcmp(nmp_safe_get("modem_enable"), "4") && (*(long *)var_val < 0 || *(long *)var_val > 1))) {
              fprintf(stderr, "write to uUSBAdapter: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          } 
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              nmp_set("Dev3G", adpater_list[value]);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwPrimaryWAN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char *pri, *sec;
    char string[16];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwPrimaryWAN not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwPrimaryWAN: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3){
              fprintf ( stderr,"write to dwPrimaryWAN: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(string, 0, 16);
		sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
		if(vstrsep(tmpstr, " ", &pri, &sec) != 2) break;
		if(value == 1)//WAN
		{
			if(!strcmp(sec, "wan"))
				sprintf(string, "wan usb");	
			else
				sprintf(string, "wan %s", sec);	
			nmp_set("wanports", "0");		
		}
		else if(value == 2)//USB
		{
			if(!strcmp(sec, "usb"))
			{
				sprintf(string, "usb lan");	
				nmp_set("wan1ports", "4");//default lan4
			}
			else
				sprintf(string, "usb %s", sec);	
		}
		else if(value ==3)//LAN
		{
			if(!strcmp(sec, "lan"))
			{
				sprintf(string, "lan wan");
				nmp_set("wanports", "4");//default lan4
				nmp_set("wan1ports", "0");//default lan4
			}
			else
				sprintf(string, "lan %s", sec);	
		}

		nmp_set("wans_dualwan", string);
		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwPWLanPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwPWLanPort not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwPWLanPort: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 4){
              fprintf ( stderr,"write to dwPWLanPort: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		nmp_set_int("wanports", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwSecondaryWAN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char *pri, *sec;
    char string[16];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwSecondaryWAN not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwSecondaryWAN: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 3){
              fprintf ( stderr,"write to dwSecondaryWAN: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(string, 0, 16);
		sprintf(tmpstr, "%s", nmp_safe_get("wans_dualwan"));
		if(vstrsep(tmpstr, " ", &pri, &sec) != 2) break;
		if(value == 0)//No secondary WAN
			sprintf(string, "%s none", pri);
		else if(value == 1)//WAN
		{
			if(!strcmp(pri, "wan"))
				sprintf(string, "usb wan");	
			else
				sprintf(string, "%s wan", pri);	
			nmp_set("wan1ports", "0");		
		}
		else if(value == 2)//USB
		{
			if(!strcmp(pri, "usb"))
			{
				sprintf(string, "lan usb");	
				nmp_set("wanports", "4");//default lan4
			}
			else
				sprintf(string, "%s usb", pri);	
		}
		else if(value == 3)//LAN
		{
			if(!strcmp(pri, "lan"))
			{
				sprintf(string, "wan lan");
				nmp_set("wanports", "0");
			}
			else
				sprintf(string, "%s lan", pri);	
		}

		nmp_set("wans_dualwan", string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwSWLanPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwSWLanPort not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwSWLanPort: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 4){
              fprintf ( stderr,"write to dwSWLanPort: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		nmp_set_int("wan1ports", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwDualWANMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwDualWANMode not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwDualWANMode: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to dwDualWANMode: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if(value == 1)
			nmp_set("wans_mode", "fo");
		else if(value == 2)
			nmp_set("wans_mode", "lb");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwLoadBalanceCfgPri(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char *priRatio, *secRatio;
    char string[16];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwLoadBalanceCfgPri not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwLoadBalanceCfgPri: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9){
              fprintf ( stderr,"write to dwLoadBalanceCfgPri: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
		memset(string, 0x0, 16);
		sprintf(tmpstr, "%s", nmp_safe_get("wans_lb_ratio"));
		if(strlen(tmpstr) != 0)
		{
			if(vstrsep(tmpstr, ":", &priRatio, &secRatio) != 2) break;
			sprintf(string, "%d:%s", value, secRatio);
		}
		else
			sprintf(string, "%d:", value);

		nmp_set("wans_lb_ratio", string);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwLoadBalanceCfgSec(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char *priRatio, *secRatio;
    char string[16];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwLoadBalanceCfgSec not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwLoadBalanceCfgSec: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9){
              fprintf ( stderr,"write to dwLoadBalanceCfgSec: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
		memset(string, 0x0, 16);
		sprintf(tmpstr, "%s", nmp_safe_get("wans_lb_ratio"));
		if(strlen(tmpstr) != 0)
		{
			if(vstrsep(tmpstr, ":", &priRatio, &secRatio) != 2) break;
			sprintf(string, "%s:%d", priRatio, value);
		}
		else
			sprintf(string, ":%d", value);

		nmp_set("wans_lb_ratio", string);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwAllowFailBack(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwAllowFailBack not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwAllowFailBack: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to dwAllowFailBack: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if(value == 1)//Yes
			nmp_set("wans_mode", "fb");		
		else
			nmp_set("wans_mode", "fo");	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwPingInterval(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwPingInterval not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwPingInterval: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9){
              fprintf ( stderr,"write to dwPingInterval: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  nmp_set_int("wandog_interval", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwPingDelay(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwPingDelay not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwPingDelay: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 99){
              fprintf ( stderr,"write to dwPingDelay: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  nmp_set_int("wandog_delay", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwPingFailCount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwPingFailCount not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwPingFailCount: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 99){
              fprintf ( stderr,"write to dwPingFailCount: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  nmp_set_int("wandog_maxfail", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwPingFbCount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwPingFbCount not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwPingFbCount: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 99){
              fprintf ( stderr,"write to dwPingFbCount: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  nmp_set_int("wandog_fb_count", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwPingEnableWatchdog(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwPingEnableWatchdog not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwPingEnableWatchdog: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to dwPingEnableWatchdog: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
        	if(value == 1) //Yes
			nmp_set("wandog_enable", "1");
             	else if(value == 2) //No
			nmp_set("wandog_enable", "0");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwPingTarget(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to dwPingTarget not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
	     strncpy(tmpstr, (u_char *)var_val, var_val_len); 
	     tmpstr[var_val_len] = '\0';
             nmp_set("wandog_target", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwEnableRoutingRules(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwEnableRoutingRules not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwEnableRoutingRules: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to dwEnableRoutingRules: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
        	if(value == 1) //Yes
			nmp_set("wans_routing_enable", "1");
             	else if(value == 2) //No
			nmp_set("wans_routing_enable", "0");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_enablePortTrigger(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("autofw_enable_x", "1");
             	else if(value == 2)
			nmp_set("autofw_enable_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enablePortForwarding(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("vts_enable_x", "1");
             	else if(value == 2)
			nmp_set("vts_enable_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ftpServerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 65535){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("vts_ftpport", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wClientListAct(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1) {
                wclient_count = get_client_detail_info(&wclient_list);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableDMZ(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if( value == 2 )//no
                nmp_set("dmz_ip", ""); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_exposedStationIPAddr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to exposedStationIPAddr not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to exposedStationIPAddr: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("dmz_ip", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableDDNSClient(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
                    nmp_set("ddns_enable_x", "1");
             	else if(value == 2)
                    nmp_set("ddns_enable_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ddnsServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9) {
              fprintf(stderr, "write to wan: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
      		switch(value)
      		{
      			case 1:/* WWW.ASUS.COM */
				    nmp_set("ddns_server_x", "WWW.ASUS.COM");
				    break;
      			case 2:/* WWW.DYNDNS.ORG */
				    nmp_set("ddns_server_x", "WWW.DYNDNS.ORG");
				    break;
      			case 3:	/* WWW.DYNDNS.ORG(CUSTOM) */
				    nmp_set("ddns_server_x", "WWW.DYNDNS.ORG(CUSTOM)");
				    break;
                case 4:/* WWW.DYNDNS.ORG(STATIC) */
				    nmp_set("ddns_server_x", "WWW.DYNDNS.ORG(STATIC)");
				    break;
      			case 5:/* WWW.TZO.COM */
				    nmp_set("ddns_server_x", "WWW.TZO.COM");
				    break;
      			case 6:	/* WWW.ZONEEDIT.COM */
				    nmp_set("ddns_server_x", "WWW.ZONEEDIT.COM");
				    break;
                case 7:/* WWW.DNSOMATIC.COM */
				    nmp_set("ddns_server_x", "WWW.DNSOMATIC.COM");
				    break;
      			case 8:/* WWW.TUNNELBROKER.NET */
				    nmp_set("ddns_server_x", "WWW.TUNNELBROKER.NET");
				    break;
      			case 9:	/* manual */
				    nmp_set("ddns_server_x", "WWW.NO-IP.COM");
				    break;
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ddnsHostName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 63 ) {
              fprintf(stderr, "write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 63)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
		tmpstr[var_val_len] = '\0';
        	nmp_set("ddns_hostname_x", tmpstr); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ddnsUserNameOrMail(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 32)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
		tmpstr[var_val_len] = '\0';
        	nmp_set("ddns_username_x", tmpstr); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ddnsPasswordOrKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 32)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
		tmpstr[var_val_len] = '\0';
        	nmp_set("ddns_passwd_x", tmpstr); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableWildcard(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("ddns_wildcard_x", "1");
             	else if(value == 2)
			nmp_set("ddns_wildcard_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_pptpPassthrough(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_pt_pptp", "1");
             	else if(value == 2)
			nmp_set("fw_pt_pptp", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_l2tpPassthrough(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_pt_l2tp", "1");
             	else if(value == 2)
			nmp_set("fw_pt_l2tp", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipsecPassthrough(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_pt_ipsec", "1");
             	else if(value == 2)
			nmp_set("fw_pt_ipsec", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_rtspPassthrough(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_pt_rtsp", "1");
             	else if(value == 2)
			nmp_set("fw_pt_rtsp", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_h323Passthrough(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_pt_h323", "1");
             	else if(value == 2)
			nmp_set("fw_pt_h323", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sipPassthrough(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_pt_sip", "1");
             	else if(value == 2)
			nmp_set("fw_pt_sip", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_pppoeRelay(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_pt_pppoerelay", "1");
             	else if(value == 2)
			nmp_set("fw_pt_pppoerelay", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwSourceIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    static struct in_addr addr;
    static long index, real_index;
    char dwRoutingRulelist[MAXROUTINGRULES][MAXROUTINGSTRNUM];
    int i, dwRoutingRulelist_count = 0;
    char *nv, *nvp, *b, *sourceIp, *destIp, *wanUnit;
    char sourceIpStr[32];
    char string[MAXROUTINGSTRNUM];

    for(i = 0; i < MAXROUTINGRULES; i++)
    	memset(dwRoutingRulelist[i], 0x0, MAXROUTINGSTRNUM);
    
    index = name[name_len-1] - 1;

    //Compute the number of wans_routing_rulelist
    nv = nvp = strdup(nmp_safe_get("wans_routing_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(dwRoutingRulelist[dwRoutingRulelist_count], b);
		dwRoutingRulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
         	memset(sourceIpStr, 0, sizeof(sourceIpStr));
             	addr.s_addr = value;
             	strcpy(sourceIpStr, (char *)inet_ntoa(addr)); 

		memset(string, 0x0, sizeof(string));
		if((index+1) > dwRoutingRulelist_count)
			real_index = dwRoutingRulelist_count;
		else
			real_index = index;

		if(dwRoutingRulelist[real_index][0]) {
			if((vstrsep(dwRoutingRulelist[real_index], ">", &sourceIp, &destIp, &wanUnit) != 3)) break;
			sprintf(string, "%s>%s>%s", sourceIpStr, destIp, wanUnit);
		}
		else
			sprintf(string, "%s>>", sourceIpStr);	
		strcpy(dwRoutingRulelist[real_index], string);
             	
		//Re-generate wans_routing_rulelist
		for(i = 0; i < MAXROUTINGRULES; i++)
		{
			char entry_str[MAXROUTINGSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(dwRoutingRulelist[i][0]) {
				sprintf(entry_str, "<%s", dwRoutingRulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("wans_routing_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwDestinationIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    static struct in_addr addr;
    static long index, real_index;
    char dwRoutingRulelist[MAXROUTINGRULES][MAXROUTINGSTRNUM];
    int i, dwRoutingRulelist_count = 0;
    char *nv, *nvp, *b, *sourceIp, *destIp, *wanUnit;
    char destIpStr[32];
    char string[MAXROUTINGSTRNUM];

    for(i = 0; i < MAXROUTINGRULES; i++)
    	memset(dwRoutingRulelist[i], 0x0, MAXROUTINGSTRNUM);
    
    index = name[name_len-1] - 1;

    //Compute the number of wans_routing_rulelist
    nv = nvp = strdup(nmp_safe_get("wans_routing_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(dwRoutingRulelist[dwRoutingRulelist_count], b);
		dwRoutingRulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to dwDestinationIP not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to dwDestinationIP: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
         	memset(destIpStr, 0, sizeof(destIpStr));
             	addr.s_addr = value;
             	strcpy(destIpStr, (char *)inet_ntoa(addr)); 

		memset(string, 0x0, sizeof(string));
		if((index+1) > dwRoutingRulelist_count)
			real_index = dwRoutingRulelist_count;
		else
			real_index = index;

		if(dwRoutingRulelist[real_index][0]) {
			if((vstrsep(dwRoutingRulelist[real_index], ">", &sourceIp, &destIp, &wanUnit) != 3)) break;
			sprintf(string, "%s>%s>%s", sourceIp, destIpStr, wanUnit);
		}
		else
			sprintf(string, ">%s>", destIpStr);	
		strcpy(dwRoutingRulelist[real_index], string);
             	
		//Re-generate wans_routing_rulelist
		for(i = 0; i < MAXROUTINGRULES; i++)
		{
			char entry_str[MAXROUTINGSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(dwRoutingRulelist[i][0]) {
				sprintf(entry_str, "<%s", dwRoutingRulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("wans_routing_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwWANUnit(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index, real_index;
    char dwRoutingRulelist[MAXROUTINGRULES][MAXROUTINGSTRNUM];
    int i, dwRoutingRulelist_count = 0;
    char *nv, *nvp, *b, *sourceIp, *destIp, *wanUnit;
    char wanUnitStr[20];
    char string[MAXROUTINGSTRNUM];

    for(i = 0; i < MAXROUTINGRULES; i++)
    	memset(dwRoutingRulelist[i], 0x0, MAXROUTINGSTRNUM);
    
    value = *(long *) var_val;
    index = name[name_len-1] - 1;

    //Compute the number of wans_routing_rulelist
    nv = nvp = strdup(nmp_safe_get("wans_routing_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(dwRoutingRulelist[dwRoutingRulelist_count], b);
		dwRoutingRulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwWANUnit not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwWANUnit: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to dwWANUnit: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		if(value == 1)
			sprintf(wanUnitStr, "0");
		else if(value == 2)
			sprintf(wanUnitStr, "1");
             	
		memset(string, 0x0, sizeof(string));
		if((index+1) > dwRoutingRulelist_count)
			real_index = dwRoutingRulelist_count;
		else
			real_index = index;

		if(dwRoutingRulelist[real_index][0]) {
			if((vstrsep(dwRoutingRulelist[real_index], ">", &sourceIp, &destIp, &wanUnit) != 3)) break;
			sprintf(string, "%s>%s>%s", sourceIp, destIp, wanUnitStr);
		}
		else
			sprintf(string, ">>%s", wanUnitStr);	
		strcpy(dwRoutingRulelist[real_index], string);
             	
		//Re-generate wans_routing_rulelist
		for(i = 0; i < MAXROUTINGRULES; i++)
		{
			char entry_str[MAXROUTINGSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(dwRoutingRulelist[i][0]) {
				sprintf(entry_str, "<%s", dwRoutingRulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("wans_routing_rulelist", tmpstr);	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dwRoutingRuleDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index, real_index;
    char dwRoutingRulelist[MAXROUTINGRULES][MAXROUTINGSTRNUM];
    int i, dwRoutingRulelist_count = 0;
    char *nv, *nvp, *b, *sourceIp, *destIp, *wanUnit;

    for(i = 0; i < MAXROUTINGRULES; i++)
    	memset(dwRoutingRulelist[i], 0x0, MAXROUTINGSTRNUM);
    
    value = *(long *) var_val;
    index = name[name_len-1] - 1;

    //Compute the number of wans_routing_rulelist
    nv = nvp = strdup(nmp_safe_get("wans_routing_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(dwRoutingRulelist[dwRoutingRulelist_count], b);
		dwRoutingRulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dwRoutingRuleDelEntry not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dwRoutingRuleDelEntry: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to dwRoutingRuleDelEntry: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < dwRoutingRulelist_count)
             {
        	memset(dwRoutingRulelist[index], 0x0, MAXROUTINGSTRNUM);

		//Re-generate wans_routing_rulelist
		for(i = 0; i < MAXROUTINGRULES; i++)
		{
			char entry_str[MAXROUTINGSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(dwRoutingRulelist[i][0]) {
				sprintf(entry_str, "<%s", dwRoutingRulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("wans_routing_rulelist", tmpstr);
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_portTriggerDescription(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char autofw_rulelist[MAXPORTTRIGGER][PORTTRIGGERSTRNUM];
    int i, autofw_rulelist_count = 0;
    char *nv, *nvp, *b, *desc, *triggerPort, *triggerProto, *incomingPort, *incomingProto;
    char descStr[20];
    char string[PORTTRIGGERSTRNUM];

    for(i = 0; i < MAXPORTTRIGGER; i++)
    	memset(autofw_rulelist[i], 0x0, PORTTRIGGERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("autofw_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(autofw_rulelist[autofw_rulelist_count], b);
		autofw_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 18 ) {
              fprintf(stderr, "write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	memset(descStr, 0, sizeof(descStr));
             	strncpy(descStr, (u_char *)var_val, var_val_len); 

		memset(string, 0x0, sizeof(string));
		if((index+1) > autofw_rulelist_count)
			real_index = autofw_rulelist_count;
		else
			real_index = index;

		if(autofw_rulelist[real_index][0]) {
			if((vstrsep(autofw_rulelist[real_index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", descStr, triggerPort, triggerProto, incomingPort, incomingProto);
		}
		else
			sprintf(string, "%s>>>>", descStr);	
		strcpy(autofw_rulelist[real_index], string);
             	
		//Re-generate autofw_rulelist
		for(i = 0; i < MAXPORTTRIGGER; i++)
		{
			char entry_str[PORTTRIGGERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(autofw_rulelist[i][0]) {
				sprintf(entry_str, "<%s", autofw_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("autofw_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portTriggerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char autofw_rulelist[MAXPORTTRIGGER][PORTTRIGGERSTRNUM];
    int i, autofw_rulelist_count = 0;
    char *nv, *nvp, *b, *desc, *triggerPort, *triggerProto, *incomingPort, *incomingProto;
    char triggerPortStr[16];
    char string[PORTTRIGGERSTRNUM];

    for(i = 0; i < MAXPORTTRIGGER; i++)
    	memset(autofw_rulelist[i], 0x0, PORTTRIGGERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("autofw_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(autofw_rulelist[autofw_rulelist_count], b);
		autofw_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 11 ) {
              fprintf(stderr, "write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	memset(triggerPortStr, 0, sizeof(triggerPortStr));
             	strncpy(triggerPortStr, (u_char *)var_val, var_val_len); 

		memset(string, 0x0, sizeof(string));
		if((index+1) > autofw_rulelist_count)
			real_index = autofw_rulelist_count;
		else
			real_index = index;

		if(autofw_rulelist[real_index][0]) {
			if((vstrsep(autofw_rulelist[real_index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", desc, triggerPortStr, triggerProto, incomingPort, incomingProto);
		}
		else
			sprintf(string, ">%s>>>", triggerPortStr);	
		strcpy(autofw_rulelist[real_index], string);
             	
		//Re-generate autofw_rulelist
		for(i = 0; i < MAXPORTTRIGGER; i++)
		{
			char entry_str[PORTTRIGGERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(autofw_rulelist[i][0]) {
				sprintf(entry_str, "<%s", autofw_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("autofw_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portTriggerProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char autofw_rulelist[MAXPORTTRIGGER][PORTTRIGGERSTRNUM];
    int i, autofw_rulelist_count = 0;
    char *nv, *nvp, *b, *desc, *triggerPort, *triggerProto, *incomingPort, *incomingProto;
    int triggerProtoInt;
    char triggerPrototr[8];
    char string[PORTTRIGGERSTRNUM];

    for(i = 0; i < MAXPORTTRIGGER; i++)
    	memset(autofw_rulelist[i], 0x0, PORTTRIGGERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("autofw_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(autofw_rulelist[autofw_rulelist_count], b);
		autofw_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		triggerProtoInt = *(u_long *)var_val;
		if(triggerProtoInt == 1)
			sprintf(triggerPrototr, "TCP");
		else if(triggerProtoInt == 2)
			sprintf(triggerPrototr, "UDP");
             	
		memset(string, 0x0, sizeof(string));
		if((index+1) > autofw_rulelist_count)
			real_index = autofw_rulelist_count;
		else
			real_index = index;

		if(autofw_rulelist[real_index][0]) {
			if((vstrsep(autofw_rulelist[real_index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", desc, triggerPort, triggerPrototr, incomingPort, incomingProto);
		}
		else
			sprintf(string, ">>%s>>", triggerPrototr);	
		strcpy(autofw_rulelist[real_index], string);
             	
		//Re-generate autofw_rulelist
		for(i = 0; i < MAXPORTTRIGGER; i++)
		{
			char entry_str[PORTTRIGGERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(autofw_rulelist[i][0]) {
				sprintf(entry_str, "<%s", autofw_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("autofw_rulelist", tmpstr);	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portTriggerIncomingPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char autofw_rulelist[MAXPORTTRIGGER][PORTTRIGGERSTRNUM];
    int i, autofw_rulelist_count = 0;
    char *nv, *nvp, *b, *desc, *triggerPort, *triggerProto, *incomingPort, *incomingProto;
    char incomingPortStr[16];
    char string[PORTTRIGGERSTRNUM];

    for(i = 0; i < MAXPORTTRIGGER; i++)
    	memset(autofw_rulelist[i], 0x0, PORTTRIGGERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("autofw_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(autofw_rulelist[autofw_rulelist_count], b);
		autofw_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 11 ) {
              fprintf(stderr, "write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	memset(incomingPortStr, 0, sizeof(incomingPortStr));
             	strncpy(incomingPortStr, (u_char *)var_val, var_val_len); 

		memset(string, 0x0, sizeof(string));
		if((index+1) > autofw_rulelist_count)
			real_index = autofw_rulelist_count;
		else
			real_index = index;

		if(autofw_rulelist[real_index][0]) {
			if((vstrsep(autofw_rulelist[real_index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", desc, triggerPort, triggerProto, incomingPortStr, incomingProto);
		}
		else
			sprintf(string, ">>>%s>", incomingPortStr);	
		strcpy(autofw_rulelist[real_index], string);
             	
		//Re-generate autofw_rulelist
		for(i = 0; i < MAXPORTTRIGGER; i++)
		{
			char entry_str[PORTTRIGGERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(autofw_rulelist[i][0]) {
				sprintf(entry_str, "<%s", autofw_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("autofw_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portTriggerIncomingProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char autofw_rulelist[MAXPORTTRIGGER][PORTTRIGGERSTRNUM];
    int i, autofw_rulelist_count = 0;
    char *nv, *nvp, *b, *desc, *triggerPort, *triggerProto, *incomingPort, *incomingProto;
    int incomingProtoInt;
    char incomingProtoStr[8];
    char string[PORTTRIGGERSTRNUM];

    for(i = 0; i < MAXPORTTRIGGER; i++)
    	memset(autofw_rulelist[i], 0x0, PORTTRIGGERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("autofw_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(autofw_rulelist[autofw_rulelist_count], b);
		autofw_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		incomingProtoInt = *(u_long *)var_val;
		if(incomingProtoInt == 1)
			sprintf(incomingProtoStr, "TCP");
		else if(incomingProtoInt == 2)
			sprintf(incomingProtoStr, "UDP");
             	
		memset(string, 0x0, sizeof(string));
		if((index+1) > autofw_rulelist_count)
			real_index = autofw_rulelist_count;
		else
			real_index = index;

		if(autofw_rulelist[real_index][0]) {
			if((vstrsep(autofw_rulelist[real_index], ">", &desc, &triggerPort, &triggerProto, &incomingPort, &incomingProto) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", desc, triggerPort, triggerProto, incomingPort, incomingProtoStr);
		}
		else
			sprintf(string, ">>>>%s", incomingProtoStr);	
		strcpy(autofw_rulelist[real_index], string);
             	
		//Re-generate autofw_rulelist
		for(i = 0; i < MAXPORTTRIGGER; i++)
		{
			char entry_str[PORTTRIGGERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(autofw_rulelist[i][0]) {
				sprintf(entry_str, "<%s", autofw_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("autofw_rulelist", tmpstr);	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portTriggerDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char autofw_rulelist[MAXPORTTRIGGER][PORTTRIGGERSTRNUM];
    int i, autofw_rulelist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXPORTTRIGGER; i++)
    	memset(autofw_rulelist[i], 0x0, PORTTRIGGERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] - 1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("autofw_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(autofw_rulelist[autofw_rulelist_count], b);
		autofw_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < autofw_rulelist_count)
             {
        	memset(autofw_rulelist[index], 0x0, PORTTRIGGERSTRNUM);

		//Re-generate autofw_rulelist
		for(i = 0; i < MAXPORTTRIGGER; i++)
		{
			char entry_str[PORTTRIGGERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(autofw_rulelist[i][0]) {
				sprintf(entry_str, "<%s", autofw_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("autofw_rulelist", tmpstr);
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portForwardingServiceName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char vts_rulelist[MAXPORTFORWARDING][PORTFORWARDINGSTRNUM];
    int i, vts_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *portRange, *localIP, *localPort, *protocol;
    char serviceNameStr[32];
    char string[PORTFORWARDINGSTRNUM];

    for(i = 0; i < MAXPORTFORWARDING; i++)
    	memset(vts_rulelist[i], 0x0, PORTFORWARDINGSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of vts_rulelist
    nv = nvp = strdup(nmp_safe_get("vts_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(vts_rulelist[vts_rulelist_count], b);
		vts_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 30 ) {
              fprintf(stderr, "write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(serviceNameStr, 0x0, sizeof(serviceNameStr));
            strncpy(serviceNameStr, (u_char *)var_val, var_val_len); 

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > vts_rulelist_count)
    			real_index = vts_rulelist_count;
    		else
    			real_index = index;

    		if(vts_rulelist[real_index][0]) {
    			if((vstrsep(vts_rulelist[real_index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
    			sprintf(string, "%s>%s>%s>%s>%s", serviceNameStr, portRange, localIP, localPort, protocol);
    		}
    		else
    			sprintf(string, "%s>>>>", serviceNameStr);	
            
    		strcpy(vts_rulelist[real_index], string);
                 	
    		//Re-generate vts_rulelist
    		for(i = 0; i < MAXPORTFORWARDING; i++)
    		{
    			char entry_str[PORTFORWARDINGSTRNUM];
    			memset(entry_str, 0x0, PORTFORWARDINGSTRNUM);
    			if(vts_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", vts_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("vts_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portForwardingPortRange(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char vts_rulelist[MAXPORTFORWARDING][PORTFORWARDINGSTRNUM];
    int i, vts_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *portRange, *localIP, *localPort, *protocol;
    char portRangeStr[32];
    char string[PORTFORWARDINGSTRNUM];

    for(i = 0; i < MAXPORTFORWARDING; i++)
    	memset(vts_rulelist[i], 0x0, PORTFORWARDINGSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of vts_rulelist
    nv = nvp = strdup(nmp_safe_get("vts_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(vts_rulelist[vts_rulelist_count], b);
		vts_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	memset(portRangeStr, 0, sizeof(portRangeStr));
             	strncpy(portRangeStr, (u_char *)var_val, var_val_len); 

		memset(string, 0x0, sizeof(string));
		if((index+1) > vts_rulelist_count)
			real_index = vts_rulelist_count;
		else
			real_index = index;

		if(vts_rulelist[real_index][0]) {
			if((vstrsep(vts_rulelist[real_index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", serviceName, portRangeStr, localIP, localPort, protocol);
		}
		else
			sprintf(string, ">%s>>>", portRangeStr);	
		strcpy(vts_rulelist[real_index], string);
             	
		//Re-generate vts_rulelist
		for(i = 0; i < MAXPORTFORWARDING; i++)
		{
			char entry_str[PORTFORWARDINGSTRNUM];
			memset(entry_str, 0x0, PORTFORWARDINGSTRNUM);
			if(vts_rulelist[i][0]) {
				sprintf(entry_str, "<%s", vts_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("vts_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portForwardingLocalIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    static struct in_addr addr;
    char vts_rulelist[MAXPORTFORWARDING][PORTFORWARDINGSTRNUM];
    int i, vts_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *portRange, *localIP, *localPort, *protocol;
    char localIPStr[32];
    char string[PORTFORWARDINGSTRNUM];

    for(i = 0; i < MAXPORTFORWARDING; i++)
    	memset(vts_rulelist[i], 0x0, PORTFORWARDINGSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of vts_rulelist
    nv = nvp = strdup(nmp_safe_get("vts_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(vts_rulelist[vts_rulelist_count], b);
		vts_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
         	memset(localIPStr, 0, sizeof(localIPStr));
             	tmpval_u = *(u_long *)var_val;
             	addr.s_addr = tmpval_u;
             	strcpy(localIPStr, (char *)inet_ntoa(addr)); 

		memset(string, 0x0, sizeof(string));
		if((index+1) > vts_rulelist_count)
			real_index = vts_rulelist_count;
		else
			real_index = index;

		if(vts_rulelist[real_index][0]) {
			if((vstrsep(vts_rulelist[real_index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", serviceName, portRange, localIPStr, localPort, protocol);
		}
		else
			sprintf(string, ">>%s>>", localIPStr);	
		strcpy(vts_rulelist[real_index], string);
             	
		//Re-generate vts_rulelist
		for(i = 0; i < MAXPORTFORWARDING; i++)
		{
			char entry_str[PORTFORWARDINGSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(vts_rulelist[i][0]) {
				sprintf(entry_str, "<%s", vts_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("vts_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portForwardingLocalPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char vts_rulelist[MAXPORTFORWARDING][PORTFORWARDINGSTRNUM];
    int i, vts_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *portRange, *localIP, *localPort, *protocol;
    int localPortInt;
    char localPortStr[8];
    char string[PORTFORWARDINGSTRNUM];

    for(i = 0; i < MAXPORTFORWARDING; i++)
    	memset(vts_rulelist[i], 0x0, PORTFORWARDINGSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of vts_rulelist
    nv = nvp = strdup(nmp_safe_get("vts_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(vts_rulelist[vts_rulelist_count], b);
		vts_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		localPortInt = *(u_long *)var_val;
		sprintf(localPortStr, "%d", localPortInt);

		memset(string, 0x0, sizeof(string));
		if((index+1) > vts_rulelist_count)
			real_index = vts_rulelist_count;
		else
			real_index = index;

		if(vts_rulelist[real_index][0]) {
			if((vstrsep(vts_rulelist[real_index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", serviceName, portRange, localIP, localPortStr, protocol);
		}
		else
			sprintf(string, ">>>%s>", localPortStr);	
		strcpy(vts_rulelist[real_index], string);
             	
		//Re-generate vts_rulelist
		for(i = 0; i < MAXPORTFORWARDING; i++)
		{
			char entry_str[PORTFORWARDINGSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(vts_rulelist[i][0]) {
				sprintf(entry_str, "<%s", vts_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("vts_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portForwardingProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char vts_rulelist[MAXPORTFORWARDING][PORTFORWARDINGSTRNUM];
    int i, vts_rulelist_count = 0;
    char *nv, *nvp, *b, *serviceName, *portRange, *localIP, *localPort, *protocol;
    int protocolInt;
    char protocolStr[8];
    char string[PORTFORWARDINGSTRNUM];

    for(i = 0; i < MAXPORTFORWARDING; i++)
    	memset(vts_rulelist[i], 0x0, PORTFORWARDINGSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of vts_rulelist
    nv = nvp = strdup(nmp_safe_get("vts_rulelist"));
    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(vts_rulelist[vts_rulelist_count], b);
            vts_rulelist_count++;	
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
    		protocolInt = *(u_long *)var_val;
    		if(protocolInt == 1)
    			sprintf(protocolStr, "TCP");
    		else if(protocolInt == 2)
    			sprintf(protocolStr, "UDP");
    		else if(protocolInt == 3)
    			sprintf(protocolStr, "BOTH");
    		else if(protocolInt == 4)
    			sprintf(protocolStr, "OTHER");

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > vts_rulelist_count)
    			real_index = vts_rulelist_count;
    		else
    			real_index = index;

    		if(vts_rulelist[real_index][0]) {
    			if((vstrsep(vts_rulelist[real_index], ">", &serviceName, &portRange, &localIP, &localPort, &protocol) != 5)) break;
    			sprintf(string, "%s>%s>%s>%s>%s", serviceName, portRange, localIP, localPort, protocolStr);
    		}
    		else
    			sprintf(string, ">>>>%s", protocolStr);	
    		strcpy(vts_rulelist[real_index], string);
                 	
    		//Re-generate vts_rulelist
    		for(i = 0; i < MAXPORTFORWARDING; i++)
    		{
    			char entry_str[PORTFORWARDINGSTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(vts_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", vts_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("vts_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portForwardingDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char vts_rulelist[MAXPORTFORWARDING][PORTFORWARDINGSTRNUM];
    int i, vts_rulelist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXPORTFORWARDING; i++)
    	memset(vts_rulelist[i], 0x0, PORTFORWARDINGSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] -1;

    //Compute the number of vts_rulelist
    nv = nvp = strdup(nmp_safe_get("vts_rulelist"));
    if (nv) {
	   while ((b = strsep(&nvp, "<")) != NULL) {
	       if (strlen(b)==0) continue;
		  strcpy(vts_rulelist[vts_rulelist_count], b);
		  vts_rulelist_count++;		
	   }
	   free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to wan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < vts_rulelist_count)
             {
                memset(vts_rulelist[index], 0x0, PORTFORWARDINGSTRNUM);
    
                //Re-generate vts_rulelist
                for(i = 0; i < MAXPORTFORWARDING; i++)
                {
                    char entry_str[PORTFORWARDINGSTRNUM];
                    memset(entry_str, 0x0, PORTFORWARDINGSTRNUM);
                    if(vts_rulelist[i][0]) {
                        sprintf(entry_str, "<%s", vts_rulelist[i]);
                        strcat(tmpstr, entry_str);
                    }
                }

                nmp_set("vts_rulelist", tmpstr);
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
