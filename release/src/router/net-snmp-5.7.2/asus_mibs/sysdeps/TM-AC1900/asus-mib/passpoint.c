/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 17716 2009-08-04 21:35:34Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "passpoint.h"
#include <nmp.h>

#define MAXWEPKEY       4 /* Maximum number of wep key */
#define MACSTRNUM       18

static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;

/* 
 * passpoint_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid passpoint_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,2 };

/* 
 * variable7 passpoint_variables:
 *   this variable defines function callbacks and type return information 
 *   for the passpoint mib section 
 */

struct variable7 passpoint_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define ENABLEPPT2G             1
{ENABLEPPT2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,1 }},
#define SSIDPPT2G               2
{SSIDPPT2G,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,2 }},
#define AUTHENTICATIONPPT2G             3
{AUTHENTICATIONPPT2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,3 }},
#define WEPENCRYPTIONPPT2G              4
{WEPENCRYPTIONPPT2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,4 }},
#define KEYINDEXPPT2G           5
{KEYINDEXPPT2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,5 }},
#define WPAENCRYPTIONPPT2G              6
{WPAENCRYPTIONPPT2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,8 }},
#define WPAPRESHAREDKEYPPT2G            7
{WPAPRESHAREDKEYPPT2G,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,9 }},
#define ACCESSINTRANETPPT2G             8
{ACCESSINTRANETPPT2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,10 }},
#define ENABLEMACFILTERPPT2G            9
{ENABLEMACFILTERPPT2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,1,11 }},
#define PPTNETWORKTYPE2G                10
{PPTNETWORKTYPE2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,2,1 }},
#define PPT2GSTATUS             11
{PPT2GSTATUS,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_passpoint, 3,  { 1,2,2 }},
#define PPT2GMAXUSERS           12
{PPT2GMAXUSERS,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,2,7 }},
#define PPT2GRADIUSSERVER               13
{PPT2GRADIUSSERVER,  ASN_IPADDRESS,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,2,8 }},
#define PPT2GRADIUSPORT         14
{PPT2GRADIUSPORT,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,2,9 }},
#define PPT2GRADIUSKEY          15
{PPT2GRADIUSKEY,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,2,10 }},
#define PPT2GRADIUSTMOSERVER            16
{PPT2GRADIUSTMOSERVER,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,2,11 }},
#define PPT2GRADIUSTMOPORT              17
{PPT2GRADIUSTMOPORT,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 1,2,12 }},
#define ENABLEPPT5G             18
{ENABLEPPT5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,1 }},
#define SSIDPPT5G               19
{SSIDPPT5G,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,2 }},
#define AUTHENTICATIONPPT5G             20
{AUTHENTICATIONPPT5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,3 }},
#define WEPENCRYPTIONPPT5G              21
{WEPENCRYPTIONPPT5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,4 }},
#define KEYINDEXPPT5G           22
{KEYINDEXPPT5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,5 }},
#define WPAENCRYPTIONPPT5G              23
{WPAENCRYPTIONPPT5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,8 }},
#define WPAPRESHAREDKEYPPT5G            24
{WPAPRESHAREDKEYPPT5G,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,9 }},
#define ACCESSINTRANETPPT5G             25
{ACCESSINTRANETPPT5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,10 }},
#define ENABLEMACFILTERPPT5G            26
{ENABLEMACFILTERPPT5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,1,11 }},
#define PPTNETWORKTYPE5G                27
{PPTNETWORKTYPE5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,2,1 }},
#define PPT5GSTATUS             28
{PPT5GSTATUS,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_passpoint, 3,  { 2,2,2 }},
#define PPT5GMAXUSERS           29
{PPT5GMAXUSERS,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,2,7 }},
#define PPT5GRADIUSSERVER               30
{PPT5GRADIUSSERVER,  ASN_IPADDRESS,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,2,8 }},
#define PPT5GRADIUSPORT         31
{PPT5GRADIUSPORT,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,2,9 }},
#define PPT5GRADIUSKEY          32
{PPT5GRADIUSKEY,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,2,10 }},
#define PPT5GRADIUSTMOSERVER            33
{PPT5GRADIUSTMOSERVER,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,2,11 }},
#define PPT5GRADIUSTMOPORT              34
{PPT5GRADIUSTMOPORT,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_passpoint, 3,  { 2,2,12 }},

#define WEPKEYINDEXPPT2G                35
{WEPKEYINDEXPPT2G,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_generalPpt2gWepKeyTable, 5,  { 1,1,6, 1, 1 }},
#define WEPKEYVALUEPPT2G                36
{WEPKEYVALUEPPT2G,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_generalPpt2gWepKeyTable, 5,  { 1,1,6, 1, 2 }},
#define PPT2GOUIINDEX           37
{PPT2GOUIINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ppt2gOuiTable, 5,  { 1,2,3, 1, 1 }},
#define PPT2GOUINAME            38
{PPT2GOUINAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ppt2gOuiTable, 5,  { 1,2,3, 1, 2 }},
#define PPT2GDOMAININDEX                39
{PPT2GDOMAININDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ppt2gDomainTable, 5,  { 1,2,4, 1, 1 }},
#define PPT2GDOMAINNAME         40
{PPT2GDOMAINNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ppt2gDomainTable, 5,  { 1,2,4, 1, 2 }},
#define PPT2GREALMINDEX         41
{PPT2GREALMINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ppt2gRealmTable, 5,  { 1,2,5, 1, 1 }},
#define PPT2GREALMNAME          42
{PPT2GREALMNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ppt2gRealmTable, 5,  { 1,2,5, 1, 2 }},
#define PPT2G3GPPINDEX          43
{PPT2G3GPPINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ppt2g3gppTable, 5,  { 1,2,6, 1, 1 }},
#define PPT2G3GPPNAME           44
{PPT2G3GPPNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ppt2g3gppTable, 5,  { 1,2,6, 1, 2 }},
#define WEPKEYINDEXPPT5G                45
{WEPKEYINDEXPPT5G,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_generalPpt5gWepKeyTable, 5,  { 2,1,6, 1, 1 }},
#define WEPKEYVALUEPPT5G                46
{WEPKEYVALUEPPT5G,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_generalPpt5gWepKeyTable, 5,  { 2,1,6, 1, 2 }},
#define PPT5GOUIINDEX           47
{PPT5GOUIINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ppt5gOuiTable, 5,  { 2,2,3, 1, 1 }},
#define PPT5GOUINAME            48
{PPT5GOUINAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ppt5gOuiTable, 5,  { 2,2,3, 1, 2 }},
#define PPT5GDOMAININDEX                49
{PPT5GDOMAININDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ppt5gDomainTable, 5,  { 2,2,4, 1, 1 }},
#define PPT5GDOMAINNAME         50
{PPT5GDOMAINNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ppt5gDomainTable, 5,  { 2,2,4, 1, 2 }},
#define PPT5GREALMINDEX         51
{PPT5GREALMINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ppt5gRealmTable, 5,  { 2,2,5, 1, 1 }},
#define PPT5GREALMNAME          52
{PPT5GREALMNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ppt5gRealmTable, 5,  { 2,2,5, 1, 2 }},
#define PPT5G3GPPINDEX          53
{PPT5G3GPPINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ppt5g3gppTable, 5,  { 2,2,6, 1, 1 }},
#define PPT5G3GPPNAME           54
{PPT5G3GPPNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ppt5g3gppTable, 5,  { 2,2,6, 1, 2 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the passpoint module */
void
init_passpoint(void)
{

    DEBUGMSGTL(("passpoint", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("passpoint", passpoint_variables, variable7,
               passpoint_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_passpoint():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_passpoint(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    /* 
     * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {
    case ENABLEPPT2G:
        *write_method = write_enablePpt2g;
        if(nmp_safe_get("wl0.3_hs2en")!=NULL)
                {
                        if(!strcmp(nmp_get("wl0.3_hs2en"), "1")) /* enable */
                                tmpval = 1;
                        else if(!strcmp(nmp_get("wl0.3_hs2en"), "0")) /* disable */
                                tmpval = 2;
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case SSIDPPT2G:
        *write_method = write_ssidPpt2g;
        if(nmp_safe_get("wl0.3_ssid")!=NULL)
                {
                        strcpy(tmpstr, nmp_get("wl0.3_ssid"));
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case AUTHENTICATIONPPT2G:
        *write_method = write_authenticationPpt2g;
        if(nmp_safe_get("wl0.3_auth_mode_x") != NULL)
        {
                        if(!strcmp(nmp_get("wl0.3_auth_mode_x"), "open")) /* open system */
                                tmpval = 1;
                        else if(!strcmp(nmp_get("wl0.3_auth_mode_x"), "shared")) /* shared key */
                                tmpval = 2;
                        else if(!strcmp(nmp_get("wl0.3_auth_mode_x"), "psk")) /* wpa personal */
                                tmpval = 3;
                        else if(!strcmp(nmp_get("wl0.3_auth_mode_x"), "psk2")) /* wpa2 personal */
                                tmpval = 4;
                        else if(!strcmp(nmp_get("wl0.3_auth_mode_x"), "pskpsk2")) /* wpa auto personal */
                                tmpval = 5;
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case WEPENCRYPTIONPPT2G:
        *write_method = write_wepEncryptionPpt2g;
        if(nmp_safe_get("wl0.3_wep_x") != NULL)
        {
                        tmpval = nmp_get_int("wl0.3_wep_x");
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case KEYINDEXPPT2G:
        *write_method = write_keyIndexPpt2g;
        if(strlen(nmp_safe_get("wl0.3_key")))
        {
                        tmpval = nmp_get_int("wl0.3_key");
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
#if 0
    case PASSPHRASEPPT2G:
        *write_method = write_passphrasePpt2g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl0.3_phrase_x") != NULL)
        {
                        strcpy(tmpstr, nmp_safe_get("wl0.3_phrase_x"));
                        tmpstr[strlen(tmpstr)] = '\0';
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
        }
        return NULL;
#endif
    case WPAENCRYPTIONPPT2G:
        *write_method = write_wpaEncryptionPpt2g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        tmpval = 0;
        if(nmp_safe_get("wl0.3_crypto") != NULL)
        {
                        strcpy(tmpstr, nmp_safe_get("wl0.3_crypto"));
                        if(!strcmp(tmpstr, "aes")) /* aes */
                                tmpval = 1;
                        else if(!strcmp(tmpstr,"tkip+aes")) /* TKIP+AES */
                                tmpval = 2;

                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case WPAPRESHAREDKEYPPT2G:
        *write_method = write_wpaPreSharedKeyPpt2g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl0.3_wpa_psk") != NULL)
        {
                        strcpy(tmpstr, nmp_safe_get("wl0.3_wpa_psk"));
                        tmpstr[strlen(tmpstr)] = '\0';
                        *var_len = strlen( tmpstr );
                        return ( u_char * ) tmpstr;
        }
        return NULL;
    case ACCESSINTRANETPPT2G:
        *write_method = write_accessIntranetPpt2g;
        if(nmp_safe_get("wl0.3_lanaccess")!=NULL)
                {
                        if(!strcmp(nmp_get("wl0.3_lanaccess"), "on")) /* enable */
                                tmpval = 1;
                        else if(!strcmp(nmp_get("wl0.3_lanaccess"), "off")) /* disable */
                                tmpval = 2;
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case ENABLEMACFILTERPPT2G:
        *write_method = write_enableMacFilterPpt2g;
        if(nmp_safe_get("wl0.3_macmode")!=NULL)
                {
                        if(!strcmp(nmp_get("wl0.3_macmode"), "")) /* enable */
                                tmpval = 1;
                        else if(!strcmp(nmp_get("wl0.3_macmode"), "disabled")) /* disable */
                                tmpval = 2;
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case PPTNETWORKTYPE2G:
        *write_method = write_pptNetworkType2g;
        if(nmp_safe_get("wl0.3_iwnettype")!=NULL)
                {
                        tmpval = nmp_get_int("wl0.3_iwnettype");
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case PPT2GSTATUS:
	memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl0_hs2en")!=NULL)
                {
                        tmpval = nmp_get_int("wl0_hs2en");
			if(tmpval == 1)
				strcpy(tmpstr, "ON");
			else
				strcpy(tmpstr, "OFF");
                        tmpstr[strlen(tmpstr)] = '\0';
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case PPT2GMAXUSERS:
        *write_method = write_ppt2gMaxUsers;
        if(nmp_safe_get("wl0.3_maxassoc")!=NULL)
                {
                        tmpval = nmp_get_int("wl0.3_maxassoc");
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case PPT2GRADIUSSERVER:
        *write_method = write_ppt2gRadiusServer;
        if(nmp_safe_get("wl0.3_radius_ipaddr") != NULL)
                {
                        tmpval_u = inet_addr(nmp_safe_get("wl0.3_radius_ipaddr"));
                        *var_len = sizeof( unsigned long );
                        return ( u_char * ) &tmpval_u;
                }
        return NULL;
    case PPT2GRADIUSPORT:
        *write_method = write_ppt2gRadiusPort;
        if(nmp_safe_get("wl0.3_radius_port") != NULL)
        {
                        tmpval = atoi(nmp_get("wl0.3_radius_port"));
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case PPT2GRADIUSKEY:
        *write_method = write_ppt2gRadiusKey;
        if(nmp_safe_get("wl0.3_radius_key") != NULL)
                {
                        strcpy(tmpstr, nmp_get("wl0.3_radius_key"));
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case PPT2GRADIUSTMOSERVER:
        *write_method = write_ppt2gRadiusTmoServer;
        if(nmp_safe_get("wl0.3_tmo_radius_ipaddr") != NULL)
                {
                        strcpy(tmpstr, nmp_get("wl0.3_tmo_radius_ipaddr"));
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case PPT2GRADIUSTMOPORT:
        *write_method = write_ppt2gRadiusTmoPort;
        if(nmp_safe_get("wl0.3_tmo_radius_port") != NULL)
        {
                        tmpval = atoi(nmp_get("wl0.3_tmo_radius_port"));
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case ENABLEPPT5G:
        *write_method = write_enablePpt5g;
        if(nmp_safe_get("wl1.3_hs2en")!=NULL)
                {
                        if(!strcmp(nmp_get("wl1.3_hs2en"), "1")) /* enable */
                                tmpval = 1;
                        else if(!strcmp(nmp_get("wl1.3_hs2en"), "0")) /* disable */
                                tmpval = 2;
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case SSIDPPT5G:
        *write_method = write_ssidPpt5g;
        if(nmp_safe_get("wl1.3_ssid")!=NULL)
                {
                        strcpy(tmpstr, nmp_get("wl1.3_ssid"));
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case AUTHENTICATIONPPT5G:
        *write_method = write_authenticationPpt5g;
        if(nmp_safe_get("wl1.3_auth_mode_x") != NULL)
        {
                        if(!strcmp(nmp_get("wl1.3_auth_mode_x"), "open")) /* open system */
                                tmpval = 1;
                        else if(!strcmp(nmp_get("wl1.3_auth_mode_x"), "shared")) /* shared key */
                                tmpval = 2;
                        else if(!strcmp(nmp_get("wl1.3_auth_mode_x"), "psk")) /* wpa personal */
                                tmpval = 3;
                        else if(!strcmp(nmp_get("wl1.3_auth_mode_x"), "psk2")) /* wpa2 personal */
                                tmpval = 4;
                        else if(!strcmp(nmp_get("wl1.3_auth_mode_x"), "pskpsk2")) /* wpa auto personal */
                                tmpval = 5;
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case WEPENCRYPTIONPPT5G:
        *write_method = write_wepEncryptionPpt5g;
        if(nmp_safe_get("wl1.3_wep_x") != NULL)
        {
                        tmpval = nmp_get_int("wl1.3_wep_x");
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case KEYINDEXPPT5G:
        *write_method = write_keyIndexPpt5g;
        if(strlen(nmp_safe_get("wl1.3_key")))
        {
                        tmpval = nmp_get_int("wl1.3_key");
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
#if 0
    case PASSPHRASEPPT5G:
        *write_method = write_passphrasePpt5g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl1.3_phrase_x") != NULL)
        {
                        strcpy(tmpstr, nmp_safe_get("wl1.3_phrase_x"));
                        tmpstr[strlen(tmpstr)] = '\0';
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
        }
        return NULL;
#endif
    case WPAENCRYPTIONPPT5G:
        *write_method = write_wpaEncryptionPpt5g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        tmpval = 0;
        if(nmp_safe_get("wl1.3_crypto") != NULL)
        {
                        strcpy(tmpstr, nmp_safe_get("wl1.3_crypto"));
                        if(!strcmp(tmpstr, "aes")) /* aes */
                                tmpval = 1;
                        else if(!strcmp(tmpstr,"tkip+aes")) /* TKIP+AES */
                                tmpval = 2;
        
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case WPAPRESHAREDKEYPPT5G:
        *write_method = write_wpaPreSharedKeyPpt5g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl1.3_wpa_psk") != NULL)
        {
                        strcpy(tmpstr, nmp_safe_get("wl1.3_wpa_psk"));
                        tmpstr[strlen(tmpstr)] = '\0';
                        *var_len = strlen( tmpstr );
                        return ( u_char * ) tmpstr;
        }
        return NULL;
    case ACCESSINTRANETPPT5G:
        *write_method = write_accessIntranetPpt5g;
        if(nmp_safe_get("wl1.3_lanaccess")!=NULL)
                {
                        if(!strcmp(nmp_get("wl1.3_lanaccess"), "on")) /* enable */
                                tmpval = 1;
                        else if(!strcmp(nmp_get("wl1.3_lanaccess"), "off")) /* disable */
                                tmpval = 2;
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case ENABLEMACFILTERPPT5G:
        *write_method = write_enableMacFilterPpt5g;
        if(nmp_safe_get("wl1.3_macmode")!=NULL)
                {
                        if(!strcmp(nmp_get("wl1.3_macmode"), "")) /* enable */
                                tmpval = 1;
                        else if(!strcmp(nmp_get("wl1.3_macmode"), "disabled")) /* disable */
                                tmpval = 2;
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case PPTNETWORKTYPE5G:
        *write_method = write_pptNetworkType5g;
        if(nmp_safe_get("wl1.3_iwnettype")!=NULL)
                {
                        tmpval = nmp_get_int("wl1.3_iwnettype");
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case PPT5GSTATUS:
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl1_hs2en")!=NULL)
                {
                        tmpval = nmp_get_int("wl1_hs2en");
                        if(tmpval == 1)
                                strcpy(tmpstr, "ON");
                        else
                                strcpy(tmpstr, "OFF");
                        tmpstr[strlen(tmpstr)] = '\0';
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case PPT5GMAXUSERS:
        *write_method = write_ppt5gMaxUsers;
        if(nmp_safe_get("wl1.3_maxassoc")!=NULL)
                {
                        tmpval = nmp_get_int("wl1.3_maxassoc");
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
                }
        return NULL;
    case PPT5GRADIUSSERVER:
        *write_method = write_ppt5gRadiusServer;
        if(nmp_safe_get("wl1.3_radius_ipaddr") != NULL)
                {
                        tmpval_u = inet_addr(nmp_safe_get("wl1.3_radius_ipaddr"));
                        *var_len = sizeof( unsigned long );
                        return ( u_char * ) &tmpval_u;
                }
        return NULL;
    case PPT5GRADIUSPORT:
        *write_method = write_ppt5gRadiusPort;
        if(nmp_safe_get("wl1.3_radius_port") != NULL)
        {
                        tmpval = atoi(nmp_get("wl1.3_radius_port"));
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    case PPT5GRADIUSKEY:
        *write_method = write_ppt5gRadiusKey;
        if(nmp_safe_get("wl1.3_radius_key") != NULL)
                {
                        strcpy(tmpstr, nmp_get("wl1.3_radius_key"));
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case PPT5GRADIUSTMOSERVER:
        *write_method = write_ppt5gRadiusTmoServer;
        if(nmp_safe_get("wl1.3_tmo_radius_ipaddr") != NULL)
                {
                        strcpy(tmpstr, nmp_get("wl1.3_tmo_radius_ipaddr"));
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case PPT5GRADIUSTMOPORT:
        *write_method = write_ppt5gRadiusTmoPort;
        if(nmp_safe_get("wl1.3_tmo_radius_port") != NULL)
        {
                        tmpval = atoi(nmp_get("wl1.3_tmo_radius_port"));
                        *var_len = sizeof( long );
                        return ( u_char * ) &tmpval;
        }
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_generalPpt2gWepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
unsigned char *
var_generalPpt2gWepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    unsigned char string[SPRINT_MAX_LEN];
    static long keyIndex;

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    memset(string, 0, SPRINT_MAX_LEN);

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXWEPKEY)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WEPKEYINDEXPPT2G:
	return NULL;
    case WEPKEYVALUEPPT2G:
        *write_method = write_wepKeyValuePpt2g;
        keyIndex = name[*length-1];
                sprintf(string, "wl0.3_key%d", keyIndex);
                string[strlen(string)] = '\0';
                if(nmp_safe_get(string) != NULL) {
                        strcpy(tmpstr, nmp_safe_get(string));
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_ppt2gOuiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
#define MAXOUILIST	4
#define MAXOUISTR	16
unsigned char *
var_ppt2gOuiTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char oui_list[MAXOUILIST][MAXOUISTR];
    int i, oui_list_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXOUILIST; i++)
        memset(oui_list[i], 0, MAXOUISTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);

    /* Compute the number of oui_list */
    nv = nvp = strdup(nmp_safe_get("wl0.3_ouilist"));
    if (nv) {
        while ((b = strsep(&nvp, ";")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(oui_list[oui_list_count], b);
                oui_list_count++;           
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXOUILIST)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PPT2GOUIINDEX:
	return NULL;
    case PPT2GOUINAME:
        *write_method = write_ppt2gOuiName;
        index = name[*length-1]-1;
        if(index <= oui_list_count-1) {
                if (strlen(oui_list[index])) {
                strcpy(tmpstr, oui_list[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_ppt2gDomainTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
#define MAXDOMAINTABLE	8
#define MAXDOMAINSTR	64
unsigned char *
var_ppt2gDomainTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char domain_tbl[MAXDOMAINTABLE][MAXDOMAINSTR];
    int i, domain_tbl_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXDOMAINTABLE; i++)
        memset(domain_tbl[i], 0, MAXDOMAINSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);

    /* Compute the number of domain_tbl */
    nv = nvp = strdup(nmp_safe_get("wl0.3_domainlist"));
    if (nv) {
        while ((b = strsep(&nvp, " ")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(domain_tbl[domain_tbl_count], b);
                domain_tbl_count++;
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXDOMAINTABLE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PPT2GDOMAININDEX:
	return NULL;
    case PPT2GDOMAINNAME:
        *write_method = write_ppt2gDomainName;
        index = name[*length-1]-1;
        if(index <= domain_tbl-1) {
                if (strlen(domain_tbl[index])) {
                strcpy(tmpstr, domain_tbl[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_ppt2gRealmTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
#define MAXREALMLIST	5
#define MAXREALMSTR	64
unsigned char *
var_ppt2gRealmTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char realm_list[MAXREALMLIST][MAXREALMSTR];
    int i, realm_list_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXREALMLIST; i++)
        memset(realm_list[i], 0, MAXREALMSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);

    /* Compute the number of realm_list */
    nv = nvp = strdup(nmp_safe_get("wl0.3_realmlist"));
    if (nv) {
        while ((b = strsep(&nvp, "?")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(realm_list[realm_list_count], b);
                realm_list_count++;
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXREALMLIST)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PPT2GREALMINDEX:
	return NULL;
    case PPT2GREALMNAME:
        *write_method = write_ppt2gRealmName;
        index = name[*length-1]-1;
        if(index <= realm_list_count-1) {
                if (strlen(realm_list[index])) {
                strcpy(tmpstr, realm_list[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_ppt2g3gppTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
#define MAX3GPPLIST	6
#define MAX3GPPSTR	11
unsigned char *
var_ppt2g3gppTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char cni_list[MAX3GPPLIST][MAX3GPPSTR];
    int i, cni_list_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAX3GPPLIST; i++)
        memset(cni_list[i], 0, MAX3GPPSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);

    /* Compute the number of cni_list */
    nv = nvp = strdup(nmp_safe_get("wl0.3_3gpplist"));
    if (nv) {
        while ((b = strsep(&nvp, ";")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(cni_list[cni_list_count], b);
                cni_list_count++;
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX3GPPLIST)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PPT2G3GPPINDEX:
	return NULL;
    case PPT2G3GPPNAME:		/* [country code]:[network code] */
        *write_method = write_ppt2g3gppName;
        index = name[*length-1]-1;
        if(index <= cni_list_count-1) {
                if (strlen(cni_list[index])) {
                strcpy(tmpstr, cni_list[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_generalPpt5gWepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
unsigned char *
var_generalPpt5gWepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    unsigned char string[SPRINT_MAX_LEN];
    static long keyIndex;

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    memset(string, 0, SPRINT_MAX_LEN);

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXWEPKEY)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WEPKEYINDEXPPT5G:
	return NULL;
    case WEPKEYVALUEPPT5G:
        *write_method = write_wepKeyValuePpt5g;
        keyIndex = name[*length-1];
                sprintf(string, "wl1.3_key%d", keyIndex);
                string[strlen(string)] = '\0';
                if(nmp_safe_get(string) != NULL) {
                        strcpy(tmpstr, nmp_safe_get(string));
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_ppt5gOuiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
unsigned char *
var_ppt5gOuiTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char oui_list[MAXOUILIST][MAXOUISTR];
    int i, oui_list_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXOUILIST; i++)
        memset(oui_list[i], 0, MAXOUISTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);

    /* Compute the number of oui_list */
    nv = nvp = strdup(nmp_safe_get("wl1.3_ouilist"));
    if (nv) {
        while ((b = strsep(&nvp, ";")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(oui_list[oui_list_count], b);
                oui_list_count++;
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXOUILIST)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PPT5GOUIINDEX:
	return NULL;
    case PPT5GOUINAME:
        *write_method = write_ppt5gOuiName;
        index = name[*length-1]-1;
        if(index <= oui_list_count-1) {
                if (strlen(oui_list[index])) {
                strcpy(tmpstr, oui_list[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_ppt5gDomainTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
unsigned char *
var_ppt5gDomainTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char domain_tbl[MAXDOMAINTABLE][MAXDOMAINSTR];
    int i, domain_tbl_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXDOMAINTABLE; i++)
        memset(domain_tbl[i], 0, MAXDOMAINSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);

    /* Compute the number of domain_tbl */
    nv = nvp = strdup(nmp_safe_get("wl1.3_domainlist"));
    if (nv) {
        while ((b = strsep(&nvp, " ")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(domain_tbl[domain_tbl_count], b);
                domain_tbl_count++;
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXDOMAINTABLE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PPT5GDOMAININDEX:
	return NULL;
    case PPT5GDOMAINNAME:
        *write_method = write_ppt5gDomainName;
        index = name[*length-1]-1;
        if(index <= domain_tbl-1) {
                if (strlen(domain_tbl[index])) {
                strcpy(tmpstr, domain_tbl[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_ppt5gRealmTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
unsigned char *
var_ppt5gRealmTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char realm_list[MAXREALMLIST][MAXREALMSTR];
    int i, realm_list_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXREALMLIST; i++)
        memset(realm_list[i], 0, MAXREALMSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);

    /* Compute the number of realm_list */
    nv = nvp = strdup(nmp_safe_get("wl1.3_realmlist"));
    if (nv) {
        while ((b = strsep(&nvp, "?")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(realm_list[realm_list_count], b);
                realm_list_count++;
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXREALMLIST)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PPT5GREALMINDEX:
	return NULL;
    case PPT5GREALMNAME:
        *write_method = write_ppt5gRealmName;
        index = name[*length-1]-1;
        if(index <= realm_list_count-1) {
                if (strlen(realm_list[index])) {
                strcpy(tmpstr, realm_list[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_ppt5g3gppTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_passpoint above.
 */
unsigned char *
var_ppt5g3gppTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char cni_list[MAX3GPPLIST][MAX3GPPSTR];
    int i, cni_list_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAX3GPPLIST; i++)
        memset(cni_list[i], 0, MAX3GPPSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);

    /* Compute the number of cni_list */
    nv = nvp = strdup(nmp_safe_get("wl1.3_3gpplist"));
    if (nv) {
        while ((b = strsep(&nvp, ";")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(cni_list[cni_list_count], b);
                cni_list_count++;
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX3GPPLIST)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PPT5G3GPPINDEX:
	return NULL;
    case PPT5G3GPPNAME:		/* [country code]:[network code] */
        *write_method = write_ppt5g3gppName;
        index = name[*length-1]-1;
        if(index <= cni_list_count-1) {
                if (strlen(cni_list[index])) {
                strcpy(tmpstr, cni_list[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_enablePpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to enablePpt2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                        nmp_set("wl0.3_hs2en", "1");
                else if(value == 2)
                        nmp_set("wl0.3_hs2en", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ssidPpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len <= 32) {
                strncpy(string, (u_char *)var_val, var_val_len);
                string[var_val_len] = '\0';
                nmp_set("wl0.3_ssid", string);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_authenticationPpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 5) {
              fprintf(stderr, "write to authenticationPpt2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 5) {
                switch(value)
                {
                        case 1:/* open system */
                                nmp_set("wl0.3_auth_mode_x", "open");
                                break;
                        case 2:/* shared key */
                                nmp_set("wl0.3_auth_mode_x", "shared");
                                break;
                        case 3: /* wpa personal */
                                nmp_set("wl0.3_auth_mode_x", "psk");
                                break;
                        case 4:/* wpa2 personal */
                                nmp_set("wl0.3_auth_mode_x", "psk2");
                                break;
                        case 5:/* wpa auto personal */
                                nmp_set("wl0.3_auth_mode_x", "pskpsk2");
                                break;
                }
	     }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wepEncryptionPpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wepEncryptionPpt2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 0 && value <= 2) {
		nmp_set_int("wl0.3_wep_x", value);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_keyIndexPpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to keyIndexPpt2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 4)
                nmp_set_int("wl0.3_key", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_passphrasePpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strncpy(string, (u_char *)var_val, var_val_len);
             string[var_val_len] = '\0';
             nmp_set("wl0.3_phrase_x", string);
             generateWepKey("0.3", string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpaEncryptionPpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write wpaEncryptionPpt2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2)
             {
                        switch(value)
                        {
                                case 1:/* AES */
                                        if( !strcmp(nmp_get("wl0.3_auth_mode_x"), "psk") || !strcmp(nmp_get("wl0.3_auth_mode_x"), "wpa") )
                                                return SNMP_ERR_WRONGVALUE;
                                        nmp_set("wl0.3_crypto", "aes");
                                        break;
                                case 2:/* TKIP+AES */
                                        if( !strcmp(nmp_get("wl0.3_auth_mode_x"), "psk") || !strcmp(nmp_get("wl0.3_auth_mode_x"), "wpa") )
                                                return SNMP_ERR_WRONGVALUE;
                                        nmp_set("wl0.3_crypto", "tkip+aes");
                                        break;
                                }
                        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpaPreSharedKeyPpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 8 || var_val_len > 63 ) {
              fprintf(stderr,"write to wpaPreSharedKeyPpt2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 8 && var_val_len <= 63)
             {
                        strncpy(string, (u_char *)var_val, var_val_len);
                        string[var_val_len] = '\0';
                        nmp_set("wl0.3_wpa_psk", string);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_accessIntranetPpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to accessIntranetPpt2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                        nmp_set("wl0.3_lanaccess", "on");
                else if(value == 2)
                        nmp_set("wl0.3_lanaccess", "off");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableMacFilterPpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to enableMacFilterPpt2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                        nmp_set("wl0.3_macmode", "");
                else if(value == 2)
                        nmp_set("wl0.3_macmode", "disabled");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_pptNetworkType2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ((*(long *)var_val < 0 || *(long *)var_val > 5) && *(long *)var_val != 14 && *(long *)var_val != 15){
              fprintf ( stderr,"write to pptNetworkType5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          if((value >= 1 && value <= 5) || value == 14 || value == 15)
                nmp_set_int("wl0.3_iwnettype", value);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt2gMaxUsers(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 1000){
              fprintf ( stderr,"write to ppt2gMaxUsers: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 1000) {
                nmp_set_int("wl0.3_maxassoc", value);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt2gRadiusServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to passpoint not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to ppt2gRadiusServer: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                tmpval_u = *(u_long *)var_val;
                addr.s_addr = tmpval_u;
                strcpy(tmpstr, (char *)inet_ntoa(addr));
                nmp_set("wl0.3_radius_ipaddr", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt2gRadiusPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( *(long *)var_val < 1024 || *(long *)var_val > 65535 ){
              fprintf(stderr,"write to ppt2gRadiusPort: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >=1024 && value <= 65535)
                nmp_set_int("wl0.3_radius_port", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt2gRadiusKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strncpy(tmpstr, (u_char *)var_val, var_val_len);
             tmpstr[var_val_len] = '\0';
             nmp_set("wl0.3_radius_key", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt2gRadiusTmoServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if (var_val_len > 32) {
              fprintf(stderr,"write to ppt2gRadiusTmoServer: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len <= 32) {
                strncpy(tmpstr, (u_char *)var_val, var_val_len);
                tmpstr[var_val_len] = '\0';
                nmp_set("wl0.3_tmo_radius_ipaddr", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt2gRadiusTmoPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( *(long *)var_val < 1024 || *(long *)var_val > 65535 ){
              fprintf(stderr, "write to ppt2gRadiusTmoPort: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1024 && value <= 65535)
                nmp_set_int("wl0.3_tmo_radius_port", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enablePpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to enablePpt5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                        nmp_set("wl1.3_hs2en", "1");
                else if(value == 2)
                        nmp_set("wl1.3_hs2en", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ssidPpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len <= 32) {
                strncpy(string, (u_char *)var_val, var_val_len);
                string[var_val_len] = '\0';
                nmp_set("wl1.3_ssid", string);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_authenticationPpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 5) {
              fprintf(stderr, "write to authenticationPpt5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 5) {
                switch(value)
                {
                        case 1:/* open system */
                                nmp_set("wl1.3_auth_mode_x", "open");
                                break;
                        case 2:/* shared key */
                                nmp_set("wl1.3_auth_mode_x", "shared");
                                break;
                        case 3: /* wpa personal */
                                nmp_set("wl1.3_auth_mode_x", "psk");
                                break;
                        case 4:/* wpa2 personal */
                                nmp_set("wl1.3_auth_mode_x", "psk2");
                                break;
                        case 5:/* wpa auto personal */
                                nmp_set("wl1.3_auth_mode_x", "pskpsk2");
                                break;
                }
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wepEncryptionPpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wepEncryptionPpt5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 0 && value <= 2) {
                nmp_set_int("wl1.3_wep_x", value);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_keyIndexPpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to keyIndexPpt5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 4)
                nmp_set_int("wl1.3_key", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_passphrasePpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strncpy(string, (u_char *)var_val, var_val_len);
             string[var_val_len] = '\0';
             nmp_set("wl1.3_phrase_x", string);
             generateWepKey("1.3", string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpaEncryptionPpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write wpaEncryptionPpt5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2)
             {
                        switch(value)
                        {
                                case 1:/* AES */
                                        if( !strcmp(nmp_get("wl1.3_auth_mode_x"), "psk") || !strcmp(nmp_get("wl1.3_auth_mode_x"), "wpa") )
                                                return SNMP_ERR_WRONGVALUE;
                                        nmp_set("wl1.3_crypto", "aes");
                                        break;
                                case 2:/* TKIP+AES */
                                        if( !strcmp(nmp_get("wl1.3_auth_mode_x"), "psk") || !strcmp(nmp_get("wl1.3_auth_mode_x"), "wpa") )
                                                return SNMP_ERR_WRONGVALUE;
                                        nmp_set("wl1.3_crypto", "tkip+aes");
                                        break;
                                }
                        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpaPreSharedKeyPpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 8 || var_val_len > 63 ) {
              fprintf(stderr,"write to wpaPreSharedKeyPpt5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 8 && var_val_len <= 63)
             {
                        strncpy(string, (u_char *)var_val, var_val_len);
                        string[var_val_len] = '\0';
                        nmp_set("wl1.3_wpa_psk", string);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_accessIntranetPpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to accessIntranetPpt5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                        nmp_set("wl1.3_lanaccess", "on");
                else if(value == 2)
                        nmp_set("wl1.3_lanaccess", "off");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableMacFilterPpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to enableMacFilterPpt5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
                if(value == 1)
                        nmp_set("wl1.3_macmode", "");
                else if(value == 2)
                        nmp_set("wl1.3_macmode", "disabled");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_pptNetworkType5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ((*(long *)var_val < 0 || *(long *)var_val > 5) && *(long *)var_val != 14 && *(long *)var_val != 15){
              fprintf ( stderr,"write to pptNetworkType5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  if((value >= 1 && value <= 5) || value == 14 || value == 15)
		nmp_set_int("wl1.3_iwnettype", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt5gMaxUsers(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 1000){
              fprintf ( stderr,"write to ppt5gMaxUsers: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 1000) {
             	nmp_set_int("wl1.3_maxassoc", value);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt5gRadiusServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to passpoint not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to radiusServerIPAddrWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                tmpval_u = *(u_long *)var_val;
                addr.s_addr = tmpval_u;
                strcpy(tmpstr, (char *)inet_ntoa(addr));
                nmp_set("wl1.3_radius_ipaddr", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt5gRadiusPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( *(long *)var_val < 1024 || *(long *)var_val > 65535 ){
              fprintf(stderr,"write to ppt5gRadiusPort: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1024 && value <= 65535)
                nmp_set_int("wl1.3_radius_port", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt5gRadiusKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strncpy(tmpstr, (u_char *)var_val, var_val_len);
             tmpstr[var_val_len] = '\0';
             nmp_set("wl1.3_radius_key", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt5gRadiusTmoServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
              fprintf(stderr, "write to ppt5gRadiusTmoServer: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len <= 32) {
                strncpy(tmpstr, (u_char *)var_val, var_val_len);
                tmpstr[var_val_len] = '\0';
                nmp_set("wl1.3_tmo_radius_ipaddr", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ppt5gRadiusTmoPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to passpoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( *(long *)var_val < 1024 || *(long *)var_val > 65535 ){
              fprintf(stderr, "write to ppt5gRadiusTmoPort: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1024 && value <= 65535)
                nmp_set_int("wl1.3_tmo_radius_port", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wepKeyValuePpt2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long keyIndex;
    unsigned char string[SPRINT_MAX_LEN];
    static int i = 0;

    keyIndex = name[name_len - 1];
    memset(string, 0, SPRINT_MAX_LEN);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 5 && var_val_len != 10 && var_val_len != 13 && var_val_len != 26) {
              fprintf(stderr,"write to wepKeyValuePpt2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(string, "wl0.3_key%d", keyIndex);
                    string[strlen(string)] = '\0';
                    strncpy(tmpstr, (u_char *)var_val, var_val_len);
            if(var_val_len == 10 || var_val_len == 26)
            {
                                for(i = 0; i < var_val_len; i++)
                                {
                                        if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
                                        || (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
                                                return SNMP_ERR_WRONGVALUE;
                                }
            }
                nmp_set(string, tmpstr);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ppt2gOuiName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char oui_list[MAXOUILIST][MAXOUISTR];
    int i, oui_list_count = 0;
    char ouiStr[MAXOUISTR+1];
    char *nv, *nvp, *b;

    for(i = 0; i < MAXOUILIST; i++)
        memset(oui_list[i], 0, MAXOUISTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of oui_list */
    nv = nvp = strdup(nmp_safe_get("wl0.3_ouilist"));
    if (nv) {
        while ((b = strsep(&nvp, ";")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(oui_list[oui_list_count], b);
                oui_list_count++;           
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 1 || var_val_len > MAXOUISTR ) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(ouiStr, 0, sizeof(ouiStr));
            strncpy(ouiStr, (u_char *)var_val, var_val_len);

                if((index+1) > oui_list_count)
                        real_index = oui_list_count;
                else
                        real_index = index;

                strcpy(oui_list[real_index], ouiStr);

                /* Re-generate oui_list */
                for(i = 0; i < MAXOUILIST; i++)
                {
                        char entry_str[MAXOUISTR];
                        memset(entry_str, 0, sizeof(entry_str));
                        if(oui_list[i][0]) {
                                sprintf(entry_str, "%s%s", i>0?";":"", oui_list[i]);
                                strcat(tmpstr, entry_str);
                        }
                }

                nmp_set("wl0.3_ouilist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ppt2gDomainName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char domain_list[MAXDOMAINTABLE][MAXDOMAINSTR];
    int i, domain_list_count = 0;
    char domainStr[MAXDOMAINSTR+1];
    char *nv, *nvp, *b;

    for(i = 0; i < MAXDOMAINTABLE; i++)
        memset(domain_list[i], 0, MAXDOMAINSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of domain_list */
    nv = nvp = strdup(nmp_safe_get("wl0.3_domainlist"));
    if (nv) {
        while ((b = strsep(&nvp, " ")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(domain_list[domain_list_count], b);
                domain_list_count++;
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > MAXDOMAINSTR ) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(domainStr, 0, sizeof(domainStr));
            strncpy(domainStr, (u_char *)var_val, var_val_len);

                if((index+1) > domain_list_count)
                        real_index = domain_list_count;
                else
                        real_index = index;

                strcpy(domain_list[real_index], domainStr);

                /* Re-generate domain_list */
                for(i = 0; i < MAXDOMAINTABLE; i++)
                {
                        char entry_str[MAXDOMAINSTR];
                        memset(entry_str, 0, sizeof(entry_str));
                        if(domain_list[i][0]) {
                                sprintf(entry_str, "%s%s", i>0?" ":"", domain_list[i]);
                                strcat(tmpstr, entry_str);
                        }
                }

                nmp_set("wl0.3_domainlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ppt2gRealmName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char realm_list[MAXREALMLIST][MAXREALMSTR];
    int i, realm_list_count = 0;
    char realmStr[MAXREALMSTR+1];
    char *nv, *nvp, *b;

    for(i = 0; i < MAXREALMLIST; i++)
        memset(realm_list[i], 0, MAXREALMSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of realm_list */
    nv = nvp = strdup(nmp_safe_get("wl0.3_realmlist"));
    if (nv) {
        while ((b = strsep(&nvp, "?")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(realm_list[realm_list_count], b);
                realm_list_count++;
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 1 || var_val_len > MAXREALMSTR ) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(realmStr, 0, sizeof(realmStr));
            strncpy(realmStr, (u_char *)var_val, var_val_len);

                if((index+1) > realm_list_count)
                        real_index = realm_list_count;
                else
                        real_index = index;

                strcpy(realm_list[real_index], realmStr);

                /* Re-generate realm_list */
                for(i = 0; i < MAXREALMLIST; i++)
                {
                        char entry_str[MAXREALMSTR];
                        memset(entry_str, 0, sizeof(entry_str));
                        if(realm_list[i][0]) {
                                sprintf(entry_str, "%s%s", i>0?"?":"", realm_list[i]);
                                strcat(tmpstr, entry_str);
                        }
                }

                nmp_set("wl0.3_realmlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ppt2g3gppName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char cni_list[MAX3GPPLIST][MAX3GPPSTR];
    int i, cni_list_count = 0;
    char cniStr[MAX3GPPSTR+1];
    char *nv, *nvp, *b;

    for(i = 0; i < MAX3GPPLIST; i++)
        memset(cni_list[i], 0, MAX3GPPSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of cni_list */
    nv = nvp = strdup(nmp_safe_get("wl0.3_3gpplist"));
    if (nv) {
        while ((b = strsep(&nvp, ";")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(cni_list[cni_list_count], b);
                cni_list_count++;
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 1 || var_val_len > MAX3GPPSTR ) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(cniStr, 0, sizeof(cniStr));
            strncpy(cniStr, (u_char *)var_val, var_val_len);

                if((index+1) > cni_list_count)
                        real_index = cni_list_count;
                else
                        real_index = index;

                strcpy(cni_list[real_index], cniStr);

                /* Re-generate cni_list */
                for(i = 0; i < MAX3GPPLIST; i++)
                {
                        char entry_str[MAX3GPPSTR];
                        memset(entry_str, 0, sizeof(entry_str));
                        if(cni_list[i][0]) {
                                sprintf(entry_str, "%s%s", i>0?";":"", cni_list[i]);
                                strcat(tmpstr, entry_str);
                        }
                }

                nmp_set("wl0.3_3gpplist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wepKeyValuePpt5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long keyIndex;
    unsigned char string[SPRINT_MAX_LEN];
    static int i = 0;

    keyIndex = name[name_len - 1];
    memset(string, 0, SPRINT_MAX_LEN);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 5 && var_val_len != 10 && var_val_len != 13 && var_val_len != 26) {
              fprintf(stderr,"write to wepKeyValuePpt5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(string, "wl1.3_key%d", keyIndex);
                    string[strlen(string)] = '\0';
                    strncpy(tmpstr, (u_char *)var_val, var_val_len);
            if(var_val_len == 10 || var_val_len == 26)
            {
                                for(i = 0; i < var_val_len; i++)
                                {
                                        if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
                                        || (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
                                                return SNMP_ERR_WRONGVALUE;
                                }
            }
                nmp_set(string, tmpstr);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ppt5gOuiName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char oui_list[MAXOUILIST][MAXOUISTR];
    int i, oui_list_count = 0;
    char ouiStr[MAXOUISTR+1];
    char *nv, *nvp, *b;

    for(i = 0; i < MAXOUILIST; i++)
        memset(oui_list[i], 0, MAXOUISTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of oui_list */
    nv = nvp = strdup(nmp_safe_get("wl1.3_ouilist"));
    if (nv) {
        while ((b = strsep(&nvp, ";")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(oui_list[oui_list_count], b);
                oui_list_count++;
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 1 || var_val_len > MAXOUISTR ) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(ouiStr, 0, sizeof(ouiStr));
            strncpy(ouiStr, (u_char *)var_val, var_val_len);

                if((index+1) > oui_list_count)
                        real_index = oui_list_count;
                else
                        real_index = index;

                strcpy(oui_list[real_index], ouiStr);

                /* Re-generate oui_list */
                for(i = 0; i < MAXOUILIST; i++)
                {
                        char entry_str[MAXOUISTR];
                        memset(entry_str, 0, sizeof(entry_str));
                        if(oui_list[i][0]) {
                                sprintf(entry_str, "%s%s", i>0?";":"", oui_list[i]);
                                strcat(tmpstr, entry_str);
                        }
                }

                nmp_set("wl1.3_ouilist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ppt5gDomainName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char domain_list[MAXDOMAINTABLE][MAXDOMAINSTR];
    int i, domain_list_count = 0;
    char domainStr[MAXDOMAINSTR+1];
    char *nv, *nvp, *b;

    for(i = 0; i < MAXDOMAINTABLE; i++)
        memset(domain_list[i], 0, MAXDOMAINSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of domain_list */
    nv = nvp = strdup(nmp_safe_get("wl1.3_domainlist"));
    if (nv) {
        while ((b = strsep(&nvp, " ")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(domain_list[domain_list_count], b);
                domain_list_count++;
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 1 || var_val_len > MAXDOMAINSTR ) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(domainStr, 0, sizeof(domainStr));
            strncpy(domainStr, (u_char *)var_val, var_val_len);

                if((index+1) > domain_list_count)
                        real_index = domain_list_count;
                else
                        real_index = index;

                strcpy(domain_list[real_index], domainStr);

                /* Re-generate domain_list */
                for(i = 0; i < MAXDOMAINTABLE; i++)
                {
                        char entry_str[MAXDOMAINSTR];
                        memset(entry_str, 0, sizeof(entry_str));
                        if(domain_list[i][0]) {
                                sprintf(entry_str, "%s%s", i>0?" ":"", domain_list[i]);
                                strcat(tmpstr, entry_str);
                        }
                }

                nmp_set("wl1.3_domainlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ppt5gRealmName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char realm_list[MAXREALMLIST][MAXREALMSTR];
    int i, realm_list_count = 0;
    char realmStr[MAXREALMSTR+1];
    char *nv, *nvp, *b;

    for(i = 0; i < MAXREALMLIST; i++)
        memset(realm_list[i], 0, MAXREALMSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of realm_list */
    nv = nvp = strdup(nmp_safe_get("wl1.3_realmlist"));
    if (nv) {
        while ((b = strsep(&nvp, "?")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(realm_list[realm_list_count], b);
                realm_list_count++;
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 1 || var_val_len > MAXREALMSTR ) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(realmStr, 0, sizeof(realmStr));
            strncpy(realmStr, (u_char *)var_val, var_val_len);

                if((index+1) > realm_list_count)
                        real_index = realm_list_count;
                else
                        real_index = index;

                strcpy(realm_list[real_index], realmStr);

                /* Re-generate realm_list */
                for(i = 0; i < MAXREALMLIST; i++)
                {
                        char entry_str[MAXREALMSTR];
                        memset(entry_str, 0, sizeof(entry_str));
                        if(realm_list[i][0]) {
                                sprintf(entry_str, "%s%s", i>0?"?":"", realm_list[i]);
                                strcat(tmpstr, entry_str);
                        }
                }

                nmp_set("wl1.3_realmlist", tmpstr);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ppt5g3gppName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char cni_list[MAX3GPPLIST][MAX3GPPSTR];
    int i, cni_list_count = 0;
    char cniStr[MAX3GPPSTR+1];
    char *nv, *nvp, *b;

    for(i = 0; i < MAX3GPPLIST; i++)
        memset(cni_list[i], 0, MAX3GPPSTR);

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of cni_list */
    nv = nvp = strdup(nmp_safe_get("wl1.3_3gpplist"));
    if (nv) {
        while ((b = strsep(&nvp, ";")) != NULL) {
                if (strlen(b)==0) continue;
                strcpy(cni_list[cni_list_count], b);
                cni_list_count++;
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passpoint not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
	  if ( var_val_len < 1 || var_val_len > MAX3GPPSTR ) {
              fprintf(stderr,"write to passpoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(cniStr, 0, sizeof(cniStr));
            strncpy(cniStr, (u_char *)var_val, var_val_len);

                if((index+1) > cni_list_count)
                        real_index = cni_list_count;
                else
                        real_index = index;

                strcpy(cni_list[real_index], cniStr);

                /* Re-generate cni_list */
                for(i = 0; i < MAX3GPPLIST; i++)
                {
                        char entry_str[MAX3GPPSTR];
                        memset(entry_str, 0, sizeof(entry_str));
                        if(cni_list[i][0]) {
                                sprintf(entry_str, "%s%s", i>0?";":"", cni_list[i]);
                                strcat(tmpstr, entry_str);
                        }
                }

                nmp_set("wl1.3_3gpplist", tmpstr);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
