/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "firewall.h"
#include <nmp.h>

#define MAXURLFILTER	128
#define URLFILTERSTRNUM	60
#define MAXKEYWORDFILTER	128
#define KEYWORDFILTERSTRNUM	60
#define MAXNETWORKSERVICEFILTER	32
#define NETWORKSERVICEFILTERSTRNUM	60
#define MAXINBOUNDFIREWALLRULES 128
#define INBOUNDFIREWALLRULESTRNUM 160

static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;

/* 
 * firewall_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid firewall_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,7 };

/* 
 * variable4 firewall_variables:
 *   this variable defines function callbacks and type return information 
 *   for the firewall mib section 
 */

struct variable7 firewall_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define ENABLEFIREWALL		1
{ENABLEFIREWALL,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 1,1 }},
#define ENABLEDOSPROTECTION		2
{ENABLEDOSPROTECTION,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 1,2 }},
#define LOGGEDPACKETSTYPE		3
{LOGGEDPACKETSTYPE,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 1,3 }},
#define RESPONDPINGREQUESTFROMWAN		4
{RESPONDPINGREQUESTFROMWAN,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 1,4 }},
#define ENABLEURLFILTER		5
{ENABLEURLFILTER,  ASN_INTEGER,  RWRITE,  var_firewall, 3,  { 2,1,1 }},
#define ENABLEKEYWORDFILTER		6
{ENABLEKEYWORDFILTER,  ASN_INTEGER,  RWRITE,  var_firewall, 3,  { 3,1,1 }},
#define ENABLENETWORKSERVICESFILTER		7
{ENABLENETWORKSERVICESFILTER,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,1 }},
#define FILTERTABLETYPE		8
{FILTERTABLETYPE,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,2 }},
#define WEEKDAYSENABLELANTOWANFILTER		9
{WEEKDAYSENABLELANTOWANFILTER,  ASN_OCTET_STR,  RWRITE,  var_firewall, 2,  { 4,3 }},
#define WEEKDAYSFILTERSTARTTIMEH		10
{WEEKDAYSFILTERSTARTTIMEH,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,4 }},
#define WEEKDAYSFILTERSTARTTIMEM		11
{WEEKDAYSFILTERSTARTTIMEM,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,5 }},
#define WEEKDAYSFILTERENDTIMEH		12
{WEEKDAYSFILTERENDTIMEH,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,6 }},
#define WEEKDAYSFILTERENDTIMEM		13
{WEEKDAYSFILTERENDTIMEM,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,7 }},
#define WEEKENDENABLELANTOWANFILTER		14
{WEEKENDENABLELANTOWANFILTER,  ASN_OCTET_STR,  RWRITE,  var_firewall, 2,  { 4,8 }},
#define WEEKENDFILTERSTARTTIMEH		15
{WEEKENDFILTERSTARTTIMEH,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,9 }},
#define WEEKENDFILTERSTARTTIMEM		16
{WEEKENDFILTERSTARTTIMEM,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,10 }},
#define WEEKENDFILTERENDTIMEH		17
{WEEKENDFILTERENDTIMEH,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,11 }},
#define WEEKENDFILTERENDTIMEM		18
{WEEKENDFILTERENDTIMEM,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 4,12 }},
#define FILTEREDICMPPACKETTYPES		19
{FILTEREDICMPPACKETTYPES,  ASN_OCTET_STR,  RWRITE,  var_firewall, 2,  { 4,13 }},
#define ENABLEIPV6FIREWALL		20
{ENABLEIPV6FIREWALL,  ASN_INTEGER,  RWRITE,  var_firewall, 2,  { 5,1 }},

#define URLFILTERINDEX		21
{URLFILTERINDEX,  ASN_INTEGER,  RONLY,   var_urlFilterTable, 5,  { 2,2,1, 1, 1 }},
#define URLFILTERURL		22
{URLFILTERURL,  ASN_OCTET_STR,  RWRITE,  var_urlFilterTable, 5,  { 2,2,1, 1, 2 }},
#define URLFILTERDELENTRY		23
{URLFILTERDELENTRY,  ASN_INTEGER,  RWRITE,  var_urlFilterTable, 5,  { 2,2,1, 1, 3 }},
#define KEYWORDFILTERINDEX		24
{KEYWORDFILTERINDEX,  ASN_INTEGER,  RONLY,   var_keywordFilterTable, 5,  { 3,2,1, 1, 1 }},
#define KEYWORDFILTERKEYWORD		25
{KEYWORDFILTERKEYWORD,  ASN_OCTET_STR,  RWRITE,  var_keywordFilterTable, 5,  { 3,2,1, 1, 2 }},
#define KEYWORDFILTERDELENTRY		26
{KEYWORDFILTERDELENTRY,  ASN_INTEGER,  RWRITE,  var_keywordFilterTable, 5,  { 3,2,1, 1, 3 }},
#define NETWORKSERVICESFILTERINDEX		27
{NETWORKSERVICESFILTERINDEX,  ASN_INTEGER,  RONLY,   var_networkServicesFilterTable, 4,  { 4,14, 1, 1 }},
#define NETWORKSERVICESFILTERSOURCEIP		28
{NETWORKSERVICESFILTERSOURCEIP,  ASN_IPADDRESS,  RWRITE,  var_networkServicesFilterTable, 4,  { 4,14, 1, 2 }},
#define NETWORKSERVICESFILTERSOURCEPORTRANGE		29
{NETWORKSERVICESFILTERSOURCEPORTRANGE,  ASN_OCTET_STR,  RWRITE,  var_networkServicesFilterTable, 4,  { 4,14, 1, 3 }},
#define NETWORKSERVICESFILTERDESTINATIONIP		30
{NETWORKSERVICESFILTERDESTINATIONIP,  ASN_IPADDRESS,  RWRITE,  var_networkServicesFilterTable, 4,  { 4,14, 1, 4 }},
#define NETWORKSERVICESFILTERDESTINATIONPORTRANGE		31
{NETWORKSERVICESFILTERDESTINATIONPORTRANGE,  ASN_OCTET_STR,  RWRITE,  var_networkServicesFilterTable, 4,  { 4,14, 1, 5 }},
#define NETWORKSERVICESFILTERPROTOCOL		32
{NETWORKSERVICESFILTERPROTOCOL,  ASN_INTEGER,  RWRITE,  var_networkServicesFilterTable, 4,  { 4,14, 1, 6 }},
#define NETWORKSERVICESFILTERDELENTRY		33
{NETWORKSERVICESFILTERDELENTRY,  ASN_INTEGER,  RWRITE,  var_networkServicesFilterTable, 4,  { 4,14, 1, 7 }},
#define INBOUNDFIREWALLRULESINDEX		34
{INBOUNDFIREWALLRULESINDEX,  ASN_INTEGER,  RONLY,   var_inboundFirewallRulesTable, 4,  { 5,2, 1, 1 }},
#define INBOUNDFIREWALLRULESSERVICENAME		35
{INBOUNDFIREWALLRULESSERVICENAME,  ASN_OCTET_STR,  RWRITE,  var_inboundFirewallRulesTable, 4,  { 5,2, 1, 2 }},
#define INBOUNDFIREWALLRULESREMOTEIP		36
{INBOUNDFIREWALLRULESREMOTEIP,  ASN_OCTET_STR,  RWRITE,  var_inboundFirewallRulesTable, 4,  { 5,2, 1, 3 }},
#define INBOUNDFIREWALLRULESLOCALIP		37
{INBOUNDFIREWALLRULESLOCALIP,  ASN_OCTET_STR,  RWRITE,  var_inboundFirewallRulesTable, 4,  { 5,2, 1, 4 }},
#define INBOUNDFIREWALLRULESPORTRANGE		38
{INBOUNDFIREWALLRULESPORTRANGE,  ASN_OCTET_STR,  RWRITE,  var_inboundFirewallRulesTable, 4,  { 5,2, 1, 5 }},
#define INBOUNDFIREWALLRULESPROTOCOL		39
{INBOUNDFIREWALLRULESPROTOCOL,  ASN_INTEGER,  RWRITE,  var_inboundFirewallRulesTable, 4,  { 5,2, 1, 6 }},
#define INBOUNDFIREWALLRULESDELENTRY		40
{INBOUNDFIREWALLRULESDELENTRY,  ASN_INTEGER,  RWRITE,  var_inboundFirewallRulesTable, 4,  { 5,2, 1, 7 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the firewall module */
void
init_firewall(void)
{

    DEBUGMSGTL(("firewall", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("firewall", firewall_variables, variable7,
               firewall_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_firewall():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_firewall(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)	//Doesn't support in AP and repeater mode
	return NULL;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case ENABLEFIREWALL:
        *write_method = write_enableFirewall;
        if(nmp_safe_get("fw_enable_x") != NULL)
    	{
    		tmpval = nmp_get_int("fw_enable_x");
    		if(tmpval == 1) /* enable */
    			tmpval = 1;
    		else if(tmpval == 0) /* disable */
    			tmpval = 2;
          		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
    	return NULL;
    case ENABLEDOSPROTECTION:
        *write_method = write_enableDoSProtection;
        if(nmp_safe_get("fw_dos_x") != NULL)
    	{
    		tmpval = nmp_get_int("fw_dos_x");
    		if(tmpval == 1) /* enable */
    			tmpval = 1;
    		else if(tmpval == 0) /* disable */
    			tmpval = 2;
          		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
    	return NULL;
    case LOGGEDPACKETSTYPE:
        *write_method = write_loggedPacketsType;
        if(nmp_safe_get("fw_log_x") != NULL)
        {
    		if(!strcmp(nmp_get("fw_log_x"), "none")) /* none */
    			tmpval = 1;
    		else if(!strcmp(nmp_get("fw_log_x"), "drop")) /* drop */
    			tmpval = 2;
    		else if(!strcmp(nmp_get("fw_log_x"), "accept")) /* accept */
    			tmpval = 3;
    		else if(!strcmp(nmp_get("fw_log_x"), "both")) /* both */
    			tmpval = 4;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case RESPONDPINGREQUESTFROMWAN:
        *write_method = write_respondPingRequestfromWAN;
        if(nmp_safe_get("misc_ping_x") != NULL)
    	{
    		tmpval = nmp_get_int("misc_ping_x");
    		if(tmpval == 1) /* yes */
    			tmpval = 1;
    		else if(tmpval == 0) /* no */
    			tmpval = 2;
          		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
    	return NULL;
    case ENABLEURLFILTER:
        *write_method = write_enableURLFilter;
        if(nmp_safe_get("url_enable_x") != NULL)
        {
	       tmpval = nmp_get_int("url_enable_x");
           *var_len = sizeof( long );
           return ( u_char * ) &tmpval;
        }
        return NULL;
    case ENABLEKEYWORDFILTER:
        *write_method = write_enableKeywordFilter;
        if(nmp_safe_get("keyword_enable_x") != NULL)
        {
            tmpval = nmp_get_int("keyword_enable_x");
      		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case ENABLENETWORKSERVICESFILTER:
        *write_method = write_enableNetworkServicesFilter;
        if(nmp_safe_get("fw_lw_enable_x") != NULL)
    	{
    		tmpval = nmp_get_int("fw_lw_enable_x");
    		if(tmpval == 1) /* yes */
    			tmpval = 1;
    		else if(tmpval == 0) /* no */
    			tmpval = 2;
          		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
    	}
    	return NULL;
    case FILTERTABLETYPE:
        *write_method = write_filterTableType;
        if(nmp_safe_get("filter_lw_default_x") != NULL)
        {
    		if(!strcmp(nmp_get("filter_lw_default_x"), "DROP")) /* White list */
    			tmpval = 1;
    		else if(!strcmp(nmp_get("filter_lw_default_x"), "ACCEPT")) /* Black List */
    			tmpval = 2;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSENABLELANTOWANFILTER:
        *write_method = write_weekDaysEnableLANtoWANFilter;
        if(nmp_safe_get("filter_lw_date_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_date_x"));
    		if(tmpstr[1]-'0') tmpval += (1 << 7);
    		if(tmpstr[2]-'0') tmpval += (1 << 6);
    		if(tmpstr[3]-'0') tmpval += (1 << 5);
    		if(tmpstr[4]-'0') tmpval += (1 << 4);
    		if(tmpstr[5]-'0') tmpval += (1 << 3);
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSFILTERSTARTTIMEH:
        *write_method = write_weekDaysFilterStartTimeH;
        if(nmp_safe_get("filter_lw_time_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_time_x"));
    		tmpval += (tmpstr[0]-'0') * 10;
    		tmpval += (tmpstr[1]-'0');
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSFILTERSTARTTIMEM:
        *write_method = write_weekDaysFilterStartTimeM;
        if(nmp_safe_get("filter_lw_time_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_time_x"));
    		tmpval += (tmpstr[2]-'0') * 10;
    		tmpval += (tmpstr[3]-'0');
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSFILTERENDTIMEH:
        *write_method = write_weekDaysFilterEndTimeH;
        if(nmp_safe_get("filter_lw_time_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_time_x"));
    		tmpval += (tmpstr[4]-'0') * 10;
    		tmpval += (tmpstr[5]-'0');
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSFILTERENDTIMEM:
        *write_method = write_weekDaysFilterEndTimeM;
        if(nmp_safe_get("filter_lw_time_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_time_x"));
    		tmpval += (tmpstr[6]-'0') * 10;
    		tmpval += (tmpstr[7]-'0');
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDENABLELANTOWANFILTER:
        *write_method = write_weekendEnableLANtoWANFilter;
        if(nmp_safe_get("filter_lw_date_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_date_x"));
    		if(tmpstr[6]-'0') tmpval += (1 << 7);	//saturday
    		if(tmpstr[0]-'0') tmpval += (1 << 6);	//sunday
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDFILTERSTARTTIMEH:
        *write_method = write_weekendFilterStartTimeH;
        if(nmp_safe_get("filter_lw_time2_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_time2_x"));
    		tmpval += (tmpstr[0]-'0') * 10;
    		tmpval += (tmpstr[1]-'0');
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDFILTERSTARTTIMEM:
        *write_method = write_weekendFilterStartTimeM;
        if(nmp_safe_get("filter_lw_time2_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_time2_x"));
    		tmpval += (tmpstr[2]-'0') * 10;
    		tmpval += (tmpstr[3]-'0');
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDFILTERENDTIMEH:
        *write_method = write_weekendFilterEndTimeH;
        if(nmp_safe_get("filter_lw_time2_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_time2_x"));
    		tmpval += (tmpstr[4]-'0') * 10;
    		tmpval += (tmpstr[5]-'0');
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDFILTERENDTIMEM:
        *write_method = write_weekendFilterEndTimeM;
        if(nmp_safe_get("filter_lw_time2_x") != NULL)
      	{
    		tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get("filter_lw_time2_x"));
    		tmpval += (tmpstr[6]-'0') * 10;
    		tmpval += (tmpstr[7]-'0');
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case FILTEREDICMPPACKETTYPES:
        *write_method = write_filteredICMPPacketTypes;
        if(nmp_safe_get("filter_lw_icmp_x") != NULL)
        {
    		strcpy(tmpstr, nmp_safe_get("filter_lw_icmp_x"));
    		tmpstr[strlen(tmpstr)] = '\0';
    		*var_len = strlen( tmpstr );
    		return ( u_char * ) tmpstr;	
        }
        return NULL;
    case ENABLEIPV6FIREWALL:
        *write_method = write_enableIpv6Firewall;
        if(nmp_safe_get("ipv6_fw_enable") != NULL)
        {
            tmpval = nmp_get_int("ipv6_fw_enable");
            if(tmpval == 1) /* yes */
                tmpval = 1;
            else if(tmpval == 0) /* no */
                tmpval = 2;
                *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }
        return NULL;        
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_urlFilterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_firewall above.
 */
unsigned char *
var_urlFilterTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char url_rulelist[MAXURLFILTER][URLFILTERSTRNUM];
    int i, url_rulelist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXURLFILTER; i++)
    	memset(url_rulelist[i], 0x0, URLFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    /* Compute the number of url_rulelist */
    nv = nvp = strdup(nmp_safe_get("url_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(url_rulelist[url_rulelist_count], b);
    		url_rulelist_count++;		
    	}
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXURLFILTER /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case URLFILTERINDEX:
        return NULL;
    case URLFILTERURL:
        *write_method = write_urlFilterUrl;
        index = name[*length-1]-1;
        if(index <= url_rulelist_count-1) {
        	if (strlen(url_rulelist[index])) {
                strcpy(tmpstr, url_rulelist[index]);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * )tmpstr;
    case URLFILTERDELENTRY:
        *write_method = write_urlFilterDelEntry;
        tmpval = 2; /* no */
	 	*var_len = sizeof( long );
        return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_keywordFilterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_firewall above.
 */
unsigned char *
var_keywordFilterTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char keyword_rulelist[MAXKEYWORDFILTER][KEYWORDFILTERSTRNUM];
    int i, keyword_rulelist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXKEYWORDFILTER; i++)
    	memset(keyword_rulelist[i], 0x0, KEYWORDFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of keyword_rulelist
    nv = nvp = strdup(nmp_safe_get("keyword_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(keyword_rulelist[keyword_rulelist_count], b);
    		keyword_rulelist_count++;		
    	}
    	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXKEYWORDFILTER /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case KEYWORDFILTERINDEX:
        return NULL;
    case KEYWORDFILTERKEYWORD:
        *write_method = write_keywordFilterKeyword;
        index = name[*length-1]-1;
        if(index <= keyword_rulelist_count-1) {
           	if (strlen(keyword_rulelist[index])) {
    			strcpy(tmpstr, keyword_rulelist[index]);
    		}
    	}
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case KEYWORDFILTERDELENTRY:
        *write_method = write_keywordFilterDelEntry;
	    tmpval = 2; /* no */
	 	*var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_networkServicesFilterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_firewall above.
 */
unsigned char *
var_networkServicesFilterTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char filter_lwlist[MAXNETWORKSERVICEFILTER][NETWORKSERVICEFILTERSTRNUM];
    int i, filter_lwlist_count = 0;
    char *nv, *nvp, *b, *srcIP, *srcPortRange, *destIP, *destPortRange, *protocol;

    for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    	memset(filter_lwlist[i], 0x0, NETWORKSERVICEFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("filter_lwlist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(filter_lwlist[filter_lwlist_count], b);
    		filter_lwlist_count++;		
    	}
    	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXNETWORKSERVICEFILTER /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case NETWORKSERVICESFILTERINDEX:
        return NULL;
    case NETWORKSERVICESFILTERSOURCEIP:
        *write_method = write_networkServicesFilterSourceIP;
        tmpval_u = 0;
        index = name[*length-1]-1;
        if(index <= filter_lwlist_count-1) {
        	if (strlen(filter_lwlist[index])) {
    			if(vstrsep(filter_lwlist[index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			tmpval_u = inet_addr(srcIP);
            }
    	}
        *var_len = sizeof( unsigned long );
        return ( u_char * ) &tmpval_u;
    case NETWORKSERVICESFILTERSOURCEPORTRANGE:
        *write_method = write_networkServicesFilterSourcePortRange;
        index = name[*length-1]-1;
        if(index <= filter_lwlist_count-1) {
        	if (strlen(filter_lwlist[index])) {
    			if(vstrsep(filter_lwlist[index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			strcpy(tmpstr, srcPortRange);
            }
    	}
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case NETWORKSERVICESFILTERDESTINATIONIP:
        *write_method = write_networkServicesFilterDestinationIP;
        tmpval_u = 0;
        index = name[*length-1]-1;
        if(index <= filter_lwlist_count-1) {
        	if (strlen(filter_lwlist[index])) {
    			if(vstrsep(filter_lwlist[index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			tmpval_u = inet_addr(destIP);
            }
    	}
        *var_len = sizeof( unsigned long );
        return ( u_char * ) &tmpval_u;
    case NETWORKSERVICESFILTERDESTINATIONPORTRANGE:
        *write_method = write_networkServicesFilterDestinationPortRange;
        index = name[*length-1]-1;
        if(index <= filter_lwlist_count-1) {
        	if (strlen(filter_lwlist[index])) {
    			if(vstrsep(filter_lwlist[index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			strcpy(tmpstr, destPortRange);
            }
    	}
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case NETWORKSERVICESFILTERPROTOCOL:
        *write_method = write_networkServicesFilterProtocol;
        tmpval = 0;
        index = name[*length-1]-1;
        if(index <= filter_lwlist_count-1) {
        	if (strlen(filter_lwlist[index])) {
    			if(vstrsep(filter_lwlist[index], ">",  &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			if(!strcmp(protocol, "TCP")) tmpval = 1;
    			else if(!strcmp(protocol, "TCP ALL")) tmpval = 2;
    			else if(!strcmp(protocol, "TCP SYN")) tmpval = 3;
    			else if(!strcmp(protocol, "TCP ACK")) tmpval = 4;
    			else if(!strcmp(protocol, "TCP FIN")) tmpval = 5;
    			else if(!strcmp(protocol, "TCP RST")) tmpval = 6;
    			else if(!strcmp(protocol, "TCP URG")) tmpval = 7;
    			else if(!strcmp(protocol, "TCP PSH")) tmpval = 8;
    			else if(!strcmp(protocol, "UDP")) tmpval = 9;
            }
    	}
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case NETWORKSERVICESFILTERDELENTRY:
        *write_method = write_networkServicesFilterDelEntry;
	    tmpval = 2; /* no */
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_inboundFirewallRulesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_firewall above.
 */
unsigned char *
var_inboundFirewallRulesTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char inboundRulesList[MAXINBOUNDFIREWALLRULES][INBOUNDFIREWALLRULESTRNUM];
    int i, rulelist_count = 0;
    char *nv, *nvp, *b, *servicename, *remoteIp, *localIp, *portRange, *proto;

    for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
        memset(inboundRulesList[i], 0x0, INBOUNDFIREWALLRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of ipv6 inbound firewall rule list
    nv = nvp = strdup(nmp_safe_get("ipv6_fw_rulelist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(inboundRulesList[rulelist_count], b);
            rulelist_count++;       
        }
        free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXINBOUNDFIREWALLRULES)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case INBOUNDFIREWALLRULESINDEX:
        return (u_char*) NULL;
    case INBOUNDFIREWALLRULESSERVICENAME:
        *write_method = write_inboundFirewallRulesServiceName;
        index = name[*length-1]-1;
        if(index <= rulelist_count-1) {
            if (strlen(inboundRulesList[index])) {
                if(vstrsep(inboundRulesList[index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                strcpy(tmpstr, servicename);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case INBOUNDFIREWALLRULESREMOTEIP:
        *write_method = write_inboundFirewallRulesRemoteIP;
        index = name[*length-1]-1;
        if(index <= rulelist_count-1) {
            if (strlen(inboundRulesList[index])) {
                if(vstrsep(inboundRulesList[index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                strcpy(tmpstr, remoteIp);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case INBOUNDFIREWALLRULESLOCALIP:
        *write_method = write_inboundFirewallRulesLocalIP;
        index = name[*length-1]-1;
        if(index <= rulelist_count-1) {
            if (strlen(inboundRulesList[index])) {
                if(vstrsep(inboundRulesList[index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                strcpy(tmpstr, localIp);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case INBOUNDFIREWALLRULESPORTRANGE:
        *write_method = write_inboundFirewallRulesPortRange;
        index = name[*length-1]-1;
        if(index <= rulelist_count-1) {
            if (strlen(inboundRulesList[index])) {
                if(vstrsep(inboundRulesList[index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                strcpy(tmpstr, portRange);
            }
        }
        *var_len = strlen( tmpstr );
        return ( u_char * ) tmpstr;
    case INBOUNDFIREWALLRULESPROTOCOL:
        *write_method = write_inboundFirewallRulesProtocol;
        tmpval = 0;
        index = name[*length-1]-1;
        if(index <= rulelist_count-1) {
            if (strlen(inboundRulesList[index])) {
                if(vstrsep(inboundRulesList[index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                if(!strcmp(proto, "TCP"))
                    tmpval = 1;
                else if(!strcmp(proto, "UDP"))
                    tmpval = 2;
                else if(!strcmp(proto, "BOTH"))
                    tmpval = 3;
                else if(!strcmp(proto, "OTHER"))
                    tmpval = 4;                                    
            }
        }       
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case INBOUNDFIREWALLRULESDELENTRY:
        *write_method = write_inboundFirewallRulesDelEntry;
        tmpval = 2;
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_enableFirewall(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_enable_x", "1");
             	else if(value == 2)
			nmp_set("fw_enable_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableDoSProtection(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_dos_x", "1");
             	else if(value == 2)
			nmp_set("fw_dos_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_loggedPacketsType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 4) {
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 4) {
      		switch(value)
      		{
      			case 1:/* none */
				nmp_set("fw_log_x", "none");
				break;
      			case 2:/* drop */
				nmp_set("fw_log_x", "drop");
				break;
      			case 3:	/* accept */
				nmp_set("fw_log_x", "accept");
				break;
			case 4:/* both */
				nmp_set("fw_log_x", "both");
				break;
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_respondPingRequestfromWAN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("misc_ping_x", "1");
             	else if(value == 2)
			nmp_set("misc_ping_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableURLFilter(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 1){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			nmp_set_int("url_enable_x", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableKeywordFilter(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 1){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			nmp_set_int("keyword_enable_x", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableNetworkServicesFilter(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("fw_lw_enable_x", "1");
             	else if(value == 2)
			nmp_set("fw_lw_enable_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_filterTableType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
      		switch(value)
      		{
      			case 1:/* DROP (White List)*/
    				nmp_set("filter_lw_default_x", "DROP");
    				break;
      			case 2:/* ACCEPT (Black List)*/
    				nmp_set("filter_lw_default_x", "ACCEPT");
    				break;
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysEnableLANtoWANFilter(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    char dateStr[16];

    value = * (char *) var_val;

    memset(dateStr, 0, sizeof(dateStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_date_x"));
             (tmpstr[0]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 7)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 6)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 5)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 4)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 3)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[7]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             nmp_set("filter_lw_date_x", dateStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysFilterStartTimeH(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char timeStr[16];
    int startM = 0, endH = 0, endM = 0;

    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_time_x"));
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", value, startM, endH, endM);
             nmp_set("filter_lw_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysFilterStartTimeM(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char timeStr[16];
    int startH = 0, endH = 0, endM = 0;

    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, value, endH, endM);
             nmp_set("filter_lw_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysFilterEndTimeH(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char timeStr[16];
    int startH = 0, startM = 0, endM = 0;

    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, value, endM);
             nmp_set("filter_lw_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysFilterEndTimeM(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char timeStr[16];
    int startH = 0, startM = 0, endH = 0;

    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, endH, value);
             nmp_set("filter_lw_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendEnableLANtoWANFilter(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    char dateStr[16];

    value = * (char *) var_val;

    memset(dateStr, 0, sizeof(dateStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_date_x"));
             (value & (1 << 6)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[1]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[2]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[3]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[4]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[5]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 7)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             nmp_set("filter_lw_date_x", dateStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendFilterStartTimeH(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char timeStr[16];
    int startM = 0, endH = 0, endM = 0;

    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_time2_x"));
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", value, startM, endH, endM);
             nmp_set("filter_lw_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendFilterStartTimeM(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char timeStr[16];
    int startH = 0, endH = 0, endM = 0;

    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, value, endH, endM);
             nmp_set("filter_lw_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendFilterEndTimeH(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char timeStr[16];
    int startH = 0, startM = 0, endM = 0;

    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, value, endM);
             nmp_set("filter_lw_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendFilterEndTimeM(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char timeStr[16];
    int startH = 0, startM = 0, endH = 0;

    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("filter_lw_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, endH, value);
             nmp_set("filter_lw_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_filteredICMPPacketTypes(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 1 || var_val_len <= 32)
             {
        		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
        		tmpstr[var_val_len] = '\0';
            	nmp_set("filter_lw_icmp_x", tmpstr); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableIpv6Firewall(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              if(value == 1)//yes
                nmp_set("ipv6_fw_enable", "1");
              else if(value == 2)//no
                nmp_set("ipv6_fw_enable", "0");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_urlFilterUrl(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char url_rulelist[MAXURLFILTER][URLFILTERSTRNUM];
    int i, url_rulelist_count = 0;
    char urlStr[33];
    char *nv, *nvp, *b;

    for(i = 0; i < MAXURLFILTER; i++)
    	memset(url_rulelist[i], 0x0, URLFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    /* Compute the number of url_rulelist */
    nv = nvp = strdup(nmp_safe_get("url_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(url_rulelist[url_rulelist_count], b);
		url_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(urlStr, 0, sizeof(urlStr));
            strncpy(urlStr, (u_char *)var_val, var_val_len); 

    		if((index+1) > url_rulelist_count)
    			real_index = url_rulelist_count;
    		else
    			real_index = index;
    	
    		strcpy(url_rulelist[real_index], urlStr);
                 	
    		/* Re-generate url_rulelist */
    		for(i = 0; i < MAXURLFILTER; i++)
    		{
    			char entry_str[URLFILTERSTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(url_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", url_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("url_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_urlFilterDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char url_rulelist[MAXURLFILTER][URLFILTERSTRNUM];
    int i, url_rulelist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXURLFILTER; i++)
    	memset(url_rulelist[i], 0x0, URLFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] - 1;

    //Compute the number of url_rulelist
    nv = nvp = strdup(nmp_safe_get("url_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(url_rulelist[url_rulelist_count], b);
		url_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < url_rulelist_count)
             {
        	memset(url_rulelist[index], 0x0, URLFILTERSTRNUM);

		//Re-generate url_rulelist
		for(i = 0; i < MAXURLFILTER; i++)
		{
			char entry_str[URLFILTERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(url_rulelist[i][0]) {
				sprintf(entry_str, "<%s", url_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("url_rulelist", tmpstr);
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_keywordFilterKeyword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char keyword_rulelist[MAXKEYWORDFILTER][KEYWORDFILTERSTRNUM];
    int i, keyword_rulelist_count = 0;
    char keywordStr[33];
    char *nv, *nvp, *b;

    for(i = 0; i < MAXKEYWORDFILTER; i++)
    	memset(keyword_rulelist[i], 0x0, KEYWORDFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of keyword_rulelist
    nv = nvp = strdup(nmp_safe_get("keyword_rulelist"));
    if (nv) {
    	while ((b = strsep(&nvp, "<")) != NULL) {
    		if (strlen(b)==0) continue;
    		strcpy(keyword_rulelist[keyword_rulelist_count], b);
    		keyword_rulelist_count++;		
    	}
    	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(keywordStr, 0, sizeof(keywordStr));
            strncpy(keywordStr, (u_char *)var_val, var_val_len); 

    		if((index+1) > keyword_rulelist_count)
    			real_index = keyword_rulelist_count;
    		else
    			real_index = index;
    	
    		strcpy(keyword_rulelist[real_index], keywordStr);
                 	
    		//Re-generate keyword_rulelist
    		for(i = 0; i < MAXKEYWORDFILTER; i++)
    		{
    			char entry_str[KEYWORDFILTERSTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(keyword_rulelist[i][0]) {
    				sprintf(entry_str, "<%s", keyword_rulelist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("keyword_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_keywordFilterDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char keyword_rulelist[MAXKEYWORDFILTER][KEYWORDFILTERSTRNUM];
    int i, keyword_rulelist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXKEYWORDFILTER; i++)
    	memset(keyword_rulelist[i], 0x0, KEYWORDFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] - 1;

    //Compute the number of keyword_rulelist
    nv = nvp = strdup(nmp_safe_get("keyword_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(keyword_rulelist[keyword_rulelist_count], b);
		keyword_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < keyword_rulelist_count)
             {
        	memset(keyword_rulelist[index], 0x0, KEYWORDFILTERSTRNUM);

		//Re-generate keyword_rulelist
		for(i = 0; i < MAXKEYWORDFILTER; i++)
		{
			char entry_str[KEYWORDFILTERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(keyword_rulelist[i][0]) {
				sprintf(entry_str, "<%s", keyword_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("keyword_rulelist", tmpstr);
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_networkServicesFilterSourceIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    static struct in_addr addr;
    char filter_lwlist[MAXNETWORKSERVICEFILTER][NETWORKSERVICEFILTERSTRNUM];
    int i, filter_lwlist_count = 0;
    char *nv, *nvp, *b, *srcIP, *srcPortRange, *destIP, *destPortRange, *protocol;
    char srcIPStr[32];
    char string[NETWORKSERVICEFILTERSTRNUM];

    for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    	memset(filter_lwlist[i], 0x0, NETWORKSERVICEFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("filter_lwlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(filter_lwlist[filter_lwlist_count], b);
		filter_lwlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to firewall not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
         	memset(srcIPStr, 0, sizeof(srcIPStr));
            tmpval_u = *(u_long *)var_val;
            addr.s_addr = tmpval_u;
            
            strcpy(srcIPStr, (char *)inet_ntoa(addr)); 

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > filter_lwlist_count)
    			real_index = filter_lwlist_count;
    		else
    			real_index = index;

    		if(filter_lwlist[real_index][0]) {
    			if(vstrsep(filter_lwlist[real_index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			sprintf(string, "%s>%s>%s>%s>%s", srcIPStr, srcPortRange, destIP, destPortRange, protocol);
    		}
    		else
    			sprintf(string, "%s>>>>", srcIPStr);	
    		strcpy(filter_lwlist[real_index], string);
                 	
    		//Re-generate filter_lwlist
    		for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    		{
    			char entry_str[NETWORKSERVICEFILTERSTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(filter_lwlist[i][0]) {
    				sprintf(entry_str, "<%s", filter_lwlist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("filter_lwlist", tmpstr);
              break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_networkServicesFilterSourcePortRange(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char filter_lwlist[MAXNETWORKSERVICEFILTER][NETWORKSERVICEFILTERSTRNUM];
    int i, filter_lwlist_count = 0, startPort = 1, endPort = 65535;
    char *nv, *nvp, *b, *srcIP, *srcPortRange, *destIP, *destPortRange, *protocol, *none;
    char srcPortRangeStr[16];
    char string[NETWORKSERVICEFILTERSTRNUM];

    for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    	memset(filter_lwlist[i], 0x0, NETWORKSERVICEFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("filter_lwlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(filter_lwlist[filter_lwlist_count], b);
		filter_lwlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 11 ) {
              fprintf(stderr, "write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(srcPortRangeStr, 0, sizeof(srcPortRangeStr));
            strncpy(srcPortRangeStr, (u_char *)var_val, var_val_len); 
            if(srcPortRangeStr[0] == '>') {
                if(vstrsep(srcPortRangeStr, ">", &none, &srcPortRange) != 2) break;
                startPort = atoi(srcPortRange);
                sprintf(srcPortRangeStr, "%d:%d", startPort, endPort);
            }
            else if(srcPortRangeStr[0] == '<') {
                if(vstrsep(srcPortRangeStr, "<", &none, &srcPortRange) != 2) break;
                endPort = atoi(srcPortRange);
                sprintf(srcPortRangeStr, "%d:%d", startPort, endPort);
            }            

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > filter_lwlist_count)
    			real_index = filter_lwlist_count;
    		else
    			real_index = index;

    		if(filter_lwlist[real_index][0]) {
    			if(vstrsep(filter_lwlist[real_index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			sprintf(string, "%s>%s>%s>%s>%s", srcIP, srcPortRangeStr, destIP, destPortRange, protocol);
    		}
    		else
    			sprintf(string, ">%s>>>", srcPortRangeStr);	
    		strcpy(filter_lwlist[real_index], string);
                 	
    		//Re-generate filter_lwlist
    		for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    		{
    			char entry_str[NETWORKSERVICEFILTERSTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(filter_lwlist[i][0]) {
    				sprintf(entry_str, "<%s", filter_lwlist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("filter_lwlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_networkServicesFilterDestinationIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    static struct in_addr addr;
    char filter_lwlist[MAXNETWORKSERVICEFILTER][NETWORKSERVICEFILTERSTRNUM];
    int i, filter_lwlist_count = 0;
    char *nv, *nvp, *b, *srcIP, *srcPortRange, *destIP, *destPortRange, *protocol;
    char destIPStr[32];
    char string[NETWORKSERVICEFILTERSTRNUM];

    for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    	memset(filter_lwlist[i], 0x0, NETWORKSERVICEFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("filter_lwlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(filter_lwlist[filter_lwlist_count], b);
		filter_lwlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to firewall not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
         	memset(destIPStr, 0, sizeof(destIPStr));
            tmpval_u = *(u_long *)var_val;
            addr.s_addr = tmpval_u;
            strcpy(destIPStr, (char *)inet_ntoa(addr)); 

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > filter_lwlist_count)
    			real_index = filter_lwlist_count;
    		else
    			real_index = index;

    		if(filter_lwlist[real_index][0]) {
    			if(vstrsep(filter_lwlist[real_index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			sprintf(string, "%s>%s>%s>%s>%s", srcIP, srcPortRange, destIPStr, destPortRange, protocol);
    		}
    		else
    			sprintf(string, ">>%s>>", destIPStr);	
    		strcpy(filter_lwlist[real_index], string);
                 	
    		//Re-generate filter_lwlist
    		for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    		{
    			char entry_str[NETWORKSERVICEFILTERSTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(filter_lwlist[i][0]) {
    				sprintf(entry_str, "<%s", filter_lwlist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("filter_lwlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_networkServicesFilterDestinationPortRange(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char filter_lwlist[MAXNETWORKSERVICEFILTER][NETWORKSERVICEFILTERSTRNUM];
    int i, filter_lwlist_count = 0, startPort = 1, endPort = 65535;
    char *nv, *nvp, *b, *srcIP, *srcPortRange, *destIP, *destPortRange, *protocol, *none;
    char destPortRangeStr[32];
    char string[NETWORKSERVICEFILTERSTRNUM];

    for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    	memset(filter_lwlist[i], 0x0, NETWORKSERVICEFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("filter_lwlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(filter_lwlist[filter_lwlist_count], b);
		filter_lwlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 11 ) {
              fprintf(stderr, "write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(destPortRangeStr, 0, sizeof(destPortRangeStr));
            strncpy(destPortRangeStr, (u_char *)var_val, var_val_len); 

            if(destPortRangeStr[0] == '>') {
                if(vstrsep(destPortRangeStr, ">", &none, &destPortRange) != 2) break;
                startPort = atoi(destPortRange);
                sprintf(destPortRangeStr, "%d:%d", startPort, endPort);
            }
            else if(destPortRangeStr[0] == '<') {
                if(vstrsep(destPortRangeStr, "<", &none, &destPortRange) != 2) break;
                endPort = atoi(destPortRange);
                sprintf(destPortRangeStr, "%d:%d", startPort, endPort);
            }  

    		memset(string, 0x0, sizeof(string));
    		if((index+1) > filter_lwlist_count)
    			real_index = filter_lwlist_count;
    		else
    			real_index = index;

    		if(filter_lwlist[real_index][0]) {
    			if(vstrsep(filter_lwlist[real_index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
    			sprintf(string, "%s>%s>%s>%s>%s", srcIP, srcPortRange, destIP, destPortRangeStr, protocol);
    		}
    		else
    			sprintf(string, ">>>%s>", destPortRangeStr);	
    		strcpy(filter_lwlist[real_index], string);
                 	
    		//Re-generate filter_lwlist
    		for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    		{
    			char entry_str[NETWORKSERVICEFILTERSTRNUM];
    			memset(entry_str, 0x0, sizeof(entry_str));
    			if(filter_lwlist[i][0]) {
    				sprintf(entry_str, "<%s", filter_lwlist[i]);
    				strcat(tmpstr, entry_str);
    			}
    		}

    		nmp_set("filter_lwlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_networkServicesFilterProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char filter_lwlist[MAXNETWORKSERVICEFILTER][NETWORKSERVICEFILTERSTRNUM];
    int i, filter_lwlist_count = 0;
    char *nv, *nvp, *b, *srcIP, *srcPortRange, *destIP, *destPortRange, *protocol;
    int protocolInt;
    char protocolStr[8];
    char string[NETWORKSERVICEFILTERSTRNUM];

    for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    	memset(filter_lwlist[i], 0x0, NETWORKSERVICEFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("filter_lwlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(filter_lwlist[filter_lwlist_count], b);
		filter_lwlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 9 ){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		protocolInt = *(u_long *)var_val;
		if(protocolInt == 1) sprintf(protocolStr, "TCP");
		else if(protocolInt == 2) sprintf(protocolStr, "TCP ALL");
		else if(protocolInt == 3) sprintf(protocolStr, "TCP SYN");
		else if(protocolInt == 4) sprintf(protocolStr, "TCP ACK");
		else if(protocolInt == 5) sprintf(protocolStr, "TCP FIN");
		else if(protocolInt == 6) sprintf(protocolStr, "TCP RST");
		else if(protocolInt == 7) sprintf(protocolStr, "TCP URG");
		else if(protocolInt == 8) sprintf(protocolStr, "TCP PSH");
		else if(protocolInt == 9) sprintf(protocolStr, "UDP");

		memset(string, 0x0, sizeof(string));
		if((index+1) > filter_lwlist_count)
			real_index = filter_lwlist_count;
		else
			real_index = index;

		if(filter_lwlist[real_index][0]) {
			if(vstrsep(filter_lwlist[real_index], ">", &srcIP, &srcPortRange, &destIP, &destPortRange, &protocol) != 5) break;
			sprintf(string, "%s>%s>%s>%s>%s", srcIP, srcPortRange, destIP, destPortRange, protocolStr);
		}
		else
			sprintf(string, ">>>>%s", protocolStr);	
		strcpy(filter_lwlist[real_index], string);
             	
		//Re-generate filter_lwlist
		for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
		{
			char entry_str[NETWORKSERVICEFILTERSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(filter_lwlist[i][0]) {
				sprintf(entry_str, "<%s", filter_lwlist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("filter_lwlist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_networkServicesFilterDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char filter_lwlist[MAXNETWORKSERVICEFILTER][NETWORKSERVICEFILTERSTRNUM];
    int i, filter_lwlist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
    	memset(filter_lwlist[i], 0x0, NETWORKSERVICEFILTERSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] -1;

    //Compute the number of autofw_rulelist
    nv = nvp = strdup(nmp_safe_get("filter_lwlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(filter_lwlist[filter_lwlist_count], b);
		filter_lwlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to firewall: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < filter_lwlist_count)
             {
                memset(filter_lwlist[index], 0x0, NETWORKSERVICEFILTERSTRNUM);

        		//Re-generate filter_lwlist
        		for(i = 0; i < MAXNETWORKSERVICEFILTER; i++)
        		{
        			char entry_str[NETWORKSERVICEFILTERSTRNUM];
        			memset(entry_str, 0x0, sizeof(entry_str));
        			if(filter_lwlist[i][0]) {
        				sprintf(entry_str, "<%s", filter_lwlist[i]);
        				strcat(tmpstr, entry_str);
        			}
        		}

                nmp_set("filter_lwlist", tmpstr);
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_inboundFirewallRulesServiceName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char inboundRulesList[MAXINBOUNDFIREWALLRULES][INBOUNDFIREWALLRULESTRNUM];
    int i, rulelist_count = 0;
    char *nv, *nvp, *b, *servicename, *remoteIp, *localIp, *portRange, *proto;
    char serviceNameStr[128], string[INBOUNDFIREWALLRULESTRNUM];    

    for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
        memset(inboundRulesList[i], 0x0, INBOUNDFIREWALLRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;  

    //Compute the number of ipv6 inbound firewall rule list
    nv = nvp = strdup(nmp_safe_get("ipv6_fw_rulelist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(inboundRulesList[rulelist_count], b);
            rulelist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(serviceNameStr, 0x0, 128);
            strncpy(serviceNameStr, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, INBOUNDFIREWALLRULESTRNUM);
            if((index+1) > rulelist_count)
                real_index = rulelist_count;
            else
                real_index = index; 
            
            if(inboundRulesList[real_index][0]) {
                if(vstrsep(inboundRulesList[real_index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", serviceNameStr, remoteIp, localIp, portRange, proto);
            }
            else
                sprintf(string, "%s>>>>", serviceNameStr);  

            strcpy(inboundRulesList[real_index], string);
                    
            //Re-generate ipv6 inbound firewall rule list
            for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
            {
                char entry_str[INBOUNDFIREWALLRULESTRNUM];
                memset(entry_str, 0x0, INBOUNDFIREWALLRULESTRNUM);
                if(inboundRulesList[i][0]) {
                    sprintf(entry_str, "<%s", inboundRulesList[i]);
                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("ipv6_fw_rulelist", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_inboundFirewallRulesRemoteIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char inboundRulesList[MAXINBOUNDFIREWALLRULES][INBOUNDFIREWALLRULESTRNUM];
    int i, rulelist_count = 0;
    char *nv, *nvp, *b, *servicename, *remoteIp, *localIp, *portRange, *proto;
    char remoteIpstr[40], string[INBOUNDFIREWALLRULESTRNUM];    

    for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
        memset(inboundRulesList[i], 0x0, INBOUNDFIREWALLRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;  

    //Compute the number of ipv6 inbound firewall rule list
    nv = nvp = strdup(nmp_safe_get("ipv6_fw_rulelist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(inboundRulesList[rulelist_count], b);
            rulelist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 39 ) {
              fprintf(stderr, "write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(remoteIpstr, 0x0, 40);
            strncpy(remoteIpstr, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, INBOUNDFIREWALLRULESTRNUM);
            if((index+1) > rulelist_count)
                real_index = rulelist_count;
            else
                real_index = index; 
            
            if(inboundRulesList[real_index][0]) {
                if(vstrsep(inboundRulesList[real_index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", servicename, remoteIpstr, localIp, portRange, proto);
            }
            else
                sprintf(string, ">%s>>>", remoteIpstr);  

            strcpy(inboundRulesList[real_index], string);
                    
            //Re-generate ipv6 inbound firewall rule list
            for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
            {
                char entry_str[INBOUNDFIREWALLRULESTRNUM];
                memset(entry_str, 0x0, INBOUNDFIREWALLRULESTRNUM);
                if(inboundRulesList[i][0]) {
                    sprintf(entry_str, "<%s", inboundRulesList[i]);
                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("ipv6_fw_rulelist", tmpstr);                   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_inboundFirewallRulesLocalIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char inboundRulesList[MAXINBOUNDFIREWALLRULES][INBOUNDFIREWALLRULESTRNUM];
    int i, rulelist_count = 0;
    char *nv, *nvp, *b, *servicename, *remoteIp, *localIp, *portRange, *proto;
    char localIpstr[40], string[INBOUNDFIREWALLRULESTRNUM];    

    for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
        memset(inboundRulesList[i], 0x0, INBOUNDFIREWALLRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;  

    //Compute the number of ipv6 inbound firewall rule list
    nv = nvp = strdup(nmp_safe_get("ipv6_fw_rulelist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(inboundRulesList[rulelist_count], b);
            rulelist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 39 ) {
              fprintf(stderr, "write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(localIpstr, 0x0, 40);
            strncpy(localIpstr, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, INBOUNDFIREWALLRULESTRNUM);
            if((index+1) > rulelist_count)
                real_index = rulelist_count;
            else
                real_index = index; 
            
            if(inboundRulesList[real_index][0]) {
                if(vstrsep(inboundRulesList[real_index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", servicename, remoteIp, localIpstr, portRange, proto);
            }
            else
                sprintf(string, ">>%s>>", localIpstr);  

            strcpy(inboundRulesList[real_index], string);
                    
            //Re-generate ipv6 inbound firewall rule list
            for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
            {
                char entry_str[INBOUNDFIREWALLRULESTRNUM];
                memset(entry_str, 0x0, INBOUNDFIREWALLRULESTRNUM);
                if(inboundRulesList[i][0]) {
                    sprintf(entry_str, "<%s", inboundRulesList[i]);
                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("ipv6_fw_rulelist", tmpstr);                     
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_inboundFirewallRulesPortRange(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char inboundRulesList[MAXINBOUNDFIREWALLRULES][INBOUNDFIREWALLRULESTRNUM];
    int i, rulelist_count = 0;
    char *nv, *nvp, *b, *servicename, *remoteIp, *localIp, *portRange, *proto;
    char portRangestr[128], string[INBOUNDFIREWALLRULESTRNUM];    

    for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
        memset(inboundRulesList[i], 0x0, INBOUNDFIREWALLRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;  

    //Compute the number of ipv6 inbound firewall rule list
    nv = nvp = strdup(nmp_safe_get("ipv6_fw_rulelist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(inboundRulesList[rulelist_count], b);
            rulelist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to firewall not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(portRangestr, 0x0, 128);
            strncpy(portRangestr, (u_char *)var_val, var_val_len);     

            memset(string, 0x0, INBOUNDFIREWALLRULESTRNUM);
            if((index+1) > rulelist_count)
                real_index = rulelist_count;
            else
                real_index = index; 
            
            if(inboundRulesList[real_index][0]) {
                if(vstrsep(inboundRulesList[real_index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", servicename, remoteIp, localIp, portRangestr, proto);
            }
            else
                sprintf(string, ">>>%s>", portRangestr);  

            strcpy(inboundRulesList[real_index], string);
                    
            //Re-generate ipv6 inbound firewall rule list
            for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
            {
                char entry_str[INBOUNDFIREWALLRULESTRNUM];
                memset(entry_str, 0x0, INBOUNDFIREWALLRULESTRNUM);
                if(inboundRulesList[i][0]) {
                    sprintf(entry_str, "<%s", inboundRulesList[i]);
                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("ipv6_fw_rulelist", tmpstr);                   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_inboundFirewallRulesProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;    
    static long index, real_index;
    char inboundRulesList[MAXINBOUNDFIREWALLRULES][INBOUNDFIREWALLRULESTRNUM];
    int i, rulelist_count = 0;
    char *nv, *nvp, *b, *servicename, *remoteIp, *localIp, *portRange, *proto;
    char protostr[8], string[INBOUNDFIREWALLRULESTRNUM];    

    for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
        memset(inboundRulesList[i], 0x0, INBOUNDFIREWALLRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;  
    value = * (long *) var_val;

    //Compute the number of ipv6 inbound firewall rule list
    nv = nvp = strdup(nmp_safe_get("ipv6_fw_rulelist"));

    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(inboundRulesList[rulelist_count], b);
            rulelist_count++;       
        }
        free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(protostr, 0x0, 128);

            if(value == 1)//tcp
                strcpy(protostr, "TCP");
            else if(value ==2)//udp 
                strcpy(protostr, "UDP");
            else if(value ==3)//both      
                strcpy(protostr, "BOTH");
            else if(value ==4)//other
                strcpy(protostr, "OTHER");

            memset(string, 0x0, INBOUNDFIREWALLRULESTRNUM);
            if((index+1) > rulelist_count)
                real_index = rulelist_count;
            else
                real_index = index; 
            
            if(inboundRulesList[real_index][0]) {
                if(vstrsep(inboundRulesList[real_index], ">", &servicename, &remoteIp, &localIp, &portRange, &proto) != 5) break;
                sprintf(string, "%s>%s>%s>%s>%s", servicename, remoteIp, localIp, portRange, protostr);
            }
            else
                sprintf(string, ">>>>%s", protostr);  

            strcpy(inboundRulesList[real_index], string);
                    
            //Re-generate ipv6 inbound firewall rule list
            for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
            {
                char entry_str[INBOUNDFIREWALLRULESTRNUM];
                memset(entry_str, 0x0, INBOUNDFIREWALLRULESTRNUM);
                if(inboundRulesList[i][0]) {
                    sprintf(entry_str, "<%s", inboundRulesList[i]);
                    strcat(tmpstr, entry_str);
                }
            }

            nmp_set("ipv6_fw_rulelist", tmpstr);                    
                           
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_inboundFirewallRulesDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;    
    static long index, real_index;
    char inboundRulesList[MAXINBOUNDFIREWALLRULES][INBOUNDFIREWALLRULESTRNUM];
    int i, rulelist_count = 0;
    char *nv, *nvp, *b, *servicename, *remoteIp, *localIp, *portRange, *proto;
    char protostr[8], string[INBOUNDFIREWALLRULESTRNUM];    

    for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
        memset(inboundRulesList[i], 0x0, INBOUNDFIREWALLRULESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;  
    value = * (long *) var_val;

    //Compute the number of ipv6 inbound firewall rule list
    nv = nvp = strdup(nmp_safe_get("ipv6_fw_rulelist"));
    
    if (nv) {
        while ((b = strsep(&nvp, "<")) != NULL) {
            if (strlen(b)==0) continue;
            strcpy(inboundRulesList[rulelist_count], b);
            rulelist_count++;       
        }
        free(nv);
    }    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to firewall not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to firewall: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf(stderr, "write to firewall: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }  
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < rulelist_count)
             {
                memset(inboundRulesList[index], 0x0, INBOUNDFIREWALLRULESTRNUM);

                //Re-generate ipv6 inbound firewall rule list
                for(i = 0; i < MAXINBOUNDFIREWALLRULES; i++)
                {
                    char entry_str[INBOUNDFIREWALLRULESTRNUM];
                    memset(entry_str, 0x0, INBOUNDFIREWALLRULESTRNUM);
                    if(inboundRulesList[i][0]) {
                        sprintf(entry_str, "<%s", inboundRulesList[i]);
                        strcat(tmpstr, entry_str);
                    }
                }

                nmp_set("ipv6_fw_rulelist", tmpstr);   
             }                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
