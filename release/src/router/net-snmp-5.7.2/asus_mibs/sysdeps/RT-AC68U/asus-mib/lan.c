/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "lan.h"
#include <nmp.h>

#define MAXDHCPSTATIC	32
#define DHCPSTATICSTRNUM	40
#define MAX_CLIENT_LIST	255
#define MACSTRNUM	18
#define STATICROUTESTRNUM	80
#define MAXSTATICROUTE	32
static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
int client_count = 0;
client_list_info_t client_list[MAX_CLIENT_LIST];
static int sw_mode = 0;

/* 
 * lan_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid lan_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,2 };

/* 
 * variable7 lan_variables:
 *   this variable defines function callbacks and type return information 
 *   for the lan mib section 
 */

struct variable7 lan_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define LGETIPAUTOMATICALLY		1
{LGETIPAUTOMATICALLY,  ASN_INTEGER,  RWRITE,  var_lan, 2,  { 1,1 }},
#define LIPADDRESS		2
{LIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_lan, 2,  { 1,2 }},
#define LSUBNETMASK		3
{LSUBNETMASK,  ASN_IPADDRESS,  RWRITE,  var_lan, 2,  { 1,3 }},
#define LDEFAULTGATEWAY		4
{LDEFAULTGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_lan, 2,  { 1,4 }},
#define LCONNECTTODNSSERVERAUTOMATICALLY		5
{LCONNECTTODNSSERVERAUTOMATICALLY,  ASN_INTEGER,  RWRITE,  var_lan, 2,  { 1,5 }},
#define LDNSSERVER1		6
{LDNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_lan, 2,  { 1,6 }},
#define LDNSSERVER2		7
{LDNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_lan, 2,  { 1,7 }},
#define ENABLEDHCPSERVER		8
{ENABLEDHCPSERVER,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 2,1,1 }},
#define DOMAINNAME		9
{DOMAINNAME,  ASN_OCTET_STR,  RWRITE,  var_lan, 3,  { 2,1,2 }},
#define IPPOOLSTARTINGADDRESS		10
{IPPOOLSTARTINGADDRESS,  ASN_IPADDRESS,  RWRITE,  var_lan, 3,  { 2,1,3 }},
#define IPPOOLENDINGADDRESS		11
{IPPOOLENDINGADDRESS,  ASN_IPADDRESS,  RWRITE,  var_lan, 3,  { 2,1,4 }},
#define LEASETIME		12
{LEASETIME,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 2,1,5 }},
#define DEFAULTGATEWAY		13
{DEFAULTGATEWAY,  ASN_OCTET_STR,  RWRITE,  var_lan, 3,  { 2,1,6 }},
#define DNSSERVER		14
{DNSSERVER,  ASN_OCTET_STR,  RWRITE,  var_lan, 3,  { 2,2,1 }},
#define WINSSERVER		15
{WINSSERVER,  ASN_OCTET_STR,  RWRITE,  var_lan, 3,  { 2,2,2 }},
#define ENABLEMANUALASSIGNMENT		16
{ENABLEMANUALASSIGNMENT,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 2,3,1 }},
#define DSCLIENTLISTACT		17
{DSCLIENTLISTACT,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 2,3,2 }},
#define ENABLESTATICROUTES		18
{ENABLESTATICROUTES,  ASN_INTEGER,  RWRITE,  var_lan, 2,  { 3,1 }},
#define RCLIENTLISTACT		19
{RCLIENTLISTACT,  ASN_INTEGER,  RWRITE,  var_lan, 2,  { 3,2 }},
#define SELECTISPPROFILE		20
{SELECTISPPROFILE,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,1,1 }},
#define IPTVSTBPORT		21
{IPTVSTBPORT,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,1,2 }},
#define VOIPPORT		22
{VOIPPORT,  ASN_OCTET_STR,  RONLY ,  var_lan, 3,  { 4,1,3 }},
#define INTERNETVID		23
{INTERNETVID,  ASN_OCTET_STR,  RWRITE,  var_lan, 3,  { 4,1,4 }},
#define INTERNETPRIO		24
{INTERNETPRIO,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,1,5 }},
#define LAN4PORTVID		25
{LAN4PORTVID,  ASN_OCTET_STR,  RWRITE,  var_lan, 3,  { 4,1,6 }},
#define LAN4PORTPRIO		26
{LAN4PORTPRIO,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,1,7 }},
#define LAN3PORTVID		27
{LAN3PORTVID,  ASN_OCTET_STR,  RWRITE,  var_lan, 3,  { 4,1,8 }},
#define LAN3PORTPRIO		28
{LAN3PORTPRIO,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,1,9 }},
#define USEDHCPROUTES		29
{USEDHCPROUTES,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,2,1 }},
#define ENABLEMULTICASTROUTING		30
{ENABLEMULTICASTROUTING,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,2,2 }},
#define ENABLEEFFICIENTMULTICASTFORWARDING		31
{ENABLEEFFICIENTMULTICASTFORWARDING,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,2,3 }},
#define UDPPROXY		32
{UDPPROXY,  ASN_INTEGER,  RWRITE,  var_lan, 3,  { 4,2,4 }},
#define ENABLEJUMBOFRAME		33
{ENABLEJUMBOFRAME,  ASN_INTEGER,  RWRITE,  var_lan, 2,  { 5,1 }},
#define ENABLENATACCELERATOR		34
{ENABLENATACCELERATOR,  ASN_INTEGER,  RWRITE,  var_lan, 2,  { 5,2 }},

#define DSCLIENTINDEX		35
{DSCLIENTINDEX,  ASN_INTEGER,  RONLY,   var_dsClientTable, 5,  { 2,3,3, 1, 1 }},
#define DSCLIENTMACADDR		36
{DSCLIENTMACADDR,  ASN_OCTET_STR,  RONLY,   var_dsClientTable, 5,  { 2,3,3, 1, 2 }},
#define DSCLIENTIPADDR		37
{DSCLIENTIPADDR,  ASN_IPADDRESS,  RONLY,   var_dsClientTable, 5,  { 2,3,3, 1, 3 }},
#define DSCLIENTNAME		38
{DSCLIENTNAME,  ASN_OCTET_STR,  RONLY,   var_dsClientTable, 5,  { 2,3,3, 1, 4 }},
#define ASSIGNEDIPINDEX		39
{ASSIGNEDIPINDEX,  ASN_INTEGER,  RONLY,   var_assignedIPTable, 5,  { 2,3,4, 1, 1 }},
#define ASSIGNEDIPMACADDR		40
{ASSIGNEDIPMACADDR,  ASN_OCTET_STR,  RWRITE,  var_assignedIPTable, 5,  { 2,3,4, 1, 2 }},
#define ASSIGNEDIPIPADDR		41
{ASSIGNEDIPIPADDR,  ASN_IPADDRESS,  RWRITE,  var_assignedIPTable, 5,  { 2,3,4, 1, 3 }},
#define ASSIGNEDIPDELENTRY		42
{ASSIGNEDIPDELENTRY,  ASN_INTEGER,  RWRITE,  var_assignedIPTable, 5,  { 2,3,4, 1, 4 }},
#define RCLIENTINDEX		43
{RCLIENTINDEX,  ASN_INTEGER,  RONLY,   var_rClientTable, 4,  { 3,3, 1, 1 }},
#define RCLIENTIPADDR		44
{RCLIENTIPADDR,  ASN_OCTET_STR,  RONLY,   var_rClientTable, 4,  { 3,3, 1, 2 }},
#define RCLIENTNAME		45
{RCLIENTNAME,  ASN_OCTET_STR,  RONLY,   var_rClientTable, 4,  { 3,3, 1, 3 }},
#define STATICROUTEINDEX		46
{STATICROUTEINDEX,  ASN_INTEGER,  RONLY,   var_staticRouteTable, 4,  { 3,4, 1, 1 }},
#define STATICROUTEIPADDR		47
{STATICROUTEIPADDR,  ASN_OCTET_STR,  RWRITE,  var_staticRouteTable, 4,  { 3,4, 1, 2 }},
#define STATICROUTENETMASK		48
{STATICROUTENETMASK,  ASN_IPADDRESS,  RWRITE,  var_staticRouteTable, 4,  { 3,4, 1, 3 }},
#define STATICROUTEGATEWAY		49
{STATICROUTEGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_staticRouteTable, 4,  { 3,4, 1, 4 }},
#define STATICROUTEMETRIC		50
{STATICROUTEMETRIC,  ASN_INTEGER,  RWRITE,  var_staticRouteTable, 4,  { 3,4, 1, 5 }},
#define STATICROUTEINTERFACE		51
{STATICROUTEINTERFACE,  ASN_INTEGER,  RWRITE,  var_staticRouteTable, 4,  { 3,4, 1, 6 }},
#define STATICROUTEDELENTRY		52
{STATICROUTEDELENTRY,  ASN_INTEGER,  RWRITE,  var_staticRouteTable, 4,  { 3,4, 1, 7 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the lan module */
void
init_lan(void)
{

    DEBUGMSGTL(("lan", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("lan", lan_variables, variable7,
               lan_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_lan():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_lan(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case LGETIPAUTOMATICALLY:
		if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)
		{
			*write_method = write_lGetIpAutomatically;
			if(nmp_safe_get("lan_proto") != NULL)
			{
				if(!strcmp(nmp_get("lan_proto"), "dhcp")) /* dhcp */
					tmpval = 1;
				else if(!strcmp(nmp_get("lan_proto"), "static")) /* static */
					tmpval = 2;
			}
			else
				return NULL;
		}
		else
			tmpval = 2;
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
    case LIPADDRESS:
        *write_method = write_lIPAddress;
		if(nmp_safe_get("lan_ipaddr") != NULL)
		{
			tmpval_u = inet_addr(nmp_safe_get("lan_ipaddr"));
			*var_len = sizeof( unsigned long );
			return ( u_char * ) &tmpval_u;
		}
		return NULL;
    case LSUBNETMASK:
        *write_method = write_lSubnetMask;
		if(nmp_safe_get("lan_netmask") != NULL)
		{
			tmpval_u = inet_addr(nmp_safe_get("lan_netmask"));
			*var_len = sizeof( unsigned long );
			return ( u_char * ) &tmpval_u;
		}
		return NULL;
    case LDEFAULTGATEWAY:
		if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)
		{
			*write_method = write_lDefaultGateway;
			if(nmp_safe_get("lan_gateway") != NULL)
			{
				tmpval_u = inet_addr(nmp_safe_get("lan_gateway"));
				*var_len = sizeof( unsigned long );
				return ( u_char * ) &tmpval_u;
			}
		}
		return NULL;
    case LCONNECTTODNSSERVERAUTOMATICALLY:
		if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)
		{
			*write_method = write_lConnectToDnsServerAutomatically;
			if(nmp_safe_get("lan_dnsenable_x") != NULL)
			{
				tmpval = nmp_get_int("lan_dnsenable_x");
				if(tmpval == 1) /* enable */
					tmpval = 1;
				else if(tmpval == 0) /* disable */
					tmpval = 2;
		      	*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case LDNSSERVER1:
		if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)
		{
			*write_method = write_lDnsServer1;
			if(nmp_safe_get("lan_dns1_x") != NULL)
			{
	            memset(tmpstr, 0, SPRINT_MAX_LEN);
	            strcpy(tmpstr, nmp_safe_get("lan_dns1_x"));
	            tmpstr[strlen(tmpstr)] = '\0';
	            *var_len = strlen( tmpstr );
	            return ( u_char * ) tmpstr;
	        }
		}
		return NULL;
    case LDNSSERVER2:
		if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)
		{
			*write_method = write_lDnsServer2;
			if(nmp_safe_get("lan_dns2_x") != NULL)
			{
	            memset(tmpstr, 0, SPRINT_MAX_LEN);
	            strcpy(tmpstr, nmp_safe_get("lan_dns2_x"));
	            tmpstr[strlen(tmpstr)] = '\0';
	            *var_len = strlen( tmpstr );
	            return ( u_char * ) tmpstr; 	
			}
		}
		return NULL;
    case ENABLEDHCPSERVER:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_enableDHCPServer;
			if(nmp_safe_get("dhcp_enable_x") != NULL)
			{
				tmpval = nmp_get_int("dhcp_enable_x");
				if(tmpval == 1) /* enable */
					tmpval = 1;
				else if(tmpval == 0) /* disable */
					tmpval = 2;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case DOMAINNAME:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_domainName;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			if(nmp_safe_get("lan_domain") != NULL)
			{
				strcpy(tmpstr, nmp_safe_get("lan_domain"));
				tmpstr[strlen(tmpstr)] = '\0';
				*var_len = strlen( tmpstr );
				return ( u_char * ) tmpstr;	
			}
		}
        return NULL;
    case IPPOOLSTARTINGADDRESS:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_ipPoolStartingAddress;
			if(nmp_safe_get("dhcp_start") != NULL)
			{
				tmpval_u = inet_addr(nmp_safe_get("dhcp_start"));
				*var_len = sizeof( unsigned long );
				return ( u_char * ) &tmpval_u;
			}
		}
		return NULL;
    case IPPOOLENDINGADDRESS:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_ipPoolEndingAddress;
			if(nmp_safe_get("dhcp_end") != NULL)
			{
				tmpval_u = inet_addr(nmp_safe_get("dhcp_end"));
				*var_len = sizeof( unsigned long );
				return ( u_char * ) &tmpval_u;
			}
		}
		return NULL;
    case LEASETIME:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_leaseTime;
			if(nmp_safe_get("dhcp_lease") != NULL)
		      	{
				tmpval = nmp_get_int("dhcp_lease");
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
		      	}
		}
        return NULL;
    case DEFAULTGATEWAY:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_defaultGateway;
			if(nmp_safe_get("dhcp_gateway_x")!= NULL)
			{
				memset(tmpstr, 0, SPRINT_MAX_LEN);
				strcpy(tmpstr, nmp_safe_get("dhcp_gateway_x"));
				tmpstr[strlen(tmpstr)] = '\0';
				*var_len = strlen( tmpstr );
				return ( u_char * ) tmpstr;	
			}
		}
		return NULL;
    case DNSSERVER:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_dnsServer;
			if(nmp_safe_get("dhcp_dns1_x")!= NULL)
			{
				memset(tmpstr, 0, SPRINT_MAX_LEN);
				strcpy(tmpstr, nmp_safe_get("dhcp_dns1_x"));
				tmpstr[strlen(tmpstr)] = '\0';
				*var_len = strlen( tmpstr );
				return ( u_char * ) tmpstr;	
			}
		}
		return NULL;
    case WINSSERVER:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_winsServer;
			if(nmp_safe_get("dhcp_wins_x")!= NULL)
			{
				memset(tmpstr, 0, SPRINT_MAX_LEN);
				strcpy(tmpstr, nmp_safe_get("dhcp_wins_x"));
				tmpstr[strlen(tmpstr)] = '\0';
				*var_len = strlen( tmpstr );
				return ( u_char * ) tmpstr;	
			}
		}
		return NULL;
    case ENABLEMANUALASSIGNMENT:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_enableManualAssignment;
			if(nmp_safe_get("dhcp_static_x") != NULL)
			{
				tmpval = nmp_get_int("dhcp_static_x");
				if(tmpval == 1) /* enable */
					tmpval = 1;
				else if(tmpval == 0) /* disable */
					tmpval = 2;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case DSCLIENTLISTACT:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_dsClientListAct;
			*var_len = sizeof( long );
			tmpval = 2; /* 1: scan	2: nothing */
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case ENABLESTATICROUTES:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_enableStaticRoutes;
			if(nmp_safe_get("sr_enable_x") != NULL)
			{
				tmpval = nmp_get_int("sr_enable_x");
				if(tmpval == 1) /* enable */
					tmpval = 1;
				else if(tmpval == 0) /* disable */
					tmpval = 2;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case RCLIENTLISTACT:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_rClientListAct;
			*var_len = sizeof( long );
			tmpval = 2; /* 1: scan	2: nothing */
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case SELECTISPPROFILE:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_selectISPProfile;
			if(nmp_safe_get("switch_wantag") != NULL)
			{
				if(!strcmp(nmp_get("switch_wantag"), "none")) /* none */
					tmpval = 1;
				else if(!strcmp(nmp_get("switch_wantag"), "unifi_home")) /* unifi-home */
					tmpval = 2;
				else if(!strcmp(nmp_get("switch_wantag"), "unifi_biz")) /* unifi-business */
					tmpval = 3;
				else if(!strcmp(nmp_get("switch_wantag"), "singtel_mio")) /* singtel-mio */
					tmpval = 4;
				else if(!strcmp(nmp_get("switch_wantag"), "singtel_others")) /* singtel-others */
					tmpval = 5;
				else if(!strcmp(nmp_get("switch_wantag"), "m1_fiber")) /* m1-fiber */
					tmpval = 6;
				else if(!strcmp(nmp_get("switch_wantag"), "maxis_fiber")) /* maxis-fiber */
					tmpval = 7;
				else if(!strcmp(nmp_get("switch_wantag"), "maxis_fiber_sp")) /* maxis-fiber-special */
					tmpval = 8;
				else if(!strcmp(nmp_get("switch_wantag"), "manual")) /* manual */
					tmpval = 9;
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
        return NULL;
    case IPTVSTBPORT:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_iptvSTBPort;
			if(nmp_safe_get("switch_stb_x") != NULL)
			{
				tmpval = nmp_get_int("switch_stb_x");
				if( strcmp(nmp_safe_get("switch_wantag"), "none") )//If special ISP is selected, IPTV Port is always LAN4 if needed. 
					tmpval = 5;
				else if(tmpval == 0) /* none */
					tmpval = 1;
				else if(tmpval == 1) /* lan 1 */
					tmpval = 2;
				else if(tmpval == 2) /* lan 2 */
					tmpval = 3;
				else if(tmpval == 3) /* lan 3 */
					tmpval = 4;
				else if(tmpval == 4) /* lan 4 */
					tmpval = 5;
				else if(tmpval == 5) /* lan 1 & lan 2 */
					tmpval = 6;
				else if(tmpval == 6) /* lan 3 & lan 4 */
					tmpval = 7;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case VOIPPORT:
		if(sw_mode == SW_MODE_ROUTER)
		{
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			if(!strcmp(nmp_safe_get("switch_wantag"), "singtel_mio") || 
				!strcmp(nmp_safe_get("switch_wantag"), "m1_fiber") ||
				!strcmp(nmp_safe_get("switch_wantag"), "maxis_fiber") ||
				!strcmp(nmp_safe_get("switch_wantag"), "maxis_fiber_sp") ||
				!strcmp(nmp_safe_get("switch_wantag"), "manual") )
			{
				strcpy(tmpstr, "LAN3");
				tmpstr[strlen(tmpstr)] = '\0';
			}

			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;			
		}
      	return NULL;
    case INTERNETVID:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_internetVID;
			if(nmp_safe_get("switch_wan0tagid") != NULL)
			{
				memset(tmpstr, 0, SPRINT_MAX_LEN);
				sprintf(tmpstr, nmp_safe_get("switch_wan0tagid"));
				*var_len = strlen( tmpstr );
				return ( u_char * ) tmpstr;
			}
		}
        return NULL;
    case INTERNETPRIO:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_internetPRIO;
			if(nmp_safe_get("switch_wan0prio") != NULL)
			{
				tmpval = nmp_get_int("switch_wan0prio");
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
		    }
		}
        return NULL;
    case LAN4PORTVID:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_lan4PortVID;
			if(nmp_safe_get("switch_wan1tagid") != NULL)
			{
				memset(tmpstr, 0, SPRINT_MAX_LEN);
				sprintf(tmpstr, nmp_safe_get("switch_wan1tagid"));
				*var_len = strlen( tmpstr );
				return ( u_char * ) tmpstr;
			}
		}
        return NULL;
    case LAN4PORTPRIO:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_lan4PortPRIO;
			if(nmp_safe_get("switch_wan1prio") != NULL)
			{
				tmpval = nmp_get_int("switch_wan1prio");
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
        return NULL;
    case LAN3PORTVID:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_lan3PortVID;
			if(nmp_safe_get("switch_wan2tagid") != NULL)
			{
				memset(tmpstr, 0, SPRINT_MAX_LEN);
				sprintf(tmpstr, nmp_safe_get("switch_wan2tagid"));
				*var_len = strlen( tmpstr );
				return ( u_char * ) tmpstr;
			}
		}
        return NULL;
    case LAN3PORTPRIO:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_lan3PortPRIO;
			if(nmp_safe_get("switch_wan2prio") != NULL)
			{
				tmpval = nmp_get_int("switch_wan2prio");
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
        return NULL;
    case USEDHCPROUTES:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_useDHCPRoutes;
			if(nmp_safe_get("dr_enable_x") != NULL)
			{
				tmpval = nmp_get_int("dr_enable_x");
				if(tmpval == 0) /* disable */
					tmpval = 1;
				else if(tmpval == 1) /* microsoft */
					tmpval = 2;
				else if(tmpval == 2) /* rfc3442 */
					tmpval = 3;
				else if(tmpval == 3) /* rfc3442 & microsoft*/
					tmpval = 4;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case ENABLEMULTICASTROUTING:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_enableMulticastRouting;
			if(nmp_safe_get("mr_enable_x") != NULL)
			{
				tmpval = nmp_get_int("mr_enable_x");
				if(tmpval == 1) /* enable */
					tmpval = 1;
				else if(tmpval == 0) /* disable */
					tmpval = 2;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case ENABLEEFFICIENTMULTICASTFORWARDING:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_enableEfficientMulticastForwarding;
			if(nmp_safe_get("emf_enable") != NULL)
			{
				tmpval = nmp_get_int("emf_enable");
				if(tmpval == 1) /* enable */
					tmpval = 1;
				else if(tmpval == 0) /* disable */
					tmpval = 2;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case UDPPROXY:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_udpProxy;
			if(nmp_safe_get("udpxy_enable_x") != NULL)
		      	{
				tmpval = nmp_get_int("udpxy_enable_x");
				*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
		      	}
		}
        return NULL;
    case ENABLEJUMBOFRAME:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_enableJumboFrame;
			if(nmp_safe_get("jumbo_frame_enable") != NULL)
			{
				tmpval = nmp_get_int("jumbo_frame_enable");
				if(tmpval == 1) /* enable */
					tmpval = 1;
				else if(tmpval == 0) /* disable */
					tmpval = 2;
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    case ENABLENATACCELERATOR:
		if(sw_mode == SW_MODE_ROUTER)
		{
			*write_method = write_enableNATAccelerator;
			if(nmp_safe_get("ctf_disable_force") != NULL)
			{
				tmpval = nmp_get_int("ctf_disable_force");
				if(tmpval == 0) {	/* enable */
					if(!nmp_safe_get("ctf_fa_mode"))	// chip not support ctf-L2
						tmpval = 2;
					else {
						tmpval = nmp_get_int("ctf_fa_mode");
						if(tmpval == 0)
							tmpval = 2;		// ctf-L1
						else if(tmpval == 2)
							tmpval = 3;		// ctf-L2
						else
							return NULL;
					}
				}	
				/* tmpval=1 ==> disable(1) */
		      		*var_len = sizeof( long );
				return ( u_char * ) &tmpval;
			}
		}
		return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_dsClientTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lan above.
 */
unsigned char *
var_dsClientTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_CLIENT_LIST /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case DSCLIENTINDEX:
        return NULL;
    case DSCLIENTMACADDR:
        index = name[*length-1]-1;
    	if(index < client_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%02X:%02X:%02X:%02X:%02X:%02X", client_list[index].mac_addr[0],
								client_list[index].mac_addr[1],
								client_list[index].mac_addr[2],
								client_list[index].mac_addr[3],
								client_list[index].mac_addr[4],
								client_list[index].mac_addr[5]);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    case DSCLIENTIPADDR:
        index = name[*length-1]-1;
    	if(index < client_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%d.%d.%d.%d", client_list[index].ip_addr[0],
						client_list[index].ip_addr[1],
						client_list[index].ip_addr[2],
						client_list[index].ip_addr[3]);

		tmpval_u = inet_addr(tmpstr);
		*var_len = sizeof( unsigned long );
		return ( u_char * ) &tmpval_u;			
    	}	
        return NULL;
    case DSCLIENTNAME:
        index = name[*length-1]-1;
    	if(index < client_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%s", client_list[index].device_name);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_assignedIPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lan above.
 */
unsigned char *
var_assignedIPTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char dhcp_staticlist[MAXDHCPSTATIC][DHCPSTATICSTRNUM];
    int i, dhcp_staticlist_count = 0;
    char *nv, *nvp, *b, *mac, *ip;

    for(i = 0; i < MAXDHCPSTATIC; i++)
    	memset(dhcp_staticlist[i], 0x0, DHCPSTATICSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("dhcp_staticlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(dhcp_staticlist[dhcp_staticlist_count], b);
		dhcp_staticlist_count++;		
	}
	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXDHCPSTATIC /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case ASSIGNEDIPINDEX:
        return NULL;
    case ASSIGNEDIPMACADDR:
        *write_method = write_assignedIPMACAddr;
		index = name[*length-1]-1;
        if(index <= dhcp_staticlist_count-1) {
        	if (strlen(dhcp_staticlist[index])) {
				if((vstrsep(dhcp_staticlist[index], ">", &mac, &ip) != 2)) break;
				ether_atoe(mac, tmpstr);
			}
    	}
		*var_len = 6;
     	return ( u_char * )tmpstr;
    case ASSIGNEDIPIPADDR:
        *write_method = write_assignedIPIPAddr;
		tmpval_u = 0;
		index = name[*length-1]-1;
        if(index <= dhcp_staticlist_count-1) {
        	if (strlen(dhcp_staticlist[index])) {
				if((vstrsep(dhcp_staticlist[index], ">", &mac, &ip) != 2)) break;
				tmpval_u = inet_addr(ip);
			}
    	}
		*var_len = sizeof( unsigned long );
		return ( u_char * ) &tmpval_u;
    case ASSIGNEDIPDELENTRY:
        *write_method = write_assignedIPDelEntry;
    	tmpval = 2; /* no */
 		*var_len = sizeof( long );
      	return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_rClientTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lan above.
 */
unsigned char *
var_rClientTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[*length-1]-1;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_CLIENT_LIST /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case RCLIENTINDEX:
        return NULL;
    case RCLIENTIPADDR:
    	if(index < client_count)
    	{
    		sprintf(tmpstr, "%d.%d.%d.%d", client_list[index].ip_addr[0],
						client_list[index].ip_addr[1],
						client_list[index].ip_addr[2],
						client_list[index].ip_addr[3]);
			*var_len = strlen(tmpstr);
			return ( u_char * )tmpstr;			
    	}	
        return NULL;
    case RCLIENTNAME:
    	if(index < client_count)
    	{
    		sprintf(tmpstr, "%s", client_list[index].device_name);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_staticRouteTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lan above.
 */
unsigned char *
var_staticRouteTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char sr_rulelist[MAXSTATICROUTE][STATICROUTESTRNUM];
    int i, sr_rulelist_count = 0;
    char *nv, *nvp, *b, *ip, *netmask, *gateway, *metric, *interface;

    for(i = 0; i < MAXSTATICROUTE; i++)
    	memset(sr_rulelist[i], 0x0, STATICROUTESTRNUM);

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of start route rule list
    nv = nvp = strdup(nmp_safe_get("sr_rulelist"));
    if (nv) {
		while ((b = strsep(&nvp, "<")) != NULL) {
			if (strlen(b)==0) continue;
			strcpy(sr_rulelist[sr_rulelist_count], b);
			sr_rulelist_count++;		
		}
		free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXSTATICROUTE /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case STATICROUTEINDEX:
        return NULL;
    case STATICROUTEIPADDR:
        *write_method = write_staticRouteIPAddr;
		index = name[*length-1]-1;
        if(index <= sr_rulelist_count-1) {
        	if (strlen(sr_rulelist[index])) {
				if(vstrsep(sr_rulelist[index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5) break;
				strcpy(tmpstr, ip);
			}
    	}
		*var_len = strlen(tmpstr);
		return ( u_char * )tmpstr;;
    case STATICROUTENETMASK:
        *write_method = write_staticRouteNetmask;
		tmpval_u = 0;
		index = name[*length-1]-1;
        if(index <= sr_rulelist_count-1) {
			if (strlen(sr_rulelist[index])) {
				if(vstrsep(sr_rulelist[index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5) break;
				tmpval_u = inet_addr(netmask);
			}
    	}
		*var_len = sizeof( unsigned long );
		return ( u_char * ) &tmpval_u;
    case STATICROUTEGATEWAY:
        *write_method = write_staticRouteGateway;
		tmpval_u = 0;
		index = name[*length-1]-1;
        if(index <= sr_rulelist_count-1) {
			if (strlen(sr_rulelist[index])) {
				if((vstrsep(sr_rulelist[index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5)) break;
				tmpval_u = inet_addr(gateway);
			}
    	}
		*var_len = sizeof( unsigned long );
		return ( u_char * ) &tmpval_u;
    case STATICROUTEMETRIC:
        *write_method = write_staticRouteMetric;
		tmpval = 0;
		index = name[*length-1]-1;
        if(index <= sr_rulelist_count-1) {
			if (strlen(sr_rulelist[index])) {
				if((vstrsep(sr_rulelist[index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5)) break;
				tmpval = atoi(metric);
			}
    	}
		*var_len = sizeof( unsigned long );
		return ( u_char * ) &tmpval;
    case STATICROUTEINTERFACE:
        *write_method = write_staticRouteInterface;
		tmpval = 0;
		index = name[*length-1]-1;
        if(index <= sr_rulelist_count-1) {
			if (strlen(sr_rulelist[index])) {
				if((vstrsep(sr_rulelist[index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5)) break;
			
				if(!strcmp(interface, "LAN"))
					tmpval = 1;
				else if(!strcmp(interface, "MAN"))
					tmpval = 2;
				else if(!strcmp(interface, "WAN"))
					tmpval = 3;
			}
    	}
		*var_len = sizeof( unsigned long );
		return ( u_char * ) &tmpval;
    case STATICROUTEDELENTRY:
        *write_method = write_staticRouteDelEntry;
    	tmpval = 2; /* no */
 		*var_len = sizeof(unsigned long);
      	return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_lGetIpAutomatically(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
					nmp_set("lan_proto", "dhcp");
             	else if(value == 2)
					nmp_set("lan_proto", "static");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
	struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("lan_ipaddr", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lSubnetMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("lan_netmask", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lDefaultGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("lan_gateway", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lConnectToDnsServerAutomatically(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if(value == 1)
				nmp_set("lan_dnsenable_x", "1");
            else if(value == 2)
				nmp_set("lan_dnsenable_x", "0");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lDnsServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';              
            nmp_set("lan_dns1_x", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lDnsServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }  
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';              
            nmp_set("lan_dns2_x", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableDHCPServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("dhcp_enable_x", "1");
             	else if(value == 2)
			nmp_set("dhcp_enable_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_domainName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len > 253 ) {
              fprintf(stderr, "write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  strncpy(tmpstr, (u_char *)var_val, var_val_len); 
	  tmpstr[var_val_len] = '\0';
          nmp_set("lan_domain", tmpstr); 			
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipPoolStartingAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("dhcp_start", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ipPoolEndingAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("dhcp_end", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_leaseTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("dhcp_lease", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_defaultGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to defaultGateway not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to defaultGateway: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
	     strncpy(tmpstr, (u_char *)var_val, var_val_len); 
	     tmpstr[var_val_len] = '\0';
             nmp_set("dhcp_gateway_x", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dnsServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to dnsServer not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15 ) {
              fprintf(stderr,"write to dnsServer: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
	     strncpy(tmpstr, (u_char *)var_val, var_val_len); 
	     tmpstr[var_val_len] = '\0';
             nmp_set("dhcp_dns1_x", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_winsServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to winsServer not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to winsServer: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
	     strncpy(tmpstr, (u_char *)var_val, var_val_len); 
	     tmpstr[var_val_len] = '\0';
             nmp_set("dhcp_wins_x", tmpstr); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableManualAssignment(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("dhcp_static_x", "1");
             	else if(value == 2)
			nmp_set("dhcp_static_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dsClientListAct(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1) {
    		client_count = get_client_detail_info(&client_list);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableStaticRoutes(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("sr_enable_x", "1");
             	else if(value == 2)
			nmp_set("sr_enable_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_rClientListAct(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1) {
    		client_count = get_client_detail_info(&client_list);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_selectISPProfile(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9) {
              fprintf(stderr, "write to lan: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
      		switch(value)
      		{
      			case 1:/* none */
					nmp_set("switch_wantag", "none");
					nmp_set("switch_stb_x", "0");
					break;
      			case 2:/* unifi-home */
					nmp_set("switch_wantag", "unifi_home");
					nmp_set("switch_stb_x", "4");
					nmp_set("switch_wan0tagid", "500");
					nmp_set("switch_wan0tagid", "500");
					nmp_set("switch_wan0prio", "0");
					nmp_set("switch_wan1tagid", "600");
					nmp_set("switch_wan1prio", "0");
					nmp_set("switch_wan2tagid", "");
					nmp_set("switch_wan2prio", "0");
					break;
      			case 3:	/* unifi-business */
					nmp_set("switch_wantag", "unifi_biz");
					nmp_set("switch_stb_x", "0");
					nmp_set("switch_wan0tagid", "500");
					nmp_set("switch_wan0prio", "0");
					nmp_set("switch_wan1tagid", "");
					nmp_set("switch_wan1prio", "0");
					nmp_set("switch_wan2tagid", "");
					nmp_set("switch_wan2prio", "0");
					break;
				case 4:/* singtel-mio */
					nmp_set("switch_wantag", "singtel_mio");
					nmp_set("switch_stb_x", "6");
					nmp_set("switch_wan0tagid", "10");
					nmp_set("switch_wan0prio", "0");
					nmp_set("switch_wan1tagid", "20");
					nmp_set("switch_wan1prio", "4");
					nmp_set("switch_wan2tagid", "30");
					nmp_set("switch_wan2prio", "4");	
					break;
      			case 5:/* singtel-others */
					nmp_set("switch_wantag", "singtel_others");
					nmp_set("switch_stb_x", "4");
					nmp_set("switch_wan0tagid", "10");
					nmp_set("switch_wan0prio", "0");
					nmp_set("switch_wan1tagid", "20");
					nmp_set("switch_wan1prio", "4");
					nmp_set("switch_wan2tagid", "");
					nmp_set("switch_wan2prio", "0");
					break;
      			case 6:	/* m1-fiber */
					nmp_set("switch_wantag", "m1_fiber");
					nmp_set("switch_stb_x", "3");
					nmp_set("switch_wan0tagid", "1103");
					nmp_set("switch_wan0prio", "1");
					nmp_set("switch_wan1tagid", "");
					nmp_set("switch_wan1prio", "0");
					nmp_set("switch_wan2tagid", "1107");
					nmp_set("switch_wan2prio", "1");
					break;
				case 7:/* maxis-fiber */
					nmp_set("switch_wantag", "maxis_fiber");
					nmp_set("switch_stb_x", "3");
					nmp_set("switch_wan0tagid", "621");
					nmp_set("switch_wan0prio", "0");
					nmp_set("switch_wan1tagid", "");
					nmp_set("switch_wan1prio", "0");
					nmp_set("switch_wan2tagid", "821,822");
					nmp_set("switch_wan2prio", "0");
					break;
      			case 8:/* maxis-fiber-special */
					nmp_set("switch_wantag", "maxis_fiber_sp");
					nmp_set("switch_stb_x", "3");
					nmp_set("switch_wan0tagid", "11");
					nmp_set("switch_wan0prio", "0");
					nmp_set("switch_wan1tagid", "");
					nmp_set("switch_wan1prio", "0");
					nmp_set("switch_wan2tagid", "14");
					nmp_set("switch_wan2prio", "0");
					break;
      			case 9:	/* manual */
					nmp_set("switch_wantag", "manual");
					break;
			}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iptvSTBPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    if( strcmp(nmp_safe_get("switch_wantag"), "none") ) /* This variable can be set only when the value of 'selectISPProfile' is 'none'. */
	return SNMP_ERR_NOTWRITABLE;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 7) {
              fprintf(stderr, "write to lan: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 7) {
      		switch(value)
      		{
      			case 1:/* none */
				nmp_set("switch_stb_x", "0");
				break;
      			case 2:/* lan 1 */
				nmp_set("switch_stb_x", "1");
				break;
      			case 3:	/* lan 2 */
				nmp_set("switch_stb_x", "2");
				break;
			case 4:/* lan 3 */
				nmp_set("switch_stb_x", "3");
				break;
      			case 5:/* lan 4 */
				nmp_set("switch_stb_x", "4");
				break;
      			case 6:	/* lan 1 & lan 2 */
				nmp_set("switch_stb_x", "5");
				break;
			case 7:/* lan 3 & lan 4 */
				nmp_set("switch_stb_x", "6");
				break;
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_internetVID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int value_i;
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
	return SNMP_ERR_NOTWRITABLE;		

    strncpy(string, (u_char *)var_val, var_val_len);
    string[var_val_len] = '\0';
    value_i = atoi(string);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to internetVID not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 4) {
              fprintf(stderr,"write to internetVID: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( value_i != 0 && (value_i < 2 || value_i > 4094) ) {
              fprintf(stderr, "write to internetVID: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
         break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */  
	     	nmp_set("switch_wan0tagid", string);	     
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_internetPRIO(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
	return SNMP_ERR_NOTWRITABLE;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to internetPRIO not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to internetPRIO: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 7) {
              fprintf(stderr, "write to internetPRIO: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			nmp_set_int("switch_wan0prio", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lan4PortVID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int value_i;
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
	return SNMP_ERR_NOTWRITABLE;

    strncpy(string, (u_char *)var_val, var_val_len);
    string[var_val_len] = '\0';
    value_i = atoi(string);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lan4PortVID not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 4) {
              fprintf(stderr,"write to lan4PortVID: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (value_i != 0 && (value_i < 2 || value_i > 4094)) {
              fprintf(stderr, "write to lan4PortVID: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set("switch_wan1tagid", string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lan4PortPRIO(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
	return SNMP_ERR_NOTWRITABLE;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan4PortPRIO not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan4PortPRIO: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 7) {
              fprintf(stderr, "write to lan4PortPRIO: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("switch_wan1prio", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lan3PortVID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int value_i;
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
	return SNMP_ERR_NOTWRITABLE;

    strncpy(string, (u_char *)var_val, var_val_len);
    string[var_val_len] = '\0';
    value_i = atoi(string);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lan3PortVID not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 4) {
              fprintf(stderr,"write to lan3PortVID: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (value_i != 0 && (value_i < 2 || value_i > 4094)) {
              fprintf(stderr, "write to lan3PortVID: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set("switch_wan2tagid", string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_lan3PortPRIO(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
	return SNMP_ERR_NOTWRITABLE;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan3PortPRIO not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan3PortPRIO: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 7) {
              fprintf(stderr, "write to lan3PortPRIO: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("switch_wan2prio", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_useDHCPRoutes(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 4) {
              fprintf(stderr, "write to lan: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 4) {
      		switch(value)
      		{
      			case 1:/* disable */
				nmp_set("dr_enable_x", "0");
				break;
      			case 2:/* microsoft */
				nmp_set("dr_enable_x", "1");
				break;
      			case 3:	/* rfc3442 */
				nmp_set("dr_enable_x", "2");
				break;
			case 4:/* rfc3442 & microsoft */
				nmp_set("dr_enable_x", "3");
				break;
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableMulticastRouting(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("mr_enable_x", "1");
             	else if(value == 2)
			nmp_set("mr_enable_x", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableEfficientMulticastForwarding(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("emf_enable", "1");
             	else if(value == 2)
			nmp_set("emf_enable", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_udpProxy(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("udpxy_enable_x", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableJumboFrame(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("jumbo_frame_enable", "1");
             	else if(value == 2)
			nmp_set("jumbo_frame_enable", "0");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableNATAccelerator(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3) {
             	if(value == 1) {	// disable ctf
			nmp_set("ctf_disable_force", "1");
			if(nmp_safe_get("ctf_fa_mode"))
				nmp_set("ctf_fa_mode", "0");
             	} else if(value == 2) {	// ctf-L1
			nmp_set("ctf_disable_force", "0");
			if(nmp_safe_get("ctf_fa_mode"))
				nmp_set("ctf_fa_mode", "0");
             	} else if(value == 3) {	// ctf-L2
			if(!nmp_safe_get("ctf_fa_mode"))	// chip not support ctf-L2
              			return SNMP_ERR_WRONGVALUE;
			nmp_set("ctf_disable_force", "0");
			nmp_set("ctf_fa_mode", "2");
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_assignedIPMACAddr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char dhcp_staticlist[MAXDHCPSTATIC][DHCPSTATICSTRNUM];
    int i, dhcp_staticlist_count = 0;
    char *nv, *nvp, *b, *mac, *ip;
    char macaddr[MACSTRNUM];
    char string[DHCPSTATICSTRNUM];

    for(i = 0; i < MAXDHCPSTATIC; i++)
    	memset(dhcp_staticlist[i], 0x0, DHCPSTATICSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("dhcp_staticlist"));
    if (nv) {
		while ((b = strsep(&nvp, "<")) != NULL) {
			if (strlen(b)==0) continue;
			strcpy(dhcp_staticlist[dhcp_staticlist_count], b);
			dhcp_staticlist_count++;
		}
		free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             ether_etoa(var_val, macaddr);
             if(strcmp("00:00:00:00:00:00", macaddr))
             {
		        memset(string, 0x0, sizeof(string));
				if((index+1) > dhcp_staticlist_count)
					real_index = dhcp_staticlist_count;
				else
					real_index = index;

				if(dhcp_staticlist[real_index][0]) {
					if((vstrsep(dhcp_staticlist[real_index], ">", &mac, &ip) != 2)) break;
					sprintf(string, "%s>%s", macaddr, ip);
				}
				else
					sprintf(string, "%s>", macaddr);	
				strcpy(dhcp_staticlist[real_index], string);
			
				//Re-generate dhcp_staticlist
				for(i = 0; i < MAXDHCPSTATIC; i++)
				{
					char entry_str[DHCPSTATICSTRNUM];
					memset(entry_str, 0x0, sizeof(entry_str));
					if(dhcp_staticlist[i][0]) {
						sprintf(entry_str, "<%s", dhcp_staticlist[i]);
						strcat(tmpstr, entry_str);
					}
				}

				nmp_set("dhcp_staticlist", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_assignedIPIPAddr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;
    static long index, real_index;
    char dhcp_staticlist[MAXDHCPSTATIC][DHCPSTATICSTRNUM];
    int i, dhcp_staticlist_count = 0;
    char *nv, *nvp, *b, *mac, *ip;
    char ipaddr[20];
    char string[DHCPSTATICSTRNUM];

    for(i = 0; i < MAXDHCPSTATIC; i++)
    	memset(dhcp_staticlist[i], 0x0, DHCPSTATICSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("dhcp_staticlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(dhcp_staticlist[dhcp_staticlist_count], b);
		dhcp_staticlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             //ether_etoa(var_val, macaddr);
             //if(strcmp("00:00:00:00:00:00", macaddr))
             //{
		//Convert ip address to string format
             	memset(ipaddr, 0, sizeof(ipaddr));
             	tmpval_u = *(u_long *)var_val;
             	addr.s_addr = tmpval_u;
             	strcpy(ipaddr, (char *)inet_ntoa(addr));

		memset(string, 0x0, sizeof(string));
		if((index+1) > dhcp_staticlist_count)
			real_index = dhcp_staticlist_count;
		else
			real_index = index;

		if(dhcp_staticlist[real_index][0]) {
			if((vstrsep(dhcp_staticlist[real_index], ">", &mac, &ip) != 2)) break;
			sprintf(string, "%s>%s", mac, ipaddr);
		}
		else
			sprintf(string, ">%s", ipaddr);	
		strcpy(dhcp_staticlist[real_index], string);
             	
		//Re-generate dhcp_staticlist
		for(i = 0; i < MAXDHCPSTATIC; i++)
		{
			char entry_str[DHCPSTATICSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(dhcp_staticlist[i][0]) {
				sprintf(entry_str, "<%s", dhcp_staticlist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("dhcp_staticlist", tmpstr);
             //}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_assignedIPDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char dhcp_staticlist[MAXDHCPSTATIC][DHCPSTATICSTRNUM];
    int i, dhcp_staticlist_count = 0;
    char *nv, *nvp, *b;
    
    value = *(long *) var_val;
    index = name[name_len-1] - 1;
    for(i = 0; i < MAXDHCPSTATIC; i++)
    	memset(dhcp_staticlist[i], 0x0, DHCPSTATICSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("dhcp_staticlist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(dhcp_staticlist[dhcp_staticlist_count], b);
		dhcp_staticlist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to assignedIPDelEntry not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to assignedIPDelEntry: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to assignedIPDelEntry: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < dhcp_staticlist_count)
             {
        	memset(dhcp_staticlist[index], 0x0, DHCPSTATICSTRNUM);

		//Re-generate dhcp_staticlist
		for(i = 0; i < MAXDHCPSTATIC; i++)
		{
			char entry_str[DHCPSTATICSTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(dhcp_staticlist[i][0]) {
				sprintf(entry_str, "<%s", dhcp_staticlist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("dhcp_staticlist", tmpstr);
             }   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_staticRouteIPAddr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char sr_rulelist[MAXSTATICROUTE][STATICROUTESTRNUM];
    int i, sr_rulelist_count = 0;
    char *nv, *nvp, *b, *ip, *netmask, *gateway, *metric, *interface;
    char ipStr[20];
    char string[STATICROUTESTRNUM];

    for(i = 0; i < MAXSTATICROUTE; i++)
    	memset(sr_rulelist[i], 0x0, STATICROUTESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("sr_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(sr_rulelist[sr_rulelist_count], b);
		sr_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to lan not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          /*if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }*/
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	memset(ipStr, 0, sizeof(ipStr));
             	strncpy(ipStr, (u_char *)var_val, var_val_len); 

		memset(string, 0x0, sizeof(string));
		if((index+1) > sr_rulelist_count)
			real_index = sr_rulelist_count;
		else
			real_index = index;

		if(sr_rulelist[real_index][0]) {
			if((vstrsep(sr_rulelist[real_index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", ipStr, netmask, gateway, metric, interface);
		}
		else
			sprintf(string, "%s>>>>", ipStr);	
		strcpy(sr_rulelist[real_index], string);
             	
		//Re-generate sr_rulelist
		for(i = 0; i < MAXSTATICROUTE; i++)
		{
			char entry_str[STATICROUTESTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(sr_rulelist[i][0]) {
				sprintf(entry_str, "<%s", sr_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("sr_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_staticRouteNetmask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;
    static long index, real_index;
    char sr_rulelist[MAXSTATICROUTE][STATICROUTESTRNUM];
    int i, sr_rulelist_count = 0;
    char *nv, *nvp, *b, *ip, *netmask, *gateway, *metric, *interface;
    char netmaskStr[20];
    char string[STATICROUTESTRNUM];

    for(i = 0; i < MAXSTATICROUTE; i++)
    	memset(sr_rulelist[i], 0x0, STATICROUTESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("sr_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(sr_rulelist[sr_rulelist_count], b);
		sr_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	memset(netmaskStr, 0, sizeof(netmaskStr));
             	tmpval_u = *(u_long *)var_val;
             	addr.s_addr = tmpval_u;
             	strcpy(netmaskStr, (char *)inet_ntoa(addr));

		memset(string, 0x0, sizeof(string));
		if((index+1) > sr_rulelist_count)
			real_index = sr_rulelist_count;
		else
			real_index = index;

		if(sr_rulelist[real_index][0]) {
			if((vstrsep(sr_rulelist[real_index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", ip, netmaskStr, gateway, metric, interface);
		}
		else
			sprintf(string, ">%s>>>", netmaskStr);	
		strcpy(sr_rulelist[real_index], string);
             	
		//Re-generate sr_rulelist
		for(i = 0; i < MAXSTATICROUTE; i++)
		{
			char entry_str[STATICROUTESTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(sr_rulelist[i][0]) {
				sprintf(entry_str, "<%s", sr_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("sr_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_staticRouteGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;
    static long index, real_index;
    char sr_rulelist[MAXSTATICROUTE][STATICROUTESTRNUM];
    int i, sr_rulelist_count = 0;
    char *nv, *nvp, *b, *ip, *netmask, *gateway, *metric, *interface;
    char gatewayStr[20];
    char string[STATICROUTESTRNUM];

    for(i = 0; i < MAXSTATICROUTE; i++)
    	memset(sr_rulelist[i], 0x0, STATICROUTESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("sr_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(sr_rulelist[sr_rulelist_count], b);
		sr_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to lan not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	memset(gatewayStr, 0, sizeof(gatewayStr));
             	tmpval_u = *(u_long *)var_val;
             	addr.s_addr = tmpval_u;
             	strcpy(gatewayStr, (char *)inet_ntoa(addr));

		memset(string, 0x0, sizeof(string));
		if((index+1) > sr_rulelist_count)
			real_index = sr_rulelist_count;
		else
			real_index = index;

		if(sr_rulelist[real_index][0]) {
			if((vstrsep(sr_rulelist[real_index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", ip, netmask, gatewayStr, metric, interface);
		}
		else
			sprintf(string, ">>%s>>", gatewayStr);	
		strcpy(sr_rulelist[real_index], string);
             	
		//Re-generate sr_rulelist
		for(i = 0; i < MAXSTATICROUTE; i++)
		{
			char entry_str[STATICROUTESTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(sr_rulelist[i][0]) {
				sprintf(entry_str, "<%s", sr_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("sr_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_staticRouteMetric(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char sr_rulelist[MAXSTATICROUTE][STATICROUTESTRNUM];
    int i, sr_rulelist_count = 0;
    char *nv, *nvp, *b, *ip, *netmask, *gateway, *metric, *interface;
    int metricInt = 0;
    char string[STATICROUTESTRNUM];

    for(i = 0; i < MAXSTATICROUTE; i++)
    	memset(sr_rulelist[i], 0x0, STATICROUTESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("sr_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(sr_rulelist[sr_rulelist_count], b);
		sr_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	metricInt = *(u_long *)var_val;
             	
		memset(string, 0x0, sizeof(string));
		if((index+1) > sr_rulelist_count)
			real_index = sr_rulelist_count;
		else
			real_index = index;

		if(sr_rulelist[real_index][0]) {
			if((vstrsep(sr_rulelist[real_index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5)) break;
			sprintf(string, "%s>%s>%s>%d>%s", ip, netmask, gateway, metricInt, interface);
		}
		else
			sprintf(string, ">>>%d>", metricInt);	
		strcpy(sr_rulelist[real_index], string);
             	
		//Re-generate sr_rulelist
		for(i = 0; i < MAXSTATICROUTE; i++)
		{
			char entry_str[STATICROUTESTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(sr_rulelist[i][0]) {
				sprintf(entry_str, "<%s", sr_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("sr_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_staticRouteInterface(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, real_index;
    char sr_rulelist[MAXSTATICROUTE][STATICROUTESTRNUM];
    int i, sr_rulelist_count = 0;
    char *nv, *nvp, *b, *ip, *netmask, *gateway, *metric, *interface;
    int interfaceInt;
    char interfaceStr[8];
    char string[STATICROUTESTRNUM];

    for(i = 0; i < MAXSTATICROUTE; i++)
    	memset(sr_rulelist[i], 0x0, STATICROUTESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("sr_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(sr_rulelist[sr_rulelist_count], b);
		sr_rulelist_count++;		
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	interfaceInt = * (long *) var_val;
		if(interfaceInt == 1)
			sprintf(interfaceStr, "LAN");
		else if(interfaceInt == 2)
			sprintf(interfaceStr, "MAN");
		else if(interfaceInt == 3)
			sprintf(interfaceStr, "WAN");

		memset(string, 0x0, sizeof(string));
		if((index+1) > sr_rulelist_count)
			real_index = sr_rulelist_count;
		else
			real_index = index;

		if(sr_rulelist[real_index][0]) {
			if((vstrsep(sr_rulelist[real_index], ">", &ip, &netmask, &gateway, &metric, &interface) != 5)) break;
			sprintf(string, "%s>%s>%s>%s>%s", ip, netmask, gateway, metric, interfaceStr);
		}
		else
			sprintf(string, ">>>>%s", interfaceStr);	
		strcpy(sr_rulelist[real_index], string);
             	
		//Re-generate sr_rulelist
		for(i = 0; i < MAXSTATICROUTE; i++)
		{
			char entry_str[STATICROUTESTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(sr_rulelist[i][0]) {
				sprintf(entry_str, "<%s", sr_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("sr_rulelist", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_staticRouteDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    static long index;
    char sr_rulelist[MAXSTATICROUTE][STATICROUTESTRNUM];
    int i, sr_rulelist_count = 0;
    char *nv, *nvp, *b;
    char string[STATICROUTESTRNUM];

    for(i = 0; i < MAXSTATICROUTE; i++)
    	memset(sr_rulelist[i], 0x0, STATICROUTESTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    value = *(long *) var_val;
    index = name[name_len-1] - 1;

    //Compute the number of dhcp static list
    nv = nvp = strdup(nmp_safe_get("sr_rulelist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(sr_rulelist[sr_rulelist_count], b);
		sr_rulelist_count++;		
	}
	free(nv);
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to lan not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to lan: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to lan: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < sr_rulelist_count)
             {
        	memset(sr_rulelist[index], 0x0, STATICROUTESTRNUM);

		//Re-generate sr_rulelist
		for(i = 0; i < MAXSTATICROUTE; i++)
		{
			char entry_str[STATICROUTESTRNUM];
			memset(entry_str, 0x0, sizeof(entry_str));
			if(sr_rulelist[i][0]) {
				sprintf(entry_str, "<%s", sr_rulelist[i]);
				strcat(tmpstr, entry_str);
			}
		}

		nmp_set("sr_rulelist", tmpstr);
             }   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
