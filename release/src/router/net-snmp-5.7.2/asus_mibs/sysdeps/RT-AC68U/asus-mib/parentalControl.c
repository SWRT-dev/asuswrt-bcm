/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "parentalControl.h"
#include <nmp.h>

#define MAX_CLIENT_LIST     255
#define MAX_PCONTROL_ENTRY  16
#define MAXPCSTRNUM         1280

static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;
int scanclient_count = 0;
client_list_info_t scanclient_list[MAX_CLIENT_LIST];

int pc_list_flag = 0, pc_list_count = 0; 
pc_list_info_t pc_list_info[MAX_PCONTROL_ENTRY];


/* 
 * parentalControl_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid parentalControl_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,11 };

/* 
 * variable7 parentalControl_variables:
 *   this variable defines function callbacks and type return information 
 *   for the parentalControl mib section 
 */

struct variable7 parentalControl_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define PCONTROLENABLE		1
{PCONTROLENABLE,  ASN_INTEGER,  RWRITE,  var_parentalControl, 1,  { 1 }},
#define PCONTROLSCANCLIENTS		2
{PCONTROLSCANCLIENTS,  ASN_INTEGER,  RWRITE,  var_parentalControl, 1,  { 2 }},

#define PCONTROLSCANINDEX		3
{PCONTROLSCANINDEX,  ASN_INTEGER,  RONLY,   var_pControlScanTable, 3,  { 3, 1, 1 }},
#define PCONTROLSCANIPADDR		4
{PCONTROLSCANIPADDR,  ASN_IPADDRESS,  RONLY,   var_pControlScanTable, 3,  { 3, 1, 2 }},
#define PCONTROLSCANCLIENTNAME		5
{PCONTROLSCANCLIENTNAME,  ASN_OCTET_STR,  RONLY,   var_pControlScanTable, 3,  { 3, 1, 3 }},
#define PCONTROLSCANCLIENTMAC		6
{PCONTROLSCANCLIENTMAC,  ASN_OCTET_STR,  RONLY,  var_pControlScanTable, 3,  { 3, 1, 4 }},
#define PCONTROLCLIENTINDEX		7
{PCONTROLCLIENTINDEX,  ASN_INTEGER,  RONLY,   var_pControlClientTable, 3,  { 4, 1, 1 }},
#define PCONTROLENTRYENABLE		8
{PCONTROLENTRYENABLE,  ASN_INTEGER,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 2 }},
#define PCONTROLCLIENTNAME		9
{PCONTROLCLIENTNAME,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 3 }},
#define PCONTROLCLIENTMAC		10
{PCONTROLCLIENTMAC,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 4 }},
#define PCONTROLSUNALLOWTIME		11
{PCONTROLSUNALLOWTIME,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 5 }},
#define PCONTROLMONALLOWTIME		12
{PCONTROLMONALLOWTIME,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 6 }},
#define PCONTROLTUEALLOWTIME		13
{PCONTROLTUEALLOWTIME,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 7 }},
#define PCONTROLWEDALLOWTIME		14
{PCONTROLWEDALLOWTIME,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 8 }},
#define PCONTROLTHUALLOWTIME		15
{PCONTROLTHUALLOWTIME,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 9 }},
#define PCONTROLFRIALLOWTIME		16
{PCONTROLFRIALLOWTIME,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 10 }},
#define PCONTROLSATALLOWTIME		17
{PCONTROLSATALLOWTIME,  ASN_OCTET_STR,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 11 }},
#define PCONTROLCLIENTDELENTRY		18
{PCONTROLCLIENTDELENTRY,  ASN_INTEGER,  RWRITE,  var_pControlClientTable, 3,  { 4, 1, 12 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the parentalControl module */
void
init_parentalControl(void)
{

    DEBUGMSGTL(("parentalControl", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("parentalControl", parentalControl_variables, variable7,
               parentalControl_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");    
}

/*
 * var_parentalControl():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_parentalControl(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER)  //Doesn't support in AP and repeater mode
    return NULL;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PCONTROLENABLE:
        *write_method = write_pControlEnable;
        if(nmp_safe_get("MULTIFILTER_ALL")!=NULL)
        {
            tmpval = nmp_get_int("MULTIFILTER_ALL");
            if(tmpval == 0) /* off */
                tmpval = 2;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;            
        }
        return NULL;
    case PCONTROLSCANCLIENTS:
        *write_method = write_pControlScanClients;
        tmpval = 2; /* nothing */
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_pControlScanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_parentalControl above.
 */
unsigned char *
var_pControlScanTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_CLIENT_LIST)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PCONTROLSCANINDEX:
        return NULL;
    case PCONTROLSCANIPADDR:
        index = name[*length-1]-1;
        if(index < scanclient_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr, "%d.%d.%d.%d", scanclient_list[index].ip_addr[0],
                        scanclient_list[index].ip_addr[1],
                        scanclient_list[index].ip_addr[2],
                        scanclient_list[index].ip_addr[3]);

            tmpval_u = inet_addr(tmpstr);
            *var_len = sizeof( unsigned long );
            return ( u_char * ) &tmpval_u;          
        }   
        return NULL;        
    case PCONTROLSCANCLIENTNAME:
        index = name[*length-1]-1;
        if(index < scanclient_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr, "%s", scanclient_list[index].device_name);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }   
        return NULL;
    case PCONTROLSCANCLIENTMAC:
        index = name[*length-1]-1;
        if(index < scanclient_count)
        {    
            char macstr[18];

            memset(macstr, 0x0, 18);
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(macstr, "%02X:%02X:%02X:%02X:%02X:%02X", scanclient_list[index].mac_addr[0],
                                scanclient_list[index].mac_addr[1],
                                scanclient_list[index].mac_addr[2],
                                scanclient_list[index].mac_addr[3],
                                scanclient_list[index].mac_addr[4],
                                scanclient_list[index].mac_addr[5]);
            ether_atoe(macstr, tmpstr);
            *var_len = 6;
            return ( u_char * )tmpstr;
        }
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_pControlClientTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_parentalControl above.
 */
unsigned char *
var_pControlClientTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    static unsigned char string[SPRINT_MAX_LEN];
    int i, val_count = 0;
    char *nv, *nvp, *b; 

    if(sw_mode == SW_MODE_AP || sw_mode == SW_MODE_REPEATER || !strcmp(nmp_get("ipv6_service"), "disabled"))    //Doesn't support in AP and repeater mode
       return NULL;     

    if(!pc_list_flag) {
        for(i = 0; i < MAX_PCONTROL_ENTRY; i++)
            memset(&pc_list_info[i], 0x0, sizeof(pc_list_info_t));        
        pc_list_count = get_pc_list_info(&pc_list_info);
        pc_list_flag = 1;
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAX_PCONTROL_ENTRY)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case PCONTROLCLIENTINDEX:
        return NULL;
    case PCONTROLENTRYENABLE:
        *write_method = write_pControlEntryEnable;
        index = name[*length-1]-1;  
        tmpval = 1;        
        if(index < pc_list_count) 
            tmpval = pc_list_info[index].enable;
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    case PCONTROLCLIENTNAME:
        *write_method = write_pControlClientName;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)  
            strcpy(tmpstr,pc_list_info[index].device_name);
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PCONTROLCLIENTMAC:
        *write_method = write_pControlClientMac;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)              
            ether_atoe(pc_list_info[index].mac, tmpstr);
        *var_len = 6;
        return ( u_char * )tmpstr;
    case PCONTROLSUNALLOWTIME:
        *write_method = write_pControlSunAllowTime;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)  
            strcpy(tmpstr,pc_list_info[index].sunday);
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PCONTROLMONALLOWTIME:
        *write_method = write_pControlMonAllowTime;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)  
            strcpy(tmpstr,pc_list_info[index].monday);
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PCONTROLTUEALLOWTIME:
        *write_method = write_pControlTueAllowTime;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)  
            strcpy(tmpstr,pc_list_info[index].tuesday);
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PCONTROLWEDALLOWTIME:
        *write_method = write_pControlWedAllowTime;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)  
            strcpy(tmpstr,pc_list_info[index].wednesday);
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PCONTROLTHUALLOWTIME:
        *write_method = write_pControlThuAllowTime;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)  
            strcpy(tmpstr,pc_list_info[index].thursday);
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PCONTROLFRIALLOWTIME:
        *write_method = write_pControlFriAllowTime;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)  
            strcpy(tmpstr,pc_list_info[index].friday);
        *var_len = strlen(tmpstr);
        return ( u_char * )tmpstr;
    case PCONTROLSATALLOWTIME:
        *write_method = write_pControlSatAllowTime;
        index = name[*length-1]-1;
        memset(tmpstr, 0x0, SPRINT_MAX_LEN);   
        if(index < pc_list_count)  
            strcpy(tmpstr,pc_list_info[index].saturday);
        *var_len = strlen(tmpstr);
        pc_list_flag = 0;        
        return ( u_char * )tmpstr;
    case PCONTROLCLIENTDELENTRY:
        *write_method = write_pControlClientDelEntry;
        tmpval = 2;
        *var_len = sizeof( long );
        return ( u_char * ) &tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_pControlEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to parentalControl not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to parentalControl: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to parentalControl: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }               
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 2) /* off */
                value = 0;
            nmp_set_int("MULTIFILTER_ALL", value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_pControlScanClients(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to parentalControl not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to parentalControl: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to parentalControl: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)
                scanclient_count = get_client_detail_info(&scanclient_list);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_pControlEntryEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    long index;    

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to parentalControl not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to parentalControl: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to parentalControl: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;
            set_pc_client_enable(index, value);           
            pc_list_flag = 0;                        
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_pControlClientName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long index;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */              
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            index = name[name_len-1] -1;
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            set_pc_client_name(index, tmpstr);           
            pc_list_flag = 0;               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlClientMac(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long index; 
    char macaddr[18];       

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            index = name[name_len-1] -1;
            ether_etoa(var_val, macaddr);
            set_pc_client_mac(index, macaddr);           
            pc_list_flag = 0;              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlSunAllowTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{    
    long index;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;              
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);       
            set_pc_client_dayTime(index, 0, tmpstr);              
            pc_list_flag = 0;               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlMonAllowTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long index;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;              
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);       
            set_pc_client_dayTime(index, 1, tmpstr);              
            pc_list_flag = 0;                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlTueAllowTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long index;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;              
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);       
            set_pc_client_dayTime(index, 2, tmpstr);              
            pc_list_flag = 0;               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlWedAllowTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long index;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;              
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);       
            set_pc_client_dayTime(index, 3, tmpstr);              
            pc_list_flag = 0;                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlThuAllowTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long index;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;              
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);       
            set_pc_client_dayTime(index, 4, tmpstr);              
            pc_list_flag = 0;   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlFriAllowTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long index;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;              
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);       
            set_pc_client_dayTime(index, 5, tmpstr);              
            pc_list_flag = 0;               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlSatAllowTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long index;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to parentalControl not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;              
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);       
            set_pc_client_dayTime(index, 6, tmpstr);              
            pc_list_flag = 0;              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pControlClientDelEntry(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value, index;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to parentalControl not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to parentalControl: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to parentalControl: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            index = name[name_len-1] -1;           
            if( value == 1 )
            {    
                del_pc_client_entry(index);
                pc_list_flag = 0;
            }                           
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
