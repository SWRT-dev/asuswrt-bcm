# Simplified Chinese translation of coreutils.
# Copyright (C) 1998, 2002, 2004, 2005, 2009, 2010, 2011 Free Software Foundation, Inc.
# This file is distributed under the same license as the coreutils package.
# Yip Chi Lap <clyip@cs.hku.hk>, 1998.
# Abel Cheung <maddog@linux.org.hk>, 2002.
# Anthony Fok <anthony@thizlinux.com>, 2002.
# Funda Wang <fundawang@linux.net.cn>, 2004, 2005.
# Ji ZhengYu <zhengyuji@gmail.com>, 2009.
# Aron Xu <happyaron.xu@gmail.com>, 2009, 2010, 2011.
#
msgid ""
msgstr ""
"Project-Id-Version: coreutils 8.11-pre1\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2011-09-08 17:09+0200\n"
"PO-Revision-Date: 2011-03-28 00:26+0800\n"
"Last-Translator: Aron Xu <happyaron.xu@gmail.com>\n"
"Language-Team: Chinese (simplified) <i18n-zh@googlegroups.com>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: lib/argmatch.c:133
#, c-format
msgid "invalid argument %s for %s"
msgstr "%2$s 的参数%1$s 无效"

#: lib/argmatch.c:134
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "%2$s 的参数%1$s 不明确"

#: lib/argmatch.c:153
#, c-format
msgid "Valid arguments are:"
msgstr "有效的参数为："

#: lib/closein.c:100
msgid "error closing file"
msgstr "关闭文件时出错"

#: lib/closeout.c:112 src/base64.c:110 src/base64.c:122 src/base64.c:128
#: src/base64.c:169 src/base64.c:225 src/cat.c:187 src/cat.c:203 src/cat.c:287
#: src/cksum.c:251 src/expand.c:332 src/expand.c:357 src/head.c:299
#: src/head.c:349 src/head.c:757 src/head.c:798 src/mktemp.c:351 src/od.c:915
#: src/paste.c:160 src/shuf.c:370 src/split.c:654 src/split.c:891
#: src/split.c:896 src/tail.c:350 src/tail.c:1200 src/tail.c:1306
#: src/tail.c:2203 src/tr.c:1621 src/tr.c:1846 src/tr.c:1940
#: src/unexpand.c:429 src/unexpand.c:445
#, c-format
msgid "write error"
msgstr "写入错误"

#: lib/copy-acl.c:638 src/copy.c:1154 src/copy.c:2536
#, c-format
msgid "preserving permissions for %s"
msgstr "%s 的保留权限"

#: lib/error.c:185
msgid "Unknown system error"
msgstr "未知的系统错误"

#: lib/euidaccess-stat.c:128 src/copy.c:1575 src/copy.c:1627 src/copy.c:2206
#: src/copy.c:2523 src/find-mount-point.c:84 src/install.c:661 src/stat.c:1206
#: src/truncate.c:353
#, c-format
msgid "cannot stat %s"
msgstr "无法获取%s 的文件状态(stat)"

#: lib/file-type.c:38
msgid "regular empty file"
msgstr "普通空文件"

#: lib/file-type.c:38
msgid "regular file"
msgstr "普通文件"

#: lib/file-type.c:41
msgid "directory"
msgstr "目录"

#: lib/file-type.c:44
msgid "block special file"
msgstr "块特殊文件"

#: lib/file-type.c:47
msgid "character special file"
msgstr "字符特殊文件"

#: lib/file-type.c:50
msgid "fifo"
msgstr "先进先出"

#: lib/file-type.c:53
msgid "symbolic link"
msgstr "符号链接"

#: lib/file-type.c:56
msgid "socket"
msgstr "套接字"

#: lib/file-type.c:59
msgid "message queue"
msgstr "消息队列"

#: lib/file-type.c:62
msgid "semaphore"
msgstr "信号量"

#: lib/file-type.c:65
msgid "shared memory object"
msgstr "共享内存对象"

#: lib/file-type.c:68
msgid "typed memory object"
msgstr "共享内存对象"

#: lib/file-type.c:70
msgid "weird file"
msgstr "古怪文件"

#: lib/gai_strerror.c:60
msgid "Address family for hostname not supported"
msgstr "主机名的地址家族不被支持"

#: lib/gai_strerror.c:61
msgid "Temporary failure in name resolution"
msgstr "名称解析出现临时错误"

#: lib/gai_strerror.c:62
msgid "Bad value for ai_flags"
msgstr "错误的ai_flags 值"

#: lib/gai_strerror.c:63
msgid "Non-recoverable failure in name resolution"
msgstr "名称解析时出现不可恢复的错误"

#: lib/gai_strerror.c:64
msgid "ai_family not supported"
msgstr "不支持的ai_family"

#: lib/gai_strerror.c:65
msgid "Memory allocation failure"
msgstr "内存分配失败"

#: lib/gai_strerror.c:66
msgid "No address associated with hostname"
msgstr "没有与主机名关联的地址"

#: lib/gai_strerror.c:67
msgid "Name or service not known"
msgstr "名称或服务未知"

#: lib/gai_strerror.c:68
msgid "Servname not supported for ai_socktype"
msgstr "ai_socktype 不支持 Servname"

#: lib/gai_strerror.c:69
msgid "ai_socktype not supported"
msgstr "不支持ai_socktype"

#: lib/gai_strerror.c:70
msgid "System error"
msgstr "系统错误"

#: lib/gai_strerror.c:71
msgid "Argument buffer too small"
msgstr "参数缓冲区太小"

#: lib/gai_strerror.c:73
msgid "Processing request in progress"
msgstr "正在处理请求"

#: lib/gai_strerror.c:74
msgid "Request canceled"
msgstr "请求已取消"

#: lib/gai_strerror.c:75
msgid "Request not canceled"
msgstr "请求未取消"

#: lib/gai_strerror.c:76
msgid "All requests done"
msgstr "全部请求已完成"

#: lib/gai_strerror.c:77
msgid "Interrupted by a signal"
msgstr "被信号中断"

#: lib/gai_strerror.c:78
msgid "Parameter string not correctly encoded"
msgstr "参数字符串编码不正确"

#: lib/gai_strerror.c:90
msgid "Unknown error"
msgstr "未知错误"

#: lib/getopt.c:547 lib/getopt.c:576
#, fuzzy, c-format
msgid "%s: option '%s' is ambiguous; possibilities:"
msgstr "%s：选项\"%s\"歧义\n"

#: lib/getopt.c:624 lib/getopt.c:628
#, c-format
msgid "%s: option '--%s' doesn't allow an argument\n"
msgstr "%s：选项\"--%s\"不允许带参数\n"

#: lib/getopt.c:637 lib/getopt.c:642
#, c-format
msgid "%s: option '%c%s' doesn't allow an argument\n"
msgstr "%s：选项\"%c%s\"不允许带参数\n"

#: lib/getopt.c:685 lib/getopt.c:704
#, c-format
msgid "%s: option '--%s' requires an argument\n"
msgstr "%s：选项\"--%s\"必需带参数\n"

#: lib/getopt.c:742 lib/getopt.c:745
#, c-format
msgid "%s: unrecognized option '--%s'\n"
msgstr "%s：无法识别的选项\"--%s\"\n"

#: lib/getopt.c:753 lib/getopt.c:756
#, c-format
msgid "%s: unrecognized option '%c%s'\n"
msgstr "%s：无法识别的选项\"%c%s\"\n"

#: lib/getopt.c:805 lib/getopt.c:808
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s：无效选项 -- %c\n"

#: lib/getopt.c:861 lib/getopt.c:878 lib/getopt.c:1088 lib/getopt.c:1106
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s：选项必需带参数 -- \"%c\"\n"

#: lib/getopt.c:934 lib/getopt.c:950
#, c-format
msgid "%s: option '-W %s' is ambiguous\n"
msgstr "%s：选项\"-W %s\"歧义\n"

#: lib/getopt.c:974 lib/getopt.c:992
#, c-format
msgid "%s: option '-W %s' doesn't allow an argument\n"
msgstr "%s：选项\"-W %s\"不允许带参数\n"

#: lib/getopt.c:1013 lib/getopt.c:1031
#, c-format
msgid "%s: option '-W %s' requires an argument\n"
msgstr "%s：选项\"-W %s\"必需带参数\n"

#: lib/mkdir-p.c:196 src/install.c:465
#, c-format
msgid "cannot change permissions of %s"
msgstr "无法更改%s 的权限"

#: lib/mkdir-p.c:206 src/copy.c:2195 src/install.c:692 src/install.c:705
#, c-format
msgid "cannot create directory %s"
msgstr "无法创建目录%s"

#: lib/obstack.c:413 lib/obstack.c:415 lib/xalloc-die.c:34 src/csplit.c:220
#: src/split.c:842
msgid "memory exhausted"
msgstr "内存耗尽"

#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "无法记录目前的工作目录"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "返回到初始工作目录失败"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  If the catalog has no translation,
#. locale_quoting_style quotes `like this', and
#. clocale_quoting_style quotes "like this".
#.
#. For example, an American English Unicode locale should
#. translate "`" to U+201C (LEFT DOUBLE QUOTATION MARK), and
#. should translate "'" to U+201D (RIGHT DOUBLE QUOTATION
#. MARK).  A British English Unicode locale should instead
#. translate these to U+2018 (LEFT SINGLE QUOTATION MARK)
#. and U+2019 (RIGHT SINGLE QUOTATION MARK), respectively.
#.
#. If you don't know what to put here, please see
#. <http://en.wikipedia.org/wiki/Quotation_mark#Glyphs>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:271
msgid "`"
msgstr "\""

#: lib/quotearg.c:272
msgid "'"
msgstr "\""

#: lib/randread.c:125
#, c-format
msgid "%s: end of file"
msgstr "%s：文件结束"

#: lib/regcomp.c:133
msgid "Success"
msgstr "成功"

#: lib/regcomp.c:136
msgid "No match"
msgstr "无匹配"

#: lib/regcomp.c:139
msgid "Invalid regular expression"
msgstr "无效的正则表达式"

#: lib/regcomp.c:142
msgid "Invalid collation character"
msgstr "无效的校勘字符"

#: lib/regcomp.c:145
msgid "Invalid character class name"
msgstr "无效的字符类型名"

#: lib/regcomp.c:148
msgid "Trailing backslash"
msgstr "末尾的反斜杠"

#: lib/regcomp.c:151
msgid "Invalid back reference"
msgstr "无效的后向引用"

#: lib/regcomp.c:154
msgid "Unmatched [ or [^"
msgstr "未匹配的[ 或[^"

#: lib/regcomp.c:157
msgid "Unmatched ( or \\("
msgstr "未匹配的( 或\\("

#: lib/regcomp.c:160
msgid "Unmatched \\{"
msgstr "未匹配的\\{"

#: lib/regcomp.c:163
msgid "Invalid content of \\{\\}"
msgstr "\\{\\} 中内容无效"

#: lib/regcomp.c:166
msgid "Invalid range end"
msgstr "无效的范围结束符"

#: lib/regcomp.c:169
msgid "Memory exhausted"
msgstr "内存耗尽"

#: lib/regcomp.c:172
msgid "Invalid preceding regular expression"
msgstr "无效的前置正则表达式"

#: lib/regcomp.c:175
msgid "Premature end of regular expression"
msgstr "正则表达式异常结束"

#: lib/regcomp.c:178
msgid "Regular expression too big"
msgstr "正则表达式过长"

#: lib/regcomp.c:181
msgid "Unmatched ) or \\)"
msgstr "未匹配的 ) 或 \\)"

#: lib/regcomp.c:702
msgid "No previous regular expression"
msgstr "缺少之前的正则表达式"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "在%s 进行递归操作十分危险"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "在%s 进行递归操作十分危险(与%s 相同)"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr "使用 --no-preserve-root 选项跳过安全模式"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:147
msgid "^[yY]"
msgstr "^[yY]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:160
msgid "^[nN]"
msgstr "^[nN]"

#: lib/set-mode-acl.c:682 src/copy.c:2218 src/cp.c:519
#, c-format
msgid "setting permissions for %s"
msgstr "设置%s 的权限"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "挂起"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "中断"

#: lib/siglist.h:37
msgid "Quit"
msgstr "退出"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "非法操作"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr "跟踪/断点陷阱"

#: lib/siglist.h:46
msgid "Aborted"
msgstr "已中止"

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "浮点数异常"

#: lib/siglist.h:52
msgid "Killed"
msgstr "已杀死"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "总线错误"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "段错误"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "管道中断"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "时钟警告"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "已终止"

#: lib/siglist.h:70
msgid "Urgent I/O condition"
msgstr "急需I/O 条件"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "已停止(信号)"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "已停止"

#: lib/siglist.h:79
msgid "Continued"
msgstr "已继续"

#: lib/siglist.h:82
msgid "Child exited"
msgstr "子进程已退出"

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "已停止(tty 输入)"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "已停止(tty 输出)"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr "可能需要I/O"

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr "CPU 时间超时"

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr "文件大小超过限制"

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr "虚拟记时器过期"

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr "定时器描述已过期"

#: lib/siglist.h:106
msgid "Window changed"
msgstr "窗口已更改"

#: lib/siglist.h:109
msgid "User defined signal 1"
msgstr "用户自定义信号 1"

#: lib/siglist.h:112
msgid "User defined signal 2"
msgstr "用户自定义信号 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr "捕获EMT 信号"

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "错误的系统调用"

#: lib/siglist.h:123
msgid "Stack fault"
msgstr "栈错误"

#: lib/siglist.h:126
msgid "Information request"
msgstr "信息请求"

#: lib/siglist.h:128
msgid "Power failure"
msgstr "电源错误"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr "资源丢失"

#: lib/strsignal.c:110
#, c-format
msgid "Real-time signal %d"
msgstr "实时信号%d"

#: lib/strsignal.c:114
#, c-format
msgid "Unknown signal %d"
msgstr "未知信号%d"

#: lib/unicodeio.c:103
msgid "iconv function not usable"
msgstr "iconv 函数无法使用"

#: lib/unicodeio.c:105
msgid "iconv function not available"
msgstr "iconv 函数不存在"

#: lib/unicodeio.c:112
msgid "character out of range"
msgstr "字符值超出可接受的范围以外"

#: lib/unicodeio.c:182
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "无法将U+%04X 转换至用户的字符集"

#: lib/unicodeio.c:184
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "无法将U+%04X 转换至用户的字符集：%s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "无效的用户"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "无效的组"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "无效的 spec"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "无法显示错误信息"

#: lib/version-etc.c:74
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "由%s (%s)打包\n"

#: lib/version-etc.c:77
#, c-format
msgid "Packaged by %s\n"
msgstr "由%s 打包\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:84
msgid "(C)"
msgstr "(C)"

#: lib/version-etc.c:86
msgid ""
"\n"
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
"\n"
msgstr ""
"\n"
"许可证：GPLv3+：GNU 通用公共许可证第3 版或更新版本<http://gnu.org/licenses/"
"gpl.html>。\n"
"本软件是自由软件：您可以自由修改和重新发布它。\n"
"在法律范围内没有其他保证。\n"
"\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:102
#, c-format
msgid "Written by %s.\n"
msgstr "由%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:106
#, c-format
msgid "Written by %s and %s.\n"
msgstr "由%s 和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:110
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "由%s、%s 和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:117
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"由%s、%s、%s 和\n"
"%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:124
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:131
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:139
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:147
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s\n"
"和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:156
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s、\n"
"%s、和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:167
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s、\n"
"%s、%s、和其他人编写。\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:245
#, c-format
msgid ""
"\n"
"Report bugs to: %s\n"
msgstr ""
"\n"
"请向<%s> 报告软件错误。请向 <i18n-zh@googlegroups.com> 报告翻译错误。\n"

#: lib/version-etc.c:247
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "请向 %2$s 报告 %1$s 的错误\n"

#: lib/version-etc.c:251 src/system.h:524
#, c-format
msgid "%s home page: <%s>\n"
msgstr "%s 的主页：<%s>\n"

#: lib/version-etc.c:253
#, c-format
msgid "%s home page: <http://www.gnu.org/software/%s/>\n"
msgstr "%s 项目主页：<http://www.gnu.org/software/%s/>\n"

#: lib/version-etc.c:256 src/system.h:525
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "GNU 软件一般性帮助：<http://www.gnu.org/gethelp/>\n"

#: lib/xfreopen.c:35
msgid "stdin"
msgstr "标准输入"

#: lib/xfreopen.c:36
msgid "stdout"
msgstr "标准输出"

#: lib/xfreopen.c:37
msgid "stderr"
msgstr "标准错误"

#: lib/xfreopen.c:38
msgid "unknown stream"
msgstr "未知流"

#: lib/xfreopen.c:39
#, c-format
msgid "failed to reopen %s with mode %s"
msgstr "以%s 模式重新打开%s 失败"

#: lib/xmemcoll.c:39 src/expr.c:887
#, c-format
msgid "string comparison failed"
msgstr "字符串比较出现错误"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "请设置LC_ALL='C' 以避免出现问题。"

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "要比较的字符串为%s 和%s。"

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "不能执行格式化输出"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument `%s'"
msgstr "非法的%s%s 参数\"%s\""

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument `%s'"
msgstr "非法的后缀在%s%s 参数\"%s\""

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument `%s' too large"
msgstr "%s%s 参数\"%s\"太大"

#. This is a proper name. See the gettext manual, section Names.
#: src/base64.c:40
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#: src/base64.c:57 src/basename.c:46 src/cat.c:85 src/chcon.c:348
#: src/chgrp.c:105 src/chmod.c:368 src/chown.c:76 src/chroot.c:118
#: src/cksum.c:260 src/comm.c:101 src/cp.c:153 src/csplit.c:1447 src/cut.c:186
#: src/date.c:120 src/dd.c:478 src/df.c:810 src/dircolors.c:94
#: src/dirname.c:41 src/du.c:256 src/echo.c:39 src/env.c:49 src/expand.c:101
#: src/expr.c:200 src/factor.c:491 src/fmt.c:266 src/fold.c:63
#: src/getlimits.c:62 src/groups.c:50 src/head.c:102 src/hostid.c:39
#: src/hostname.c:53 src/id.c:78 src/install.c:572 src/join.c:184
#: src/kill.c:73 src/link.c:42 src/ln.c:332 src/logname.c:36 src/ls.c:4592
#: src/md5sum.c:156 src/mkdir.c:53 src/mkfifo.c:48 src/mknod.c:49
#: src/mktemp.c:65 src/mv.c:281 src/nice.c:69 src/nl.c:179 src/nohup.c:50
#: src/nproc.c:53 src/od.c:291 src/paste.c:432 src/pathchk.c:86
#: src/pinky.c:499 src/pr.c:2766 src/printenv.c:59 src/printf.c:85
#: src/ptx.c:1814 src/pwd.c:53 src/readlink.c:59 src/rm.c:131 src/rmdir.c:161
#: src/runcon.c:80 src/seq.c:65 src/setuidgid.c:46 src/shred.c:155
#: src/shuf.c:45 src/sleep.c:42 src/sort.c:389 src/split.c:178 src/stat.c:1318
#: src/stdbuf.c:87 src/stty.c:506 src/su.c:365 src/sum.c:56 src/sync.c:37
#: src/tac.c:129 src/tail.c:254 src/tee.c:59 src/test.c:683 src/timeout.c:199
#: src/touch.c:213 src/tr.c:283 src/truncate.c:93 src/tsort.c:79 src/tty.c:61
#: src/uname.c:118 src/unexpand.c:111 src/uniq.c:131 src/unlink.c:42
#: src/uptime.c:193 src/users.c:102 src/wc.c:109 src/who.c:646 src/whoami.c:42
#: src/yes.c:38
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "请尝试执行\"%s --help\"来获取更多信息。\n"

#: src/base64.c:61
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"Base64 encode or decode FILE, or standard input, to standard output.\n"
"\n"
msgstr ""
"用法：%s [选项]... [文件]\n"
"使用 Base64 编码/解码文件或标准输入输出。\n"
"\n"

#: src/base64.c:65
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
"\n"
msgstr ""
"  -d, --decode\t\t解码数据\n"
"  -i, --ignore-garbag\t解码时忽略非字母字符\n"
"  -w, --wrap=字符数\t在指定的字符数后自动换行(默认为76)，0 为禁用自动换行\n"
"\n"

#: src/base64.c:74 src/cat.c:111 src/fmt.c:293 src/shuf.c:72 src/sum.c:72
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"如果没有指定文件，或者文件为\"-\"，则从标准输入读取。\n"

#: src/base64.c:77
msgid ""
"\n"
"The data are encoded as described for the base64 alphabet in RFC 3548.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal base64 alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"数据以 RFC 3548 规定的 Base64 字母格式进行编码。 解码时，输入数据(加密流)可能"
"包含一些非有效 Base64 字符的新行字符。可以尝试用 --ignore-garbage 选项来恢复"
"加密流中任何非 base64 字符。\n"

#: src/base64.c:172 src/base64.c:209 src/csplit.c:264 src/csplit.c:1436
#: src/join.c:452 src/shuf.c:158 src/shuf.c:362 src/tac-pipe.c:75
#: src/tee.c:205 src/tr.c:1645
#, c-format
msgid "read error"
msgstr "读取错误"

#: src/base64.c:228
#, c-format
msgid "invalid input"
msgstr "输入无效"

#: src/base64.c:265
#, c-format
msgid "invalid wrap size: %s"
msgstr "无效的换行字符数：%s"

#: src/base64.c:284 src/basename.c:119 src/comm.c:437 src/cp.c:608
#: src/date.c:438 src/dircolors.c:448 src/dirname.c:97 src/du.c:881
#: src/hostid.c:75 src/hostname.c:112 src/id.c:169 src/install.c:912
#: src/join.c:962 src/link.c:86 src/ln.c:520 src/logname.c:72 src/mknod.c:158
#: src/mv.c:448 src/od.c:1799 src/ptx.c:2082 src/readlink.c:155 src/seq.c:409
#: src/shuf.c:321 src/shuf.c:340 src/sort.c:4465 src/split.c:1212
#: src/tr.c:1798 src/tsort.c:556 src/tty.c:113 src/uname.c:253 src/uniq.c:455
#: src/uniq.c:472 src/unlink.c:82 src/uptime.c:251 src/users.c:147
#: src/wc.c:667 src/who.c:837 src/whoami.c:80
#, c-format
msgid "extra operand %s"
msgstr "额外的操作数 %s"

#: src/base64.c:316 src/cat.c:782
#, c-format
msgid "closing standard input"
msgstr "关闭标准输入"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:40 src/chgrp.c:37 src/chmod.c:39 src/chown.c:36
#: src/comm.c:39 src/cp.c:57 src/csplit.c:42 src/cut.c:45 src/date.c:39
#: src/dd.c:44 src/df.c:42 src/dirname.c:34 src/du.c:53 src/env.c:33
#: src/expand.c:50 src/fold.c:36 src/groups.c:35 src/head.c:45 src/id.c:39
#: src/install.c:50 src/ln.c:40 src/ls.c:125 src/mkdir.c:36 src/mkfifo.c:33
#: src/mknod.c:34 src/mv.c:42 src/nice.c:39 src/nl.c:41 src/paste.c:53
#: src/pathchk.c:33 src/pinky.c:37 src/printenv.c:44 src/printf.c:63
#: src/rm.c:42 src/rmdir.c:38 src/stty.c:65 src/su.c:88 src/sum.c:39
#: src/tac.c:58 src/tail.c:69 src/tee.c:36 src/touch.c:45 src/tty.c:43
#: src/uname.c:61 src/unexpand.c:51 src/uniq.c:42 src/uptime.c:46
#: src/users.c:36 src/wc.c:51 src/who.c:49 src/yes.c:32
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:50
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 名称 [后缀]\n"
"　或：%s 选项\n"

#: src/basename.c:55
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
"\n"
msgstr ""
"去掉前导的目录部分后打印\"名称\"。\n"
"如果指定的话，还会去掉尾随的\"后缀\"。\n"
"\n"

#: src/basename.c:62
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort       Output \"sort\".\n"
"  %s include/stdio.h .h  Output \"stdio\".\n"
msgstr ""
"\n"
"示例：\n"
"  %s /usr/bin/sort       输出\"sort\"。\n"
"  %s include/stdio.h .h  输出\"stdio\"。\n"

#: src/basename.c:113 src/chcon.c:524 src/chgrp.c:272 src/chmod.c:519
#: src/chown.c:275 src/chroot.c:187 src/comm.c:429 src/csplit.c:1370
#: src/dirname.c:91 src/expr.c:327 src/join.c:1148 src/link.c:78
#: src/mkdir.c:184 src/mkfifo.c:109 src/mknod.c:147 src/nohup.c:112
#: src/pathchk.c:149 src/printf.c:675 src/readlink.c:147 src/rm.c:315
#: src/rmdir.c:224 src/seq.c:403 src/setuidgid.c:138 src/sleep.c:121
#: src/stat.c:1468 src/stdbuf.c:347 src/tr.c:1783 src/unlink.c:76
#, c-format
msgid "missing operand"
msgstr "缺少操作数"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:56 src/df.c:41 src/du.c:52 src/split.c:49
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:38 src/ls.c:124 src/rm.c:43 src/split.c:50
#: src/tee.c:35 src/uniq.c:41
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:89 src/df.c:814 src/expand.c:105 src/fold.c:67 src/head.c:106
#: src/ls.c:4596 src/nl.c:183 src/paste.c:436 src/pr.c:2770 src/sum.c:60
#: src/tac.c:133 src/tail.c:258 src/tee.c:63 src/unexpand.c:115
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "用法：%s [选项]... [文件]...\n"

#: src/cat.c:93
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"将[文件]或标准输入组合输出到标准输出。\n"
"\n"
"  -A, --show-all           等于-vET\n"
"  -b, --number-nonblank    对非空输出行编号\n"
"  -e                       等于-vE\n"
"  -E, --show-ends          在每行结束处显示\"$\"\n"
"  -n, --number             对输出的所有行编号\n"
"  -s, --squeeze-blank      不输出多行空行\n"

#: src/cat.c:103
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       与-vT 等价\n"
"  -T, --show-tabs          将跳格字符显示为^I\n"
"  -u                       (被忽略)\n"
"  -v, --show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外\n"

#: src/cat.c:115
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"示例：\n"
"  %s f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。\n"
"  %s        将标准输入的内容复制到标准输出。\n"

#: src/cat.c:327
#, c-format
msgid "cannot do ioctl on %s"
msgstr "无法在 %s 上执行 ioctrl"

#: src/cat.c:638 src/dd.c:2053 src/sort.c:381 src/tee.c:166 src/yes.c:87
#, c-format
msgid "standard output"
msgstr "标准输出"

#: src/cat.c:717
#, c-format
msgid "%s: input file is output file"
msgstr "%s：输入文件是输出文件"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:36 src/runcon.c:62
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/chgrp.c:38 src/chmod.c:40 src/chown.c:37 src/cp.c:58
#: src/cut.c:46 src/dirname.c:35 src/du.c:55 src/head.c:46 src/hostid.c:33
#: src/hostname.c:33 src/mktemp.c:36 src/mv.c:43 src/nohup.c:37 src/od.c:36
#: src/pathchk.c:34 src/pwd.c:31 src/rm.c:44 src/setuidgid.c:38 src/sleep.c:35
#: src/sync.c:31 src/tail.c:71 src/tr.c:37 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:100 src/runcon.c:204 src/runcon.c:235
#, c-format
msgid "failed to create security context: %s"
msgstr "创建安全环境失败：%s"

#: src/chcon.c:112
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "设置%s 安全环境组件到%s 失败"

#: src/chcon.c:156 src/chcon.c:533 src/copy.c:2156 src/runcon.c:218
#: src/stat.c:669
#, c-format
msgid "failed to get security context of %s"
msgstr "无法取得%s 的安全环境"

#: src/chcon.c:166
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "部分关联无法应用于文件%s"

#: src/chcon.c:193
#, c-format
msgid "failed to change context of %s to %s"
msgstr "改变%s 的环境到%s 失败"

#: src/chcon.c:255 src/chmod.c:216 src/chown-core.c:325 src/copy.c:598
#: src/du.c:443 src/ls.c:2855
#, c-format
msgid "cannot access %s"
msgstr "无法访问%s"

#: src/chcon.c:265 src/chmod.c:229 src/chown-core.c:338 src/du.c:423
#, c-format
msgid "cannot read directory %s"
msgstr "无法读取目录%s"

#: src/chcon.c:292
#, c-format
msgid "changing security context of %s\n"
msgstr "正在更改%s 的安全环境\n"

#: src/chcon.c:326 src/chmod.c:346 src/chown-core.c:539 src/remove.c:626
#, c-format
msgid "fts_read failed"
msgstr "fts_read 失败"

#: src/chcon.c:337 src/chmod.c:357 src/chown-core.c:551 src/du.c:605
#: src/remove.c:640
#, c-format
msgid "fts_close failed"
msgstr "fts_close 失败"

#: src/chcon.c:352
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法:  %s [选项]... 环境 文件...\n"
"　或:  %s [选项]... [-u 用户] [-r 角色] [-l 范围] [-t 类型] 文件...\n"
"　或:  %s [选项]... --reference=参考文件 文件...\n"

#: src/chcon.c:358
msgid ""
"Change the security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
"\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""
"将每个文件的安全环境变更至指定环境。\n"
"使用 --reference 选项时，把指定文件的安全环境设置为与参考文件相同。\n"
"\n"
"  -h, --no-dereference\t\t影响符号连接而非引用的文件。\n"

#: src/chcon.c:364
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
"  -R, --recursive        operate on files and directories recursively\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"      --reference=参考文件\t使用指定参考文件的安全环境，而非指定值\n"
"  -R, --recursive        \t递归处理所有的文件及子目录\n"
"  -v, --verbose          \t为处理的所有文件显示诊断信息\n"

#: src/chcon.c:370
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
"\n"
msgstr ""
"  -u, --user=用户 \t\t设置指定用户的目标安全环境\n"
"  -r, --role=角色 \t\t设置指定角色的目标安全环境\n"
"  -t, --type=类型 \t\t设置指定类型的目标安全环境\n"
"  -l, --range=范围 \t\t设置指定范围的目标安全环境\n"
"\n"

#: src/chcon.c:377 src/chgrp.c:139 src/chown.c:117
msgid ""
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"以下选项是在指定了 -R 选项时被用于设置如何穿越目录结构体系。\n"
"如果您指定了多于一个选项，那么只有最后一个会生效。\n"
"\n"
"  -H         如果命令行参数是一个通到目录的符号链接，则遍历符号链接\n"
"  -L         遍历每一个遇到的通到目录的符号链接\n"
"  -P         不遍历任何符号链接(默认)\n"
"\n"

#: src/chcon.c:505 src/chgrp.c:259 src/chown.c:262
#, c-format
msgid "-R --dereference requires either -H or -L"
msgstr "-R --dereference 需要-H 或-L 其中之一"

#: src/chcon.c:511
#, c-format
msgid "-R -h requires -P"
msgstr "-R -h 需要-P"

#: src/chcon.c:526 src/chgrp.c:274 src/chmod.c:521 src/chown.c:277
#: src/comm.c:431 src/csplit.c:1372 src/join.c:1150 src/link.c:80
#: src/mknod.c:149 src/setuidgid.c:140 src/tr.c:1786
#, c-format
msgid "missing operand after %s"
msgstr "%s 后缺少操作数"

#: src/chcon.c:549 src/runcon.c:248
#, c-format
msgid "invalid context: %s"
msgstr "无效模式：%s"

#: src/chcon.c:556
#, c-format
msgid "conflicting security context specifiers given"
msgstr "给出的安全环境说明冲突"

#: src/chcon.c:565 src/chgrp.c:282 src/chgrp.c:300 src/chmod.c:529
#: src/chmod.c:548 src/chown.c:285 src/chown.c:314 src/cp.c:434 src/cp.c:494
#: src/mv.c:96 src/pwd.c:274 src/rm.c:325 src/touch.c:353
#, c-format
msgid "failed to get attributes of %s"
msgstr "无法取得%s 的属性"

#: src/chgrp.c:92
#, c-format
msgid "invalid group: %s"
msgstr "无效的组：%s"

#: src/chgrp.c:109
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... 用户组 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chgrp.c:114
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
"  -c, --changes          like verbose but report only when a change is made\n"
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
msgstr ""
"将每个指定文件的所属组设置为指定值。\n"
"如果使用 --reference，则将每个文件的所属组设置为与指定参考文件相同。\n"
"\n"
"  -c, --changes\t\t\t类似 --verbose，但只在有更改时才显示结果\n"
"      --dereference\t\t影响符号链接所指示的对象，而非符号链接本身(默认值)\n"

#: src/chgrp.c:122 src/chown.c:93
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"  -h, --no-dereference\t\t会影响符号链接本身，而非符号链接所指示的目的地\n"
"\t\t\t\t(当系统支持更改符号链接的所有者时，此选项才有用)\n"

#: src/chgrp.c:127 src/chown.c:105
msgid ""
"      --no-preserve-root  do not treat `/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on `/'\n"
msgstr ""
"      --no-preserve-root\t不特殊对待\"/\"(默认值)\n"
"      --preserve-root\t\t不允许在\"/\"上递归操作\n"

#: src/chgrp.c:131
msgid ""
"  -f, --silent, --quiet  suppress most error messages\n"
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
"  -R, --recursive        operate on files and directories recursively\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
"\n"
msgstr ""
"  -f, --silent, --quiet\t\t去除大部份错误信息\n"
"      --reference=RFILE\t\t使用参考文件的所属组，而非指定值\n"
"  -R, --recursive\t\t递归处理所有的文件及子目录\n"
"  -v, --verbose\t\t\t为处理的所有文件显示诊断信息\n"
"\n"

#: src/chgrp.c:153
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"示例：\n"
"  %s staff /u            将 /u 的属组更改为\"staff\"。\n"
"  %s -hR staff /u    将 /u 及其子目录下所有文件的属组更改为\"staff\"。\n"

#: src/chmod.c:126
#, c-format
msgid "getting new attributes of %s"
msgstr "检查 %s 的新属性"

#: src/chmod.c:149 src/chown-core.c:147
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr "符号链接%s 和该链接所指示的对象都未被更改\n"

#: src/chmod.c:163
#, fuzzy, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr "%s 的权限模式已更改为%04lo (%s)\n"

#: src/chmod.c:166
#, fuzzy, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr "无法将%s 的权限模式更改为%04lo (%s)\n"

#: src/chmod.c:169
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "%s 的权限模式保留为%04lo (%s)\n"

#: src/chmod.c:236
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "无法创建符号链接%s"

#: src/chmod.c:276
#, c-format
msgid "changing permissions of %s"
msgstr "更改%s 的权限"

#: src/chmod.c:311
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s：新的权限为%s，而非%s"

#: src/chmod.c:372
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... 模式[,模式]... 文件...\n"
"　或：%s [选项]... 八进制模式 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chmod.c:378
msgid ""
"Change the mode of each FILE to MODE.\n"
"\n"
"  -c, --changes           like verbose but report only when a change is "
"made\n"
msgstr ""
"将每个文件的模式更改为指定值。\n"
"\n"
"  -c, --changes\t\t类似 --verbose，但只在有更改时才显示结果\n"

#: src/chmod.c:383
msgid ""
"      --no-preserve-root  do not treat `/' specially (the default)\n"
"      --preserve-root     fail to operate recursively on `/'\n"
msgstr ""
"      --no-preserve-root\t不特殊对待根目录(默认)\n"
"      --preserve-root\t\t禁止对根目录进行递归操作\n"

#: src/chmod.c:387
msgid ""
"  -f, --silent, --quiet   suppress most error messages\n"
"  -v, --verbose           output a diagnostic for every file processed\n"
"      --reference=RFILE   use RFILE's mode instead of MODE values\n"
"  -R, --recursive         change files and directories recursively\n"
msgstr ""
"  -f, --silent, --quiet\t去除大部份的错误信息\n"
"  -v, --verbose\t\t为处理的所有文件显示诊断信息\n"
"      --reference=参考文件\t使用指定参考文件的模式，而非自行指定权限模式\n"
"  -R, --recursive\t\t以递归方式更改所有的文件及子目录\n"

#: src/chmod.c:395
msgid ""
"\n"
"Each MODE is of the form `[ugoa]*([-+=]([rwxXst]*|[ugo]))+'.\n"
msgstr ""
"\n"
"每种 MODE 都应属于这类形式\"[ugoa]*([-+=]([rwxXst]*|[ugo]))+\"。\n"

#: src/chmod.c:506
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "无法组合使用 mode 和 --reference 选项"

#: src/chmod.c:537
#, c-format
msgid "invalid mode: %s"
msgstr "无效模式：%s"

#: src/chown-core.c:158
#, fuzzy, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "%s 的所有者已更改为%s\n"

#: src/chown-core.c:159
#, fuzzy, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "%s 的所属组已更改为%s\n"

#: src/chown-core.c:160
#, c-format
msgid "no change to ownership of %s\n"
msgstr "%s 的归属关系未更改\n"

#: src/chown-core.c:165
#, fuzzy, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "无法更改%s 的所有者为%s\n"

#: src/chown-core.c:166
#, fuzzy, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "无法更改%s 的所属组为%s\n"

#: src/chown-core.c:167 src/chown-core.c:173
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "更改%s 的所有者失败\n"

#: src/chown-core.c:171
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "无法更改%s 的所有者为%s\n"

#: src/chown-core.c:172
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "无法更改%s 的所属组为%s\n"

#: src/chown-core.c:180
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "%s 的所有者已保留为%s\n"

#: src/chown-core.c:181
#, c-format
msgid "group of %s retained as %s\n"
msgstr "%s 的所属组已保留为%s\n"

#: src/chown-core.c:182
#, c-format
msgid "ownership of %s retained\n"
msgstr "%s 的所有权已保留\n"

#: src/chown-core.c:379
#, c-format
msgid "cannot dereference %s"
msgstr "无法取消%s 的引用"

#: src/chown-core.c:467
#, c-format
msgid "changing ownership of %s"
msgstr "正在更改%s 的所有者"

#: src/chown-core.c:468
#, c-format
msgid "changing group of %s"
msgstr "正在更改%s 的所属组"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... [所有者][:[组]] 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
"  -c, --changes          like verbose but report only when a change is made\n"
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
msgstr ""
"更改每个文件的所有者和/或所属组。\n"
"当使用 --referebce 参数时，将文件的所有者和所属组更改为与指定参考文件相同。\n"
"\n"
"  -c, --changes\t\t\t类似 verbose，但只在有更改时才显示结果\n"
"      --dereference\t\t受影响的是符号链接所指示的对象，而非符号链接本身\n"

#: src/chown.c:98
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=当前所有者:当前所属组\n"
"                         \t只当每个文件的所有者和组符合选项所指定时才更改所\n"
"\t\t\t\t有者和组。其中一个可以省略，这时已省略的属性就不\n"
"\t\t\t\t需要符合原有的属性。\n"

#: src/chown.c:109
msgid ""
"  -f, --silent, --quiet  suppress most error messages\n"
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
"  -R, --recursive        operate on files and directories recursively\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
"\n"
msgstr ""
"  -f, --silent, --quiet\t去除大部份的错误信息\n"
"      --reference=参考文件\t使用参考文件的所属组，而非指定值\n"
"  -R, --recursive\t\t递归处理所有的文件及子目录\n"
"  -v, --verbose\t\t\t为处理的所有文件显示诊断信息\n"
"\n"

#: src/chown.c:131
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a `:' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"如果没有指定所有者，则不会更改。 所属组若没有指定也不会更改，但当加上\n"
"\":\"时 GROUP 会更改为指定所有者的主要组。所有者和所属组可以是数字或名称。\n"

#: src/chown.c:137
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"示例：\n"
"  %s root /u\t\t将 /u 的属主更改为\"root\"。\n"
"  %s root:staff /u\t和上面类似，但同时也将其属组更改为\"staff\"。\n"
"  %s -hR root /u\t将 /u 及其子目录下所有文件的属主更改为\"root\"。\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:34
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:86 src/install.c:557 src/setuidgid.c:111 src/setuidgid.c:121
#, c-format
msgid "invalid group %s"
msgstr "无效的组%s"

#: src/chroot.c:98
#, c-format
msgid "invalid group list %s"
msgstr "无效的组列表%s"

#: src/chroot.c:106
#, c-format
msgid "failed to set additional groups"
msgstr "设置附加组失败"

#: src/chroot.c:122
#, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [选项] 新根 [命令 [参数]...]\n"
"　或：%s 选项\n"

#: src/chroot.c:127
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"以指定的新根为运行指定命令时的的根目录。\n"
"\n"

#: src/chroot.c:132
msgid ""
"  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
"  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""
"  --userspec=用户:组      指定所用的用户及用户组(可使用\"数字\"或\"名字\")\n"
"  --groups=组列表         指定可供选择的用户组列表，形如组1，组2，组3...\n"

#: src/chroot.c:139
msgid ""
"\n"
"If no command is given, run ``${SHELL} -i'' (default: /bin/sh).\n"
msgstr ""
"\n"
"如果没有指定命令，则运行\"${SHELL} -i\" (默认：/bin/sh)。\n"

#: src/chroot.c:192
#, c-format
msgid "cannot change root directory to %s"
msgstr "无法进入目录%s"

#: src/chroot.c:196
#, c-format
msgid "cannot chdir to root directory"
msgstr "无法切换到根目录"

#: src/chroot.c:237
#, c-format
msgid "failed to set group-ID"
msgstr "设置组ID 失败"

#: src/chroot.c:243
#, c-format
msgid "failed to set user-ID"
msgstr "设置用户ID 失败"

#: src/chroot.c:265 src/nohup.c:237 src/setuidgid.c:214 src/stdbuf.c:367
#: src/timeout.c:400
#, c-format
msgid "failed to run command %s"
msgstr "无法运行命令%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:216
#, c-format
msgid "%s: file too long"
msgstr "%s：文件太大"

#: src/cksum.c:264
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"用法：%s [文件]...\n"
"　或：%s [选项]\n"

#: src/cksum.c:269
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"输出每个文件的 CRC 校验值和字节统计。\n"
"\n"

#: src/comm.c:105 src/join.c:188
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "用法：%s [选项]... 文件1 文件2\n"

#: src/comm.c:109
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "逐行比较已排序的文件文件1 和文件2。\n"

#: src/comm.c:112
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"如果不附带选项，程序会生成三列输出。第一列包含文件1 特有的行，第二列包含 文件"
"2 特有的行，而第三列包含两个文件共有的行。\n"

#: src/comm.c:118
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1\t\t不输出文件1 特有的行\n"
"  -2\t\t不输出文件2 特有的行\n"
"  -3\t\t不输出两个文件共有的行\n"

#: src/comm.c:124
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"  --check-order\t\t\t检查输入是否被正确排序，即使所有输入行均成对\n"
"  --nocheck-order\t\t不检查输入是否被正确排序\n"

#: src/comm.c:130
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr "  --output-delimiter=STR\t依照STR 分列\n"

#: src/comm.c:135
msgid ""
"\n"
"Note, comparisons honor the rules specified by `LC_COLLATE'.\n"
msgstr ""
"\n"
"注意，比较操作遵从\"LC_CPLLATE\"所定义的规则。\n"

#: src/comm.c:139
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""
"\n"
"示例：\n"
"  %s -12 文件1 文件2  只打印在文件1 和文件2 中都有的行\n"
"  %s -3  文件1 文件2  打印在文件1 中有，而文件2 中没有的行。反之亦然。\n"

#: src/comm.c:224
#, c-format
msgid "file %d is not in sorted order"
msgstr "文件%d 没有被正确排序"

#: src/comm.c:409
#, c-format
msgid "multiple delimiters specified"
msgstr "已定义多重分隔符"

#: src/comm.c:413
#, c-format
msgid "empty %s not allowed"
msgstr "不允许空的%s"

#: src/copy.c:167 src/dd.c:1500 src/dd.c:1847
#, c-format
msgid "reading %s"
msgstr "正在读入%s"

#: src/copy.c:212 src/copy.c:363 src/copy.c:374 src/head.c:427
#, c-format
msgid "cannot lseek %s"
msgstr "无法lseek %s"

#: src/copy.c:224 src/dd.c:1910 src/dd.c:1973
#, c-format
msgid "writing %s"
msgstr "正在写入%s"

#: src/copy.c:330
#, c-format
msgid "%s: failed to get extents info"
msgstr "%s：无法获得 extent 信息"

#: src/copy.c:390
#, c-format
msgid "%s: write failed"
msgstr "%s：写入失败"

#: src/copy.c:459 src/copy.c:1077
#, c-format
msgid "failed to extend %s"
msgstr "扩展%s 失败"

#: src/copy.c:679
#, c-format
msgid "clearing permissions for %s"
msgstr "清除%s 的权限"

#: src/copy.c:714 src/copy.c:2404 src/cp.c:332
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "无法保留%s 的所有者"

#: src/copy.c:740
#, c-format
msgid "failed to lookup file %s"
msgstr "查阅文件%s 失败"

#: src/copy.c:745
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "保留%s 的作者失败"

#: src/copy.c:821 src/csplit.c:639 src/du.c:888 src/fmt.c:428 src/head.c:848
#: src/sort.c:4477 src/split.c:1219 src/tac.c:544 src/tail.c:1755 src/wc.c:679
#, c-format
msgid "cannot open %s for reading"
msgstr "无法打开%s 读取数据"

#: src/copy.c:827 src/copy.c:968 src/dd.c:1440 src/dd.c:2096 src/tail.c:1591
#: src/tail.c:1657 src/truncate.c:142
#, c-format
msgid "cannot fstat %s"
msgstr "无法获取%s 的文件状态(fstat)"

#: src/copy.c:837
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "跳过文件%s，因为在准备复制时它已被其它文件取代"

#: src/copy.c:865
#, c-format
msgid "failed to get file system create context"
msgstr "获取文件系统创建环境失败"

#: src/copy.c:879
#, c-format
msgid "failed to set the security context of %s to %s"
msgstr "设置%s 的安全环境为%s 失败"

#: src/copy.c:896 src/copy.c:1512 src/copy.c:1715 src/copy.c:1869 src/ln.c:277
#: src/remove.c:294 src/remove.c:320 src/remove.c:471 src/remove.c:492
#, c-format
msgid "cannot remove %s"
msgstr "无法删除%s"

#: src/copy.c:901 src/copy.c:1516 src/copy.c:1710 src/copy.c:1874
#: src/remove.c:445
#, c-format
msgid "removed %s\n"
msgstr "已删除%s\n"

#: src/copy.c:939
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "无法通过符号链接%s 进行操作"

#: src/copy.c:960
#, c-format
msgid "cannot create regular file %s"
msgstr "无法创建普通文件%s"

#: src/copy.c:981
#, fuzzy, c-format
msgid "failed to clone %s from %s"
msgstr "克隆%s 失败"

#: src/copy.c:1092 src/copy.c:2465
#, c-format
msgid "preserving times for %s"
msgstr "正在保留 %s 的时间"

#: src/copy.c:1164 src/copy.c:1170 src/head.c:856 src/touch.c:176
#: src/truncate.c:389
#, c-format
msgid "closing %s"
msgstr "正在关闭 %s"

#: src/copy.c:1404
#, c-format
msgid "%s: try to overwrite %s, overriding mode %04lo (%s)? "
msgstr "%s：是否覆盖%s，而不理会权限模式%04lo (%s)？ "

#: src/copy.c:1411
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s：是否覆盖%s？ "

#: src/copy.c:1480
#, c-format
msgid " (backup: %s)"
msgstr " (备份：%s)"

#: src/copy.c:1490
#, c-format
msgid "failed to restore the default file creation context"
msgstr "恢复默认文件创建环境失败"

#: src/copy.c:1522
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "无法创建指向%2$s 的硬链接%1$s"

#: src/copy.c:1583
#, c-format
msgid "omitting directory %s"
msgstr "略过目录%s"

#: src/copy.c:1597
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "警告：指定来源文件%s 多于一次"

#: src/copy.c:1645 src/ln.c:212
#, c-format
msgid "%s and %s are the same file"
msgstr "%s 与%s 为同一文件"

#: src/copy.c:1744
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "无法以目录%2$s 来覆盖非目录%1$s"

#: src/copy.c:1762 src/ln.c:180
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "不会以%2$s 覆盖刚创建的%1$s"

#: src/copy.c:1780
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "无法以非目录来覆盖目录%s"

#: src/copy.c:1794
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "无法将目录移动至非目录：%s -> %s"

#: src/copy.c:1824
#, c-format
msgid "backing up %s would destroy source;  %s not moved"
msgstr "备份%s 会破坏源文件；未移动%s"

#: src/copy.c:1825
#, c-format
msgid "backing up %s would destroy source;  %s not copied"
msgstr "备份%s 会破坏源文件；未复制%s"

#: src/copy.c:1844 src/ln.c:242
#, c-format
msgid "cannot backup %s"
msgstr "无法备份%s"

#: src/copy.c:1908
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "不会以%s 覆盖刚创建的%s"

#: src/copy.c:1985
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "无法将目录%s 复制到自己%s"

#: src/copy.c:2002
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "不会创建指向目录%2$s 的硬链接%1$s"

#: src/copy.c:2052
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "无法将目录%s 移动至自身的子目录%s 下"

#: src/copy.c:2095
#, c-format
msgid "cannot move %s to %s"
msgstr "无法将%s 移动至%s"

#: src/copy.c:2107
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr "无法进行跨设备的移动：%s 至%s；无法删除目标"

#: src/copy.c:2141 src/install.c:888 src/mkdir.c:190 src/mkfifo.c:115
#: src/mknod.c:168
#, c-format
msgid "failed to set default file creation context to %s"
msgstr "无法取得%s 的创建环境"

#: src/copy.c:2175
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "无法复制循环的符号链接%s"

#: src/copy.c:2284
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr "%s：只能于当前目录中创建相对的符号链接"

#: src/copy.c:2291
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "无法创建指向%2$s 的符号链接%1$s"

#: src/copy.c:2340 src/mkfifo.c:134
#, c-format
msgid "cannot create fifo %s"
msgstr "无法创建先进先出文件%s"

#: src/copy.c:2349
#, c-format
msgid "cannot create special file %s"
msgstr "无法创建特殊文件%s"

#: src/copy.c:2360 src/ls.c:3067 src/stat.c:888
#, c-format
msgid "cannot read symbolic link %s"
msgstr "无法读取符号链接%s"

#: src/copy.c:2387
#, c-format
msgid "cannot create symbolic link %s"
msgstr "无法创建符号链接%s"

#: src/copy.c:2419
#, c-format
msgid "%s has unknown file type"
msgstr "%s 的文件类型不详"

#: src/copy.c:2563 src/ln.c:320
#, c-format
msgid "cannot un-backup %s"
msgstr "无法将%s 的备份还原"

#: src/copy.c:2567
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (还原备份)\n"

#: src/cp.c:157 src/mv.c:285
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"用法：%s [选项]... [-T] 源文件 目标文件\n"
"　或：%s [选项]... 源文件... 目录\n"
"　或：%s [选项]... -t 目录 源文件...\n"

#: src/cp.c:163
msgid ""
"Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
"\n"
msgstr ""
"将源文件复制至目标文件，或将多个源文件复制至目标目录。\n"
"\n"

#: src/cp.c:167 src/csplit.c:1460 src/cut.c:198 src/df.c:820 src/du.c:268
#: src/expand.c:114 src/fmt.c:276 src/fold.c:76 src/head.c:116
#: src/install.c:595 src/kill.c:87 src/ln.c:353 src/ls.c:4602 src/mkdir.c:62
#: src/mkfifo.c:57 src/mknod.c:59 src/mv.c:295 src/nl.c:192 src/paste.c:446
#: src/pr.c:2779 src/ptx.c:1826 src/shred.c:165 src/shuf.c:59 src/sort.c:402
#: src/split.c:192 src/stdbuf.c:96 src/tac.c:142 src/tail.c:268
#: src/touch.c:228 src/truncate.c:108 src/unexpand.c:124 src/uniq.c:146
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr "长选项必须使用的参数对于短选项时也是必需使用的。\n"

#: src/cp.c:170
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive\t\t\t等于-dR --preserve=all\n"
"      --attributes-only\t仅复制属性而不复制数据      --backup[=CONTROL\t\t为"
"每个已存在的目标文件创建备份\n"
"  -b\t\t\t\t类似--backup 但不接受参数\n"
"      --copy-contents\t\t在递归处理是复制特殊文件内容\n"
"  -d\t\t\t\t等于--no-dereference --preserve=links\n"

#: src/cp.c:179
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (redundant "
"if\n"
"                                 the -n option is used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force\t\t\t如果目标文件无法打开则将其移除并重试(当 -n 选项\n"
"\t\t\t\t\t存在时则不需再选此项)\n"
"  -i, --interactive\t\t覆盖前询问(使前面的 -n 选项失效)\n"
"  -H\t\t\t\t跟随源文件中的命令行符号链接\n"

#: src/cp.c:189
#, fuzzy
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link\t\t\t链接文件而不复制\n"
"  -L, --dereference\t\t总是跟随符号链接\n"

#: src/cp.c:193
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber\t\t不要覆盖已存在的文件(使前面的 -i 选项失效)\n"
"  -P, --no-dereference\t\t不跟随源文件中的符号链接\n"

#: src/cp.c:198
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p\t\t\t\t等于--preserve=模式,所有权,时间戳\n"
"      --preserve[=属性列表\t保持指定的属性(默认：模式,所有权,时间戳)，如果\n"
"\t\t\t\t\t可能保持附加属性：环境、链接、xattr 等\n"

#: src/cp.c:206
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --sno-preserve=属性列表\t不保留指定的文件属性\n"
"      --parents\t\t\t复制前在目标目录创建来源文件路径中的所有目录\n"

#: src/cp.c:210
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive\t\t递归复制目录及其子目录内的所有内容\n"
"      --reflink[=WHEN]\t\t控制克隆/CoW 副本。请查看下面的内如。\n"
"      --remove-destination\t尝试打开目标文件前先删除已存在的目的地\n"
"\t\t\t\t\t文件 (相对于 --force 选项)\n"

#: src/cp.c:216
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=WHEN\t\t控制创建稀疏文件的方式\n"
"      --strip-trailing-slashes\t删除参数中所有源文件/目录末端的斜杠\n"

#: src/cp.c:221
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link\t\t只创建符号链接而不复制文件\n"
"  -S, --suffix=后缀\t\t自行指定备份文件的后缀\n"
"  -t,  --target-directory=目录\t将所有参数指定的源文件/目录\n"
"                                           复制至目标目录\n"
"  -T, --no-target-directory\t将目标目录视作普通文件\n"

#: src/cp.c:227
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update\t\t\t只在源文件比目标文件新，或目标文件\n"
"\t\t\t\t\t不存在时才进行复制\n"
"  -v, --verbose\t\t显示详细的进行步骤\n"
"  -x, --one-file-system\t不跨越文件系统进行操作\n"

#: src/cp.c:236
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
msgstr ""
"\n"
"默认情况下，源文件的稀疏性仅仅通过简单的方法判断，对应的目标文件目标文件也\n"
"被为稀疏。这是因为默认情况下使用了--sparse=auto 参数。如果明确使用\n"
"--sparse=always 参数则不论源文件是否包含足够长的0 序列也将目标文件创文\n"
"建为稀疏件。\n"
"使用--sparse=never 参数禁止创建稀疏文件。\n"
"\n"
"当指定了--reflink[=always] 参数时执行轻量化的复制，即只在数据块被修改的\n"
"情况下才复制。如果复制失败或者同时指定了--reflink=auto，则返回标准复制模"
"式。\n"

#: src/cp.c:248 src/install.c:632 src/ln.c:381 src/mv.c:322
msgid ""
"\n"
"The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"备份文件的后缀为\"~\"，除非以--suffix 选项或是SIMPLE_BACKUP_SUFFIX\n"
"环境变量指定。版本控制的方式可通过--backup 选项或VERSION_CONTROL 环境\n"
"变量来选择。以下是可用的变量值：\n"
"\n"

#: src/cp.c:255 src/install.c:639 src/ln.c:393 src/mv.c:329
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       不进行备份(即使使用了--backup 选项)\n"
"  numbered, t     备份文件加上数字进行排序\n"
"  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备"
"份\n"
"  simple, never   永远使用普通方式备份\n"

#: src/cp.c:261
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"有一个特别情况：如果同时指定--force 和--backup 选项，而源文件和目标文件\n"
"是同一个已存在的一般文件的话，cp 会将源文件备份。\n"

#: src/cp.c:320
#, c-format
msgid "failed to preserve times for %s"
msgstr "无法保留%s 的时间"

#: src/cp.c:351
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "保留%s 的权限失败"

#: src/cp.c:478
#, c-format
msgid "cannot make directory %s"
msgstr "无法创建目录%s"

#: src/cp.c:527 src/cp.c:546
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s 存在但并非目录"

#: src/cp.c:573 src/cp.c:1069 src/install.c:383 src/install.c:827 src/ln.c:117
#: src/ln.c:147 src/ln.c:168 src/ln.c:473 src/mv.c:152 src/mv.c:400
#, c-format
msgid "accessing %s"
msgstr "正在访问%s"

#: src/cp.c:593 src/install.c:897 src/ln.c:503 src/mv.c:433 src/shred.c:1194
#: src/touch.c:435 src/truncate.c:344
#, c-format
msgid "missing file operand"
msgstr "缺少了文件操作数"

#: src/cp.c:595 src/install.c:899 src/ln.c:517 src/mv.c:435
#, c-format
msgid "missing destination file operand after %s"
msgstr "在%s 后缺少了要操作的目标文件"

#: src/cp.c:604 src/install.c:908 src/mv.c:444
#, c-format
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr "无法同时使用--target-directory (-t) 和--no-target-directory (-T) 选项"

#: src/cp.c:620 src/cp.c:1071 src/install.c:385 src/install.c:829
#: src/install.c:921 src/ln.c:119 src/ln.c:475 src/ln.c:531 src/mv.c:402
#: src/mv.c:458
#, c-format
msgid "target %s is not a directory"
msgstr "目标%s 不是目录"

#: src/cp.c:731
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "当跟随--parents 选项时，目的地必须是目录"

#: src/cp.c:1064 src/install.c:822 src/ln.c:468 src/mv.c:395
#, c-format
msgid "multiple target directories specified"
msgstr "指定了多个目标目录"

#: src/cp.c:1109
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "无法同时创建硬链接及符号链接"

#: src/cp.c:1116 src/mv.c:465
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "选项--backup 和 --no-clobber 互斥"

#: src/cp.c:1122
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "--reflink 只能与--sparse=auto 一起用"

#: src/cp.c:1130 src/install.c:882 src/ln.c:539 src/mv.c:473
msgid "backup type"
msgstr "备份方式"

#: src/cp.c:1155
#, c-format
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr "无法在未启用SELinux 支持的内核上使用安全环境"

#: src/cp.c:1161
#, c-format
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr "无法保留扩展属性，当前使用的 cp 副本编译时没有启用 xattr 支持"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:41 src/dd.c:45
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:530
#, c-format
msgid "input disappeared"
msgstr "输入消失"

#: src/csplit.c:659 src/csplit.c:670
#, c-format
msgid "%s: line number out of range"
msgstr "%s：行数超出范围"

#: src/csplit.c:699
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s：%s：行数超出范围"

#: src/csplit.c:702 src/csplit.c:751
#, c-format
msgid " on repetition %s\n"
msgstr " 在循环位%s\n"

#: src/csplit.c:745
#, c-format
msgid "%s: %s: match not found"
msgstr "%s：%s：无匹配"

#: src/csplit.c:809 src/csplit.c:849 src/nl.c:360 src/tac.c:274
#, c-format
msgid "error in regular expression search"
msgstr "正则表达式搜索时出错"

#: src/csplit.c:982
#, c-format
msgid "write error for %s"
msgstr "写入%s 时出错"

#: src/csplit.c:1058
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s：分界符后应该跟随整数"

#: src/csplit.c:1074
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s：在重复计数中需要\"}\"字符"

#: src/csplit.c:1084
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}：在\"{\"和\"}\"之间需要一个整数声明"

#: src/csplit.c:1111
#, c-format
msgid "%s: closing delimiter `%c' missing"
msgstr "%s：闭合定义符\"%c\"缺失"

#: src/csplit.c:1128
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s：无效的正则表达式：%s"

#: src/csplit.c:1161
#, c-format
msgid "%s: invalid pattern"
msgstr "%s：无效的模式"

#: src/csplit.c:1164
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s：行号必须大于0"

#: src/csplit.c:1170
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "行号%s 比先前的行号%s 更小"

#: src/csplit.c:1176
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "警告：行号%s 比先前的行号更小"

#: src/csplit.c:1254
#, c-format
msgid "missing conversion specifier in suffix"
msgstr "下标中丢失了转换规格"

#: src/csplit.c:1260
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "下标中出现无效的转换规格：%c"

#: src/csplit.c:1263
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "下标中出现无效的转换规格：\\%.3o"

#: src/csplit.c:1268
#, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "无效的转换声明%%%c%c"

#: src/csplit.c:1285
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "下标中出现过多的%% 转换规格字符"

#: src/csplit.c:1299
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "下标中丢失了%% 转换规格字符"

#: src/csplit.c:1346
#, c-format
msgid "%s: invalid number"
msgstr "%s：无效数字"

#: src/csplit.c:1451
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "用法：%s [选项]... 文件 格式...\n"

#: src/csplit.c:1455
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx00', `xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
msgstr ""
"按照指定的格式将文件分块为\"xx00\"、\"xx01\"...并输出。\n"
"同时每个分块文件的字节数也将被输出到标准输出。\n"
"\n"

#: src/csplit.c:1463
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=格式\t使用sprintf 格式代替%02d\n"
"  -f, --prefix=前缀\t\t使用指定前缀代替\"xx\"\n"
"  -k, --keep-files\t\t不移除错误的输出文件\n"

#: src/csplit.c:1468
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=数位\t\t使用指定的进制数位代替二进制\n"
"  -s, --quiet, --silent\t不显示输出文件的尺寸计数\n"
"  -z, --elide-empty-files\t删除空的输出文件\n"

#: src/csplit.c:1475
msgid ""
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
msgstr ""
"\n"
"如果文件为\"-\"，则读取标准输入。每个\"格式\"可以是：\n"

#: src/csplit.c:1479
msgid ""
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""
"\n"
"  整数\t\t\t不包括指定的行，并以其为文件分块边界\n"
"  /表达式/[偏移量]\t不包括匹配到的行，并以其为文件分块边界\n"
"  %表达式%[偏移量]\t预先跳过匹配的行数，以其为文件分块边界\n"
"  {整数}\t\t将之前指定的模式重复指定的次数\n"
"  {*}\t\t\t将之前指定的模式重复尽可能多的次数。\n"
"\n"
"一个行的偏移量需要在正整数值之后声明\"+\" 或 \"-\"。\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:44 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:64
msgid "fields and positions are numbered from 1"
msgstr "序号从1 开始计数"

#: src/cut.c:190
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "用法：%s [选项]... [文件]...\n"

#: src/cut.c:194
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
msgstr ""
"从每个文件中输出指定部分到标准输出。\n"
"\n"

#: src/cut.c:201
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=列表\t\t只选中指定的这些字节\n"
"  -c, --characters=列表\t\t只选中指定的这些字符\n"
"  -d, --delimiter=分界符\t使用指定分界符代替制表符作为区域分界\n"

#: src/cut.c:206
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=列表\t\t只选中指定的这些域；并打印所有不包含分界符的\n"
"\t\t\t\t行，除非-s 选项被指定\n"
"  -n\t\t\t\t(忽略)\n"

#: src/cut.c:212
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr "      --complement\t\t补全选中的字节、字符或域\n"

#: src/cut.c:216
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited\t\t不打印没有包含分界符的行\n"
"      --output-delimiter=字符串\t使用指定的字符串作为输出分界符，默认采用输"
"入\n"
"\t\t\t\t的分界符\n"

#: src/cut.c:223
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"仅使用f -b, -c 或-f 中的一个。每一个列表都是专门为一个类别作出的，或者您可以"
"用逗号隔\n"
"开要同时显示的不同类别。您的输入顺序将作为读取顺序，每个仅能输入一次。\n"

#: src/cut.c:229
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"每种参数格式表示范围如下：\n"
"    N\t从第1 个开始数的第N 个字节、字符或域\n"
"    N-\t从第N 个开始到所在行结束的所有字符、字节或域\n"
"    N-M\t从第N 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n"
"    -M\t从第1 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n"
"\n"
"当没有文件参数，或者文件不存在时，从标准输入读取\n"

#: src/cut.c:369 src/cut.c:490
msgid "invalid byte or field list"
msgstr "无效的字节或域列表"

#: src/cut.c:386
msgid "invalid range with no endpoint: -"
msgstr "无终点的无效的范围：-"

#: src/cut.c:400
msgid "invalid decreasing range"
msgstr "无效的缩小的范围"

#: src/cut.c:479
#, c-format
msgid "byte offset %s is too large"
msgstr "字节偏移量%s 过大"

#: src/cut.c:482
#, c-format
msgid "field number %s is too large"
msgstr "域编号%s 过大"

#: src/cut.c:790 src/cut.c:798
msgid "only one type of list may be specified"
msgstr "只能指定列表中的一种类型"

#: src/cut.c:807
msgid "the delimiter must be a single character"
msgstr "分界符必须是单个字符"

#: src/cut.c:842
msgid "you must specify a list of bytes, characters, or fields"
msgstr "您必须指定一组字节、字符或域的列表"

#: src/cut.c:845
msgid "an input delimiter may be specified only when operating on fields"
msgstr "只有当操作域时才可以指定输入分界符"

#: src/cut.c:849
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"清除没有分界符的行只有在\n"
"\t操作域时才有意义"

#: src/cut.c:865
msgid "missing list of fields"
msgstr "缺少域列表"

#: src/cut.c:867
msgid "missing list of positions"
msgstr "缺少位置列表"

#: src/date.c:124
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"用法：%s [选项]... [+格式]\n"
"　或：%s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"

#: src/date.c:129
msgid ""
"Display the current time in the given FORMAT, or set the system date.\n"
"\n"
"  -d, --date=STRING         display time described by STRING, not `now'\n"
"  -f, --file=DATEFILE       like --date once for each line of DATEFILE\n"
msgstr ""
"以给定的格式显示当前时间，或是设置系统日期。\n"
"\n"
"  -d,--date=字符串\t\t显示指定字符串所描述的时间，而非当前时间\n"
"  -f,--file=日期文件\t\t类似--date，从日期文件中按行读入时间描述\n"

#: src/date.c:135
msgid ""
"  -r, --reference=FILE      display the last modification time of FILE\n"
"  -R, --rfc-2822            output date and time in RFC 2822 format.\n"
"                            Example: Mon, 07 Aug 2006 12:34:56 -0600\n"
msgstr ""
"  -r, --reference=文件\t\t显示文件指定文件的最后修改时间\n"
"  -R, --rfc-2822\t\t以RFC 2822格式输出日期和时间\n"
"\t\t\t\t例如：2006年8月7日，星期一 12:34:56 -0600\n"

#: src/date.c:140
msgid ""
"      --rfc-3339=TIMESPEC   output date and time in RFC 3339 format.\n"
"                            TIMESPEC=`date', `seconds', or `ns' for\n"
"                            date and time to the indicated precision.\n"
"                            Date and time components are separated by\n"
"                            a single space: 2006-08-07 12:34:56-06:00\n"
"  -s, --set=STRING          set time described by STRING\n"
"  -u, --utc, --universal    print or set Coordinated Universal Time\n"
msgstr ""
"      --rfc-3339=TIMESPEC\t以RFC 3339 格式输出日期和时间。\n"
"\t\t\t\tTIMESPEC=`date'，`seconds'，或 `ns' \n"
"\t\t\t\t表示日期和时间的显示精度。\n"
"\t\t\t\t日期和时间单元由单个的空格分开：\n"
"\t\t\t\t2006-08-07 12:34:56-06:00\n"
"  -s, --set=字符串         \t设置指定字符串来分开时间\n"
"  -u, --utc, --universal\t输出或者设置协调的通用时间\n"

#: src/date.c:151
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"给定的格式FORMAT 控制着输出，解释序列如下：\n"
"\n"
"  %%\t一个文字的 %\n"
"  %a\t当前locale 的星期名缩写(例如： 日，代表星期日)\n"

#: src/date.c:158
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A\t当前locale 的星期名全称 (如：星期日)\n"
"  %b\t当前locale 的月名缩写 (如：一，代表一月)\n"
"  %B\t当前locale 的月名全称 (如：一月)\n"
"  %c\t当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)\n"

#: src/date.c:164
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C\t世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)\n"
"  %d\t按月计的日期(例如：01)\n"
"  %D\t按月计的日期；等于%m/%d/%y\n"
"  %e\t按月计的日期，添加空格，等于%_d\n"

#: src/date.c:170
msgid ""
"  %F   full date; same as %Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F\t完整日期格式，等价于 %Y-%m-%d\n"
"  %g\tISO-8601 格式年份的最后两位 (参见%G)\n"
"  %G\tISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用\n"

#: src/date.c:175
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h\t等于%b\n"
"  %H\t小时(00-23)\n"
"  %I\t小时(00-12)\n"
"  %j\t按年计的日期(001-366)\n"

#: src/date.c:181
#, fuzzy
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k\t时(0-23)\n"
"  %l\t时(1-12)\n"
"  %m\t月份(01-12)\n"
"  %M\t分(00-59)\n"

#: src/date.c:187
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""
"  %n\t换行\n"
"  %N\t纳秒(000000000-999999999)\n"
"  %p\t当前locale 下的\"上午\"或者\"下午\"，未知时输出为空\n"
"  %P\t与%p 类似，但是输出小写字母\n"
"  %r\t当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)\n"
"  %R\t24 小时时间的时和分，等价于 %H:%M\n"
"  %s\t自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数\n"

#: src/date.c:196
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S\t秒(00-60)\n"
"  %t\t输出制表符 Tab\n"
"  %T\t时间，等于%H:%M:%S\n"
"  %u\t星期，1 代表星期一\n"

#: src/date.c:202
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U\t一年中的第几周，以周日为每星期第一天(00-53)\n"
"  %V\tISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)\n"
"  %w\t一星期中的第几日(0-6)，0 代表周一\n"
"  %W\t一年中的第几周，以周一为每星期第一天(00-53)\n"

#: src/date.c:208
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x\t当前locale 下的日期描述 (如：12/31/99)\n"
"  %X\t当前locale 下的时间描述 (如：23:13:48)\n"
"  %y\t年份最后两位数位 (00-99)\n"
"  %Y\t年份\n"

#: src/date.c:214
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z +hhmm\t\t数字时区(例如，-0400)\n"
"  %:z +hh:mm\t\t数字时区(例如，-04:00)\n"
"  %::z +hh:mm:ss\t数字时区(例如，-04:00:00)\n"
"  %:::z\t\t\t数字时区带有必要的精度 (例如，-04，+05:30)\n"
"  %Z\t\t\t按字母表排序的时区缩写 (例如，EDT)\n"
"\n"
"默认情况下，日期的数字区域以0 填充。\n"

#: src/date.c:223
msgid ""
"The following optional flags may follow `%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""
"以下可选标记可以跟在\"%\"后:\n"
"\n"
"  - (连字符)不填充该域\n"
"  _ (下划线)以空格填充\n"
"  0 (数字0)以0 填充\n"
"  ^ 如果可能，使用大写字母\n"
"  # 如果可能，使用相反的大小写\n"

#: src/date.c:232
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。\n"
"作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的\n"
"表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。\n"

#: src/date.c:239
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""

#: src/date.c:272 src/dd.c:2037 src/head.c:839 src/md5sum.c:460
#: src/md5sum.c:781 src/od.c:859 src/od.c:1911 src/pr.c:1177 src/pr.c:1373
#: src/pr.c:1495 src/stty.c:843 src/tac.c:535 src/tail.c:343 src/tee.c:127
#: src/tr.c:1946 src/tsort.c:531 src/wc.c:197
#, c-format
msgid "standard input"
msgstr "标准输入"

#: src/date.c:300 src/date.c:520
#, c-format
msgid "invalid date %s"
msgstr "无效的日期%s"

#: src/date.c:411 src/date.c:445
#, c-format
msgid "multiple output formats specified"
msgstr "指定了多种输出格式"

#: src/date.c:423
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "被指定的这几种日期显示选项是相互抵触的"

#: src/date.c:430
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr "显示与设置时间的选项不能同时使用"

#: src/date.c:451
#, c-format
msgid ""
"the argument %s lacks a leading `+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with `+'"
msgstr ""
"参数%s 缺少前导的\"+\"；\n"
"当使用选项来描述日期是，任何非选项参数都必须以\"+\"所引导的字符串出现"

#: src/date.c:528
#, c-format
msgid "cannot set date"
msgstr "无法设置日期"

#: src/date.c:551 src/du.c:360
#, c-format
msgid "time %s is out of range"
msgstr "时间%s 超出范围"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:43 src/factor.c:43 src/rm.c:41 src/tail.c:68 src/touch.c:42
#: src/wc.c:50
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:482
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [操作数] ...\n"
"　或：%s 选项\n"

#: src/dd.c:487
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=BLOCKS    copy only BLOCKS input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""
"复制文件，依照操作数转换并格式化。\n"
"\n"
"  bs=比特数\t一次读写的比特数\n"
"  cbs=比特数\t一次转换的比特数\n"
"  conv=CONVS\t依照每个逗号分割的标志列表转换文件\n"
"  count=块数\t只将指定个块数复制到块\n"
"  ibs=比特数\t一次读取的比特数(默认：512)\n"

#: src/dd.c:496
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=BLOCKS     skip BLOCKS obs-sized blocks at start of output\n"
"  skip=BLOCKS     skip BLOCKS ibs-sized blocks at start of input\n"
"  status=noxfer   suppress transfer statistics\n"
msgstr ""
"  if=文件\t从指定文件中读取\n"
"  iflag=符号\t按照以逗号分隔的符号列表指定的方式读取\n"
"  obs=比特数\t一次写入指定比特数(默认：512)\n"
"  of=文件\t写入到指定文件\n"
"  oflag=符号\t按照以逗号分隔的符号列表指定的方式写入\n"
"  seek=块数\t在输出开始处跳过指定的块数\n"
"  skip=块数\t在输入开始处跳过指定的块数\n"
"  status=noxfer\t禁止传输统计\n"

#: src/dd.c:506
msgid ""
"\n"
"BLOCKS and BYTES may be followed by the following multiplicative suffixes:\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M\n"
"GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"块和字节数后可能带有以下的一个或多个后缀：\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M\n"
"GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
"每个 CONV 符号可能为：\n"
"\n"

#: src/dd.c:515
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  ascii\t\t由EBCDIC 码转换至ASCII 码\n"
"  ebcdic\t由ASCII 码转换至EBCDIC 码\n"
"  ibm\t\t由ASCII 码转换至替换的EBCDIC 码\n"
"  block\t\t将结束字符块里的换行替换成等长的空格\n"
"  unblock\t将cbs 大小的块中尾部的空格替换为一个换行符\n"
"  lcase\t\t将大写字符转换为小写\n"
"  ucase\t\t将小写字符转换为大写\n"
"  swab\t\t交换每一对输入数据字节\n"
"  sync\t\t将每个输入数据块以NUL 字符填满至ibs 的大小；当配合block\n"
"\t\t或unblock 时，会以空格代替NUL 字符填充\n"

#: src/dd.c:527
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl\t\tfail if the output file already exists\n"
"  nocreat\tdo not create the output file\n"
"  notrunc\t不截断输出文件\n"
"  noerror\t读取数据发生错误后仍然继续\n"
"  fdatasync\t结束前将输出文件数据写入磁盘\n"
"  fsync\t类似上面，但是元数据也一同写入\n"

#: src/dd.c:535
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"FLAG 符号可以是：\n"
"\n"
"  append\t追加模式(仅对输出有意义；隐含了conv=notrunc)\n"

#: src/dd.c:542
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio\t使用并行I/O 存取模式\n"

#: src/dd.c:544
msgid "  direct    use direct I/O for data\n"
msgstr "  direct\t使用直接I/O 存取模式\n"

#: src/dd.c:546
msgid "  directory  fail unless a directory\n"
msgstr "  directory\t除非是目录，否则 directory 失败\n"

#: src/dd.c:548
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync\t\t使用同步I/O 存取模式\n"

#: src/dd.c:550
msgid "  sync      likewise, but also for metadata\n"
msgstr "  sync\t\t与上者类似，但同时也对元数据生效\n"

#: src/dd.c:551
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr "  fullblock\t为输入积累完整块(仅iflag)\n"

#: src/dd.c:554
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock\t使用无阻塞I/O 存取模式\n"

#: src/dd.c:556
msgid "  noatime   do not update access time\n"
msgstr "  noatime\t不更新存取时间\n"

#: src/dd.c:559
msgid "  nocache   discard cached data\n"
msgstr "  nocache\t丢弃缓存数据\n"

#: src/dd.c:562
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty\t不根据文件指派控制终端\n"

#: src/dd.c:565
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow\t不跟随链接文件\n"

#: src/dd.c:567
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks\t如果有多重链接，则nolinks 失败\n"

#: src/dd.c:569
msgid "  binary    use binary I/O for data\n"
msgstr "  binary\t使用二进制I/O 存取模式\n"

#: src/dd.c:571
msgid "  text      use text I/O for data\n"
msgstr "  text\t使用文本I/O 存取模式\n"

#: src/dd.c:575
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running `dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
"  $ kill -%s $pid; sleep 1; kill $pid\n"
"  18335302+0 records in\n"
"  18335302+0 records out\n"
"  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"对运行中的\"dd\"进程发送一个%s 信号会使得\n"
"I/O 的统计信息被打印到标准错误设备然后恢复复制操作。\n"
"\n"
"  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
"  $ kill -%s $pid; sleep 1; kill $pid\n"
"  18335302+0 records in\n"
"  18335302+0 records out\n"
"  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
"\n"
"可用选项有：\n"
"\n"

#: src/dd.c:631
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"记录了%<PRIuMAX>+%<PRIuMAX> 的读入\n"
"记录了%<PRIuMAX>+%<PRIuMAX> 的写出\n"

#: src/dd.c:637
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> 个被截断了的块\n"

#: src/dd.c:649
#, c-format
msgid "%<PRIuMAX> byte (%s) copied"
msgid_plural "%<PRIuMAX> bytes (%s) copied"
msgstr[0] "%<PRIuMAX>字节(%s)已复制"

#: src/dd.c:667
msgid "Infinity B"
msgstr "无穷量 B"

#. TRANSLATORS: The two instances of "s" in this string are the SI
#. symbol "s" (meaning second), and should not be translated.
#.
#. This format used to be:
#.
#. ngettext (", %g second, %s/s\n", ", %g seconds, %s/s\n", delta_s == 1)
#.
#. but that was incorrect for languages like Polish.  To fix this
#. bug we now use SI symbols even though they're a bit more
#. confusing in English.
#: src/dd.c:680
#, c-format
msgid ", %g s, %s/s\n"
msgstr "，%g 秒，%s/秒\n"

#: src/dd.c:759
#, c-format
msgid "closing input file %s"
msgstr "正在关闭输入文件%s"

#: src/dd.c:766
#, c-format
msgid "closing output file %s"
msgstr "正在关闭输出文件%s"

#: src/dd.c:969
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "无法关闭O_DIRECT：%s"

#: src/dd.c:1021 src/dd.c:1814
#, c-format
msgid "writing to %s"
msgstr "正在写入%s"

#: src/dd.c:1132 src/dd.c:1186
#, c-format
msgid "unrecognized operand %s"
msgstr "无法识别的操作数%s"

#: src/dd.c:1143
msgid "invalid conversion"
msgstr "转换无效"

#: src/dd.c:1146
msgid "invalid input flag"
msgstr "输入标志无效"

#: src/dd.c:1149 src/dd.c:1216
msgid "invalid output flag"
msgstr "输出标志无效"

#: src/dd.c:1152
msgid "invalid status flag"
msgstr "状态标志无效"

#: src/dd.c:1191 src/truncate.c:300
#, c-format
msgid "invalid number %s"
msgstr "无效的数字%s"

#: src/dd.c:1236
#, c-format
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "不可将{ascii、ebcdic、idm}中的任意两个结合使用"

#: src/dd.c:1238
#, c-format
msgid "cannot combine block and unblock"
msgstr "不可将block 和unblock 结合使用"

#: src/dd.c:1240
#, c-format
msgid "cannot combine lcase and ucase"
msgstr "不可将lcase 和ucase 结合使用"

#: src/dd.c:1242
#, c-format
msgid "cannot combine excl and nocreat"
msgstr "不可将excl 和nocreat 结合使用"

#: src/dd.c:1245
#, c-format
msgid "cannot combine direct and nocache"
msgstr "不可将direct 和nocreat 结合使用"

#: src/dd.c:1402
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"警告：暂时避免有关文件%s 的lseek 内核错误\n"
"  错误地址在mt_type=0x%0lx -- 有关mt_type 类型的列表请参考<sys/mtio.h>"

#: src/dd.c:1484
#, c-format
msgid "%s: cannot skip"
msgstr "%s：无法跳过"

#: src/dd.c:1486 src/dd.c:1508 src/dd.c:1565
#, c-format
msgid "%s: cannot seek"
msgstr "%s：无法搜索"

#: src/dd.c:1545
#, c-format
msgid "offset overflow while reading file %s"
msgstr "读入文件%s 时偏移量溢出"

#: src/dd.c:1557
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "警告：文件读取失败后偏移错误"

#: src/dd.c:1561
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "无法避免内核的错误"

#: src/dd.c:1704
#, c-format
msgid "setting flags for %s"
msgstr "正在设置%s 的标记"

#: src/dd.c:1757
#, c-format
msgid "memory exhausted by input buffer of size %zu bytes (%s)"
msgstr "%zu 字节的输入缓冲导致内存耗尽(%s)"

#: src/dd.c:1771
#, c-format
msgid "memory exhausted by output buffer of size %zu bytes (%s)"
msgstr "%zu 字节的输出缓冲导致内存耗尽(%s)"

#: src/dd.c:1797
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s：无法跳至指定偏移量"

#: src/dd.c:1982
#, c-format
msgid "fdatasync failed for %s"
msgstr "%s 的fdatasync 失败"

#: src/dd.c:1992
#, c-format
msgid "fsync failed for %s"
msgstr "%s 的fsync 失败"

#: src/dd.c:2043 src/dd.c:2072
#, c-format
msgid "opening %s"
msgstr "正在打开%s"

#: src/dd.c:2081
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr "偏移量过大：无法在seek=%<PRIuMAX> (%lu-字节) 块的长度上实施截断"

#: src/dd.c:2102
#, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "无法针对输出文件%2$s 的%1$<PRIuMAX> 字节处实施截断"

#: src/dd.c:2118 src/dd.c:2124
#, c-format
msgid "failed to discard cache for: %s"
msgstr "无法丢弃缓存：%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:43 src/du.c:54 src/expr.c:153 src/kill.c:33 src/pathchk.c:32
#: src/shuf.c:39 src/sleep.c:36 src/sort.c:68
msgid "Paul Eggert"
msgstr "Paul Eggert"

# ## Proof reading to here.
#: src/df.c:139
msgid "Filesystem"
msgstr "文件系统"

#: src/df.c:140
msgid "Type"
msgstr "类型"

#: src/df.c:141
msgid "blocks"
msgstr "块"

#: src/df.c:141
msgid "Inodes"
msgstr "Inode"

#: src/df.c:141
msgid "Size"
msgstr "容量"

#: src/df.c:142
msgid "Used"
msgstr "已用"

#: src/df.c:142
msgid "IUsed"
msgstr "已用(I)"

#: src/df.c:143
msgid "Available"
msgstr "可用"

#: src/df.c:143
msgid "IFree"
msgstr "可用(I)"

#: src/df.c:143
msgid "Avail"
msgstr "可用"

#: src/df.c:144
msgid "Use%"
msgstr "已用%"

#: src/df.c:144
msgid "IUse%"
msgstr "已用(I)%"

#: src/df.c:144
msgid "Capacity"
msgstr "配额"

#: src/df.c:145
msgid "Mounted on"
msgstr "挂载点"

#: src/df.c:815
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
"\n"
msgstr ""
"显示每个文件所在的文件系统的信息，默认是显示所有文件系统。\n"
"\n"

#: src/df.c:823
msgid ""
"  -a, --all             include dummy file systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them.  E.g.,\n"
"                           `-BM' prints sizes in units of 1,048,576 bytes.\n"
"                           See SIZE format below.\n"
"      --total           produce a grand total\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"  -H, --si              likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -a, --all\t\t包含虚拟文件系统\n"
"  -B, --block-size=大小\t使用指定字节数的块。例如-BM 以 1,248,576\n"
"\t\t\t字节为单位显示大小。参看SIZE 格式。      --total\t\t显示总计信息\n"
"  -h, --human-readable\t以可读性较好的格式显示尺寸(例如：1K 234M 2G)\n"
"  -H, --si\t\t计算时使用1000 为基底而非1024\n"

#: src/df.c:833
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes\t\t显示inode 信息而非块使用量\n"
"  -k\t\t\t即--block-size=1K\n"
"  -l, --local\t\t只显示本机的文件系统\n"
"      --no-sync\t\t取得使用量数据前不进行同步动作(默认)\n"

#: src/df.c:840
msgid ""
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -P, --portability\t使用POSIX 兼容的输出格式\n"
"      --sync\t\t取得使用量数据前先进行同步动作\n"
"  -t, --type=类型\t只显示指定文件系统为指定类型的信息\n"
"  -T, --print-type\t显示文件系统类型\n"
"  -x, --exclude-type=类型\t只显示文件系统不是指定类型信息\n"
"  -v\t\t\t(忽略)\n"

#: src/df.c:995
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "不能同时选择和排除文件系统类型%s"

#: src/df.c:1043
msgid "Warning: "
msgstr "警告："

#: src/df.c:1045 src/stat.c:781
msgid "cannot read table of mounted file systems"
msgstr "%s 无法读取已挂载上的文件系统的目录"

#: src/df.c:1075
#, c-format
msgid "no file systems processed"
msgstr "未处理文件系统"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:35
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:98 src/uptime.c:197 src/users.c:106
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "用法：%s [选项]... [文件]\n"

#: src/dircolors.c:99
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"输出用来设置 LS_COLORS 环境变量的命令。\n"
"\n"
"指定输出的规格：\n"
"  -b, --sh, --bourne-shell\t输出设置LS_COLORS 的Bourne shell 命令\n"
"  -c, --csh, --c-shell\t\t输出设置LS_COLORS 的C shell 命令\n"
"  -p, --print-database\t\t输出默认的色彩设置\n"

#: src/dircolors.c:109
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run `dircolors --print-database'.\n"
msgstr ""
"\n"
"如果指定了文件，则读取该文件的数据来决定文件类型及扩展名相应的颜色。\n"
"否则，会使用默认的数据库。如要了解此文件格式的细节，请执行：\n"
"\"dircolors --print-database\"。\n"

#: src/dircolors.c:287
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s：%lu：此行无效；缺少了第二栏数据"

#: src/dircolors.c:359
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s：%lu：无法识别的关键字%s"

#: src/dircolors.c:360
msgid "<internal>"
msgstr "<内部数据>"

#: src/dircolors.c:441
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"显示 dircolors 内部数据库的选项和选择 shell 语法的选项\n"
"是互相抵触的"

#: src/dircolors.c:451
msgid "file operands cannot be combined with --print-database (-p)"
msgstr "文件操作和--print-database (-p)不能同时使用"

#: src/dircolors.c:474
#, c-format
msgid "no SHELL environment variable, and no shell type option given"
msgstr "没有设置SHELL 环境变量，也没有指定shell 类型的选项"

#: src/dirname.c:45
#, c-format
msgid ""
"Usage: %s NAME\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 名称\n"
"　或：%s 选项\n"

#: src/dirname.c:50
msgid ""
"Output NAME with its last non-slash component and trailing slashes removed;\n"
"if NAME contains no /'s, output `.' (meaning the current directory).\n"
"\n"
msgstr ""
"输出已经去除了尾部的\"/\"字符部分的名称；如果名称中不包含\"/\"，\n"
"则显示\".\"(表示当前目录)。\n"
"\n"

#: src/dirname.c:57
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/      Output \"/usr\".\n"
"  %s stdio.h        Output \".\".\n"
msgstr ""
"\n"
"示例：\n"
"  %s /usr/bin/\t输出\"/usr\"。\n"
"  %s stdio.h\t\t输出\".\"。\n"

#: src/du.c:260 src/sort.c:393 src/wc.c:113
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"　或：%s [选项]... --files0-from=F\n"

#: src/du.c:264
msgid ""
"Summarize disk usage of each FILE, recursively for directories.\n"
"\n"
msgstr ""
"计算每个文件的磁盘用量，目录则取总用量。\n"
"\n"

#: src/du.c:271
msgid ""
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in (`sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -a, --all\t\t输出所有文件的磁盘用量，不仅仅是目录\n"
"      --apparent-size\t显示表面用量，而并非是磁盘用量；虽然表面用量通常会\n"
"\t\t\t小一些，但有时它会因为稀疏文件间的\"洞\"、内部碎\n"
"\t\t\t片、非直接引用的块等原因而变大。\n"

#: src/du.c:279
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them.  E.g.,\n"
"                           `-BM' prints sizes in units of 1,048,576 bytes.\n"
"                           See SIZE format below.\n"
"  -b, --bytes           equivalent to `--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
msgstr ""
"  -B, --block-size=大小\t使用指定字节数的块。例如-BM 以 1,048,576\n"
"\t\t\t字节为单位显示大小。参看SIZE 格式。  -b, --bytes\t\t等于--apparent-"
"size --block-size=1\n"
"  -c, --total\t\t显示总计信息\n"
"  -D, --dereference-args\t解除命令行中列出的符号连接\n"

#: src/du.c:288
msgid ""
"      --files0-from=F   summarize disk usage of the NUL-terminated file\n"
"                          names specified in file F;\n"
"                          If F is - then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
msgstr ""
"      --files0-from=F\t计算文件F 中以NUL 结尾的文件名对应占用的磁盘空间\n"
"\t\t\t如果F 的值是\"-\"，则从标准输入读入文件名\n"
"  -H\t\t\t等于--dereference-args (-D)\n"
"  -h, --human-readable\t以可读性较好的方式显示尺寸(例如：1K 234M 2G)\n"
"      --si\t\t类似-h，但在计算时使用1000 为基底而非1024\n"

#: src/du.c:297
msgid ""
"  -k                    like --block-size=1K\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""
"  -k\t\t\t等于--block-size=1K\n"
"  -l, --count-links\t如果是硬连接，就多次计算其尺寸\n"
"  -m\t\t\t等于--block-size=1M\n"

#: src/du.c:302
msgid ""
"  -L, --dereference     dereference all symbolic links\n"
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -0, --null            end each output line with 0 byte rather than "
"newline\n"
"  -S, --separate-dirs   do not include size of subdirectories\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -L, --dereference\t找出任何符号链接指示的真正目的地\n"
"  -P, --no-dereference\t不跟随任何符号链接(默认)\n"
"  -0, --null\t\t将每个空行视作0 字节而非换行符\n"
"  -S, --separate-dirs\t不包括子目录的占用量\n"
"  -s, --summarize\t只分别计算命令列中每个参数所占的总用量\n"

#: src/du.c:309
msgid ""
"  -x, --one-file-system    skip directories on different file systems\n"
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -x, --one-file-system\t\t跳过处于不同文件系统之上的目录\n"
"  -X, --exclude-from=文件\t排除与指定文件中描述的模式相符的文件\n"
"      --exclude=PATTERN\t\t排除与PATTERN 中描述的模式相符的文件\n"
"      --max-depth=N\t显示目录总计(与--all 一起使用计算文件)\n"
"\t\t\t当N 为指定数值时计算深度为N；\n"
"\t\t\t--max-depth=0 等于--summarize\n"

#: src/du.c:318
msgid ""
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using style STYLE:\n"
"                          full-iso, long-iso, iso, +FORMAT\n"
"                          FORMAT is interpreted like `date'\n"
msgstr ""
"      --time\t\t显示目录或该目录子目录下所有文件的最后修改时间\n"
"      --time=WORD\t显示WORD 时间，而非修改时间：\n"
"\t\t\tatime，access，use，ctime 或status\n"
"      --time-style=样式\t按照指定样式显示时间(样式解释规则同\"date\"命令)：\n"
"\t\t\tfull-iso，long-iso，iso，+FORMAT\n"

#: src/du.c:587
#, c-format
msgid "fts_read failed: %s"
msgstr "fts_read 失败：%s"

#: src/du.c:711
#, c-format
msgid "invalid maximum depth %s"
msgstr "目录最大深度%s 无效"

#: src/du.c:804
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "不能既显示总用量，同时又显示每个项目"

#: src/du.c:811
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "警告：显示总用量等价于使用--max-depth=0"

#: src/du.c:817
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "警告：显示总用量的选项和--max-depth=%lu 互斥"

#: src/du.c:883 src/sort.c:4467 src/wc.c:669
msgid "file operands cannot be combined with --files0-from"
msgstr "文件操作数不能于--files0-from 参数一起使用"

#: src/du.c:936 src/md5sum.c:570 src/od.c:899 src/tac.c:239 src/tac.c:350
#: src/tac.c:481 src/tac.c:557 src/wc.c:734
#, c-format
msgid "%s: read error"
msgstr "%s：读取出错"

#: src/du.c:950 src/sort.c:4496 src/wc.c:748
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr "当从标准输入读取时，不允许指定文件名%s"

#: src/du.c:967 src/du.c:975 src/wc.c:761 src/wc.c:769
msgid "invalid zero-length file name"
msgstr "无效的零长度文件名"

#: src/du.c:994 src/head.c:150 src/head.c:263 src/head.c:335 src/head.c:539
#: src/head.c:621 src/head.c:693 src/head.c:751 src/head.c:775 src/tail.c:412
#: src/tail.c:500 src/tail.c:549 src/tail.c:642 src/tail.c:770 src/tail.c:818
#: src/tail.c:857 src/tail.c:1781 src/tail.c:1811 src/uniq.c:396
#, c-format
msgid "error reading %s"
msgstr "读取%s 时出错"

#: src/du.c:997 src/ls.c:2609 src/wc.c:792
msgid "total"
msgstr "总用量"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:28
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:43
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"用法：%s [短选项]... [字符串]...\n"
"　或：%s 长选项\n"

#: src/echo.c:47
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"将 STRING 回显到标准输出。\n"
"\n"
"  -n\t\t不尾随换行符\n"

#: src/echo.c:53
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e\t\t启用解释反斜杠的转义功能(默认)\n"
"  -E\t\t禁用解释反斜杠的转义功能\n"

#: src/echo.c:56
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e\t\t启用解释反斜杠的转义功能\n"
"  -E\t\t禁用解释反斜杠的转义功能(默认)\n"

#: src/echo.c:62
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"若-e 可用，则以下序列即可识别：\n"
"\n"

#: src/echo.c:67 src/printf.c:106
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\    反斜杠\n"
"  \\a    响铃声\n"
"  \\b    退格\n"
"  \\c    不再产生新的输出\n"
"  \\e    转义符  \n"
"  \\f    换页\n"
"  \\n    新行\n"
"  \\r    回车\n"
"  \\t    水平制表符\n"
"  \\v    竖直制表符\n"

#: src/echo.c:79
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   字节数以八进制数 NNN (1至3位)表示\n"
"  \\xHH    字节数以十六进制数 HH (1至2位)表示\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:32 src/printenv.c:45 src/whoami.c:36
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:53
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr "用法：%s [选项]... [-] [名称=值]... [命令 [参数]...]\n"

#: src/env.c:56
msgid ""
"Set each NAME to VALUE in the environment and run COMMAND.\n"
"\n"
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with 0 byte rather than newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"设置一个环境变量的\"名称=键值\"并运行命令。\n"
"\n"
"  -i, --ignore-environment      以无定义的环境启动\n"
"  -0, --null                    以空字符而非新行符结束每一输出行\n"
"  -u,  --unset=名称              从当前环境中撤消一个变量\n"

#: src/env.c:65
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"单纯的 - 意味着 -i。如果没有命令，则打印结果环境。\n"

#: src/env.c:121
#, c-format
msgid "cannot unset %s"
msgstr "无法撤消 %s"

#: src/env.c:132
#, c-format
msgid "cannot set %s"
msgstr "无法设定 %s"

#: src/env.c:149
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr "无法以命令指定--null (-0)"

#: src/expand.c:109
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"将每个文件中的制表符转换为空格，写到标准输出。\n"
"如果不指定文件，或者文件为\"-\"，程序将从标准输入读取数据。\n"
"\n"

#: src/expand.c:117
msgid ""
"  -i, --initial       do not convert tabs after non blanks\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""
"  -i, --initial\t\t不转换非空白符后的制表符\n"
"  -t, --tabs=数字\t设置每个制表符为指定数字的宽度，而不是默认的8\n"

#: src/expand.c:121
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr "  -t, --tabs=列表\t指定制表符位置列表，用逗号分隔\n"

#: src/expand.c:174 src/unexpand.c:193
#, c-format
msgid "tab stop is too large %s"
msgstr "%s：制表符跳格量过大"

#: src/expand.c:182 src/unexpand.c:201
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "制表符尺寸中包含无效字符：%s"

#: src/expand.c:208 src/unexpand.c:227
#, c-format
msgid "tab size cannot be 0"
msgstr "制表符尺寸不可为0"

#: src/expand.c:210 src/unexpand.c:229
#, c-format
msgid "tab sizes must be ascending"
msgstr "制表符尺寸必须是升序的"

#: src/expand.c:328 src/expand.c:347 src/unexpand.c:376 src/unexpand.c:421
#, c-format
msgid "input line is too long"
msgstr "输入行太长"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/ln.c:39 src/mv.c:41 src/tee.c:34
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:152 src/groups.c:36
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:204
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 表达式\n"
"　或：%s 选项\n"

#: src/expr.c:212
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"将表达式的值列印到标准输出，分隔符下面的空行可提升算式优先级。\n"
"可用的表达式有：\n"
"\n"
"  ARG1 | ARG2       若ARG1 的值不为0 或者为空，则返回ARG1，否则返回ARG2\n"
"\n"
"  ARG1 & ARG2       若两边的值都不为0 或为空，则返回ARG1，否则返回 0\n"

#: src/expr.c:221
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  ARG1 < ARG2       ARG1 小于ARG2\n"
"  ARG1 <= ARG2      ARG1 小于或等于ARG2\n"
"  ARG1 = ARG2       ARG1 等于ARG2\n"
"  ARG1 != ARG2      ARG1 不等于ARG2\n"
"  ARG1 >= ARG2      ARG1 大于或等于ARG2\n"
"  ARG1 > ARG2       ARG1 大于ARG2\n"

#: src/expr.c:230
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  ARG1 + ARG2       计算 ARG1 与ARG2 相加之和\n"
"  ARG1 - ARG2       计算 ARG1 与ARG2 相减之差\n"

#: src/expr.c:237
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  ARG1 * ARG2       计算 ARG1 与ARG2 相乘之积\n"
"  ARG1 / ARG2       计算 ARG1 与ARG2 相除之商\n"
"  ARG1 % ARG2       计算 ARG1 与ARG2 相除之余数\n"

#: src/expr.c:243
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  字符串 : 表达式\t\t定位字符串中匹配表达式的模式\n"
"\n"
"  match 字符串 表达式\t\t等于\"字符串 :表达式\"\n"
"  substr 字符串 偏移量 长度\t替换字符串的子串，偏移的数值从 1 起计\n"
"  index 字符串 字符\t\t在字符串中发现字符的地方建立下标，或者标0\n"
"  length 字符串\t\t\t字符串的长度\n"

#: src/expr.c:252
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like `match' or an operator like `/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + 记号\t\t\t将记号解析为字符串，即使它是一个类似\"match\"或\n"
"\t\t\t\t运算符\"/\"那样的关键字\n"
"\n"
"  ( 表达式 )\t\t\t表达式的值\n"

#: src/expr.c:258
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"请注意有许多运算操作符都可能需要由 shell 先实施转义。\n"
"如果参与运算的 ARG 自变量都是数字，比较符就会被视作数学符号，否则就是多义"
"的。\n"
"模式匹配会返回\"\\\"和\"\\\"之间被匹配的子字符串或空(null)；如果未使用\"\\"
"\"和\"\\\"，\n"
"则会返回匹配字符数量或是 0。\n"

#: src/expr.c:265
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"若表达式的值既不是空也不是 0，退出状态值为 0；若表达式的值为空或为 0，\n"
"退出状态值为 1。如果表达式的句法无效，则会在出错时返回退出状态值 3。\n"

#: src/expr.c:279
#, c-format
msgid "syntax error"
msgstr "语法错误"

#: src/expr.c:600 src/ptx.c:283
#, c-format
msgid "error in regular expression matcher"
msgstr "正则表达式匹配器出错"

#: src/expr.c:792 src/expr.c:829
#, c-format
msgid "non-integer argument"
msgstr "非整数参数"

#: src/expr.c:794 src/truncate.c:304
#, c-format
msgid "division by zero"
msgstr "除以零"

#: src/expr.c:888 src/sort.c:2014
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "请设置LC_ALL='C' 以避免出现问题。"

#: src/expr.c:890
#, c-format
msgid "the strings compared were %s and %s"
msgstr "已比较的字符串为%s 和%s"

#: src/factor.c:449
msgid "using arbitrary-precision arithmetic"
msgstr "使用任意精度运算"

#: src/factor.c:460
msgid "using single-precision arithmetic"
msgstr "使用单精度运算"

#: src/factor.c:465 src/od.c:1637 src/od.c:1706
#, c-format
msgid "%s is too large"
msgstr "%s 太大"

#: src/factor.c:469
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s 不是有效的正整数"

#: src/factor.c:495
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [数字]...\n"
"　或：%s 选项\n"

#: src/factor.c:500
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr "输出每个指定的数字的素因子，如果没有在命令行中指定则从标准输入读取。\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "无法获得当前目录"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "无法进入目录%s"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "无法获取当前目录的文件状态(stat，当前目录是%s)"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:37
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:270
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "用法：%s [-宽度] [选项]... [文件]...\n"

#: src/fmt.c:271
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
"\n"
msgstr ""
"重新格式化文件中每个段落并输出到标准输出\n"
"选项 \"-宽度\" 是\"--width=数字\" 的缩写。\n"
"\n"

#: src/fmt.c:279
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c --crown-margin\t\t保持前两行的缩进\n"
"  -p, --prefix=字符串\t\t只对以指定字符串开头的行重新格式化，\n"
"\t\t\t\t将前缀重新附着到被重新格式化的行上\n"
"  -s, --split-only\t\t分割过长的行，但不自动补足\n"

#: src/fmt.c:286
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
msgstr ""
"  -t, --tagged-paragraph\t缩进首行以使其不同于第二行\n"
"  -u, --uniform-spacing\t\t每两个单词间保留一个空格，每句之后保留两个空格\n"
"  -w, --width=宽度\t\t最大行宽(默认为75 列宽度)\n"

#: src/fmt.c:355
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr "无效选项 -- %c；宽度必须是第一个选项才能被正确识别；请使用 -w N"

#: src/fmt.c:397
#, c-format
msgid "invalid width: %s"
msgstr "无效的宽度：%s"

#: src/fold.c:71
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
msgstr ""
"对每个指定的文件(默认由标准输入读取)设置自动换行，并将重新排版后的结果输出到"
"标准输出。\n"
"\n"

#: src/fold.c:79
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes\t\t计算字节数而不是列数\n"
"  -s,  --spaces\t\t在空格处断行\n"
"  -w, --width=宽度\t使用指定的列宽度代替默认的80\n"

#: src/fold.c:290 src/pr.c:837
#, c-format
msgid "invalid number of columns: %s"
msgstr "无效的列数：%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:29 src/stdbuf.c:37 src/timeout.c:75 src/truncate.c:37
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "用法：%s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"为Shell 脚本格式输出基于操作平台的限制参数。\n"
"\n"

#: src/group-list.c:67 src/id.c:305 src/setuidgid.c:185
#, c-format
msgid "failed to get groups for user %s"
msgstr "获取用户%s 的属组失败"

#: src/group-list.c:72 src/id.c:310
#, c-format
msgid "failed to get groups for the current process"
msgstr "获取当前进程用户组失败"

#: src/group-list.c:102
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "无法找到ID 为%lu 的用户的属组"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "用法：%s [选项]... [用户名]...\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""
"显示每个输入的用户名所在的全部组，如果没有指定用户名则默认为当前进程用户(当用"
"户组数据库发生变更时可能导致差异)。\n"
"\n"

#: src/groups.c:115 src/id.c:198
#, c-format
msgid "%s: No such user"
msgstr "%s：无此用户"

#: src/head.c:110
msgid ""
"Print the first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"将每个指定文件的头10 行显示到标准输出。\n"
"如果指定了多于一个文件，在每一段输出前会给出文件名作为文件头。\n"
"如果不指定文件，或者文件为\"-\"，则从标准输入读取数据。\n"
"\n"

#: src/head.c:119
msgid ""
"  -c, --bytes=[-]K         print the first K bytes of each file;\n"
"                             with the leading `-', print all but the last\n"
"                             K bytes of each file\n"
"  -n, --lines=[-]K         print the first K lines instead of the first 10;\n"
"                             with the leading `-', print all but the last\n"
"                             K lines of each file\n"
msgstr ""
"  -c,  --bytes=[-]K\t显示每个文件的前K 字节内容；\n"
"\t\t\t如果附加\"-\"参数，则除了每个文件的最后K字节数据外\n"
"\t\t\t显示剩余全部内容\n"
"  -n, --lines=[-]K\t显示每个文件的前K 行内容；\n"
"\t\t\t如果附加\"-\"参数，则除了每个文件的最后K 行外显示\n"
"\t\t\t剩余全部内容\n"

#: src/head.c:127
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent\t不显示包含给定文件名的文件头\n"
"  -v, --verbose\t\t总是显示包含给定文件名的文件头\n"

#: src/head.c:133
msgid ""
"\n"
"K may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
msgstr ""
"\n"
"K 后面可以跟乘号:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, 对于T, P, E, Z, Y 同样适用。\n"

#: src/head.c:153
#, c-format
msgid "error writing %s"
msgstr "写入%s 出错"

#: src/head.c:156
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s：文件被过度收缩"

#: src/head.c:229 src/head.c:1045
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s：字节数过大"

#: src/head.c:442
#, c-format
msgid "%s: cannot lseek back to original position"
msgstr "%s：lseek 无法回溯到初始位置"

#: src/head.c:614 src/head.c:685 src/tail.c:450
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s：无法检索到偏移量%s"

#: src/head.c:792
#, c-format
msgid "cannot reposition file pointer for %s"
msgstr "无法复位%s 的文件指针"

#: src/head.c:879
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s：%s 过大以至于无法表示"

#: src/head.c:880
msgid "number of lines"
msgstr "参数数目错误"

#: src/head.c:880
msgid "number of bytes"
msgstr "字节数"

#: src/head.c:887 src/tail.c:1946
msgid "invalid number of lines"
msgstr "无效的号码%s"

#: src/head.c:888 src/tail.c:1947
msgid "invalid number of bytes"
msgstr "无效的号码%s"

#: src/head.c:975 src/head.c:1033
#, c-format
msgid "invalid trailing option -- %c"
msgstr "无效的加附选项 -- %c"

#: src/hostid.c:43
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"用法：%s [选项]\n"
"显示当前主机的数字标识符(十六进制)。\n"
"\n"

#: src/hostname.c:57
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"用法：%s [名称]\n"
"　或：%s 选项\n"
"显示或设置当前系统的主机名。\n"
"\n"

#: src/hostname.c:95
#, c-format
msgid "cannot set name to %s"
msgstr "无法设置主机名为%s"

#: src/hostname.c:98
#, c-format
msgid "cannot set hostname; this system lacks the functionality"
msgstr "无法设置主机名，此系统似乎不具备此功能"

#: src/hostname.c:106
#, c-format
msgid "cannot determine hostname"
msgstr "无法确定主机名"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:38 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:82
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]\n"
msgstr "用法：%s [选项]... [用户名]\n"

#: src/id.c:83
msgid ""
"Print user and group information for the specified USERNAME,\n"
"or (when USERNAME omitted) for the current user.\n"
"\n"
"  -a              ignore, for compatibility with other versions\n"
"  -Z, --context   print only the security context of the current user\n"
"  -g, --group     print only the effective group ID\n"
"  -G, --groups    print all group IDs\n"
"  -n, --name      print a name instead of a number, for -ugG\n"
"  -r, --real      print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user      print only the effective user ID\n"
msgstr ""
"显示指定用户或当前用户(当未指定用户时)的用户与组信息。\n"
"\n"
"  -a\t\t\t忽略，仅为与其他版本相兼容而设计\n"
"  -Z, --context\t\t仅显示当前用户的安全环境\n"
"  -g, --group\t\t仅显示有效的用户组ID\n"
"  -G, --groups\t\t显示所有组的ID\n"
"  -n, --name\t\t显示组名称而非数字，不与-ugG 一起使用\n"
"  -r, --real\t\t显示真实ID 而非有效ID，与-ugG 一起使用\n"
"  -u, --user\t\t仅显示有效用户ID\n"

#: src/id.c:97
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"如果不附带任何选项，程序会显示一些可供识别用户身份的有用信息。\n"

#: src/id.c:141
#, c-format
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "--context (-Z) 选项只能在开启SELinux 支持的内核上使用"

#: src/id.c:175
#, c-format
msgid "cannot print security context when user specified"
msgstr "不能显示特定用户的安全环境"

#: src/id.c:184
#, c-format
msgid "can't get process context"
msgstr "不能得到进程环境"

#: src/id.c:188
#, c-format
msgid "cannot print \"only\" of more than one choice"
msgstr "有多种选择，无法输出唯一的"

#: src/id.c:192
#, c-format
msgid "cannot print only names or real IDs in default format"
msgstr "以默认格式无法只显示名称或只显示真实ID。"

#: src/id.c:249
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "无法找到ID 为%lu 的用户的名称"

#: src/id.c:269
#, c-format
msgid "uid=%lu"
msgstr "uid=%lu"

#: src/id.c:274
#, c-format
msgid " gid=%lu"
msgstr " gid=%lu"

#: src/id.c:281
#, c-format
msgid " euid=%lu"
msgstr " euid=%lu"

#: src/id.c:289
#, c-format
msgid " egid=%lu"
msgstr " egid=%lu"

#: src/id.c:317
msgid " groups="
msgstr " 组="

#: src/id.c:333
#, c-format
msgid " context=%s"
msgstr " 环境=%s"

#: src/install.c:354
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr "警告：%s：切换到%s 用户环境失败"

#: src/install.c:395
#, c-format
msgid "creating directory %s"
msgstr "正在创建目录%s"

#: src/install.c:463
#, c-format
msgid "cannot change ownership of %s"
msgstr "无法更改%s 的所有权"

#: src/install.c:487
#, c-format
msgid "cannot set time stamps for %s"
msgstr "无法设置%s 的时间戳"

#: src/install.c:508 src/split.c:339 src/timeout.c:385
#, c-format
msgid "fork system call failed"
msgstr "创建系统进程(fork)出错"

#: src/install.c:512
#, c-format
msgid "cannot run %s"
msgstr "无法运行%s"

#: src/install.c:516
#, c-format
msgid "waiting for strip"
msgstr "等待拆解"

#: src/install.c:518
#, c-format
msgid "strip process terminated abnormally"
msgstr "拆解过程非正常中止"

#: src/install.c:539
#, c-format
msgid "invalid user %s"
msgstr "无效的用户%s"

#: src/install.c:576
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"用法：%s [选项]... [-T] 源文件 目标文件\n"
"　或：%s [选项]... 源文件... 目录\n"
"　或：%s [选项]... -t 目录 源文件...\n"
"　或：%s [选项]... -d 目录...\n"

#: src/install.c:583
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
"\n"
msgstr ""
"\n"
"此install 将文件(通常仅是编译后的文件)复制到您所选择的目的位置。\n"
"如果您希望在GNU/Linux 操作系统上下载并安装一个即时可用的软件包，\n"
"您应当使用诸如yum(1) 和apt-get(1) 的软件包管理器。\n"
"\n"
"在前三种形式中，将源文件复制到目标文件或将多个源文件复制到一个已存在的目录\n"
"中同时设置其所有权和权限模式。在第四种形式中，创建给出目标目录中的所有组"
"件。\n"
"\n"

#: src/install.c:598
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=CONTROL]\t为每个已存在的文件创建备份\n"
"  -b\t\t\t类似--backup 但不接受参数\n"
"  -c\t\t\t(忽略)\n"
"  -C, --compare\t\t比较每组源文件和目标文件，在一些情况下不修改目标文件\n"
"  -d, --directory\t将所有参数视为目录名称；为指定的目录创建所有组件\n"

#: src/install.c:607
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D\t\t\t创建目标目录的所有必要的父目录，然后将源文件复制至该目录\n"
"  -g, --group=组\t自行设置所属组，而不是进程目前的所属组\n"
"  -m, --mode=模式\t自行设置权限模式(像chmod)，而不是rwxr-xr-x\n"
"  -o, --owner=所有者\t自行设置所有者(只适用于超级用户)\n"

#: src/install.c:614
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps\t修改源文件的访问/修改时间以与目标文件保持一致\n"
"  -s, --strip\t\t\t拆解符号表\n"
"      --strip-program=程序\t指定拆解二进制文件的程序\n"
"  -S, --suffix=后缀\t\t覆盖常用备份文件后缀\n"
"  -t, --target-directory=目录\t将源文件所有参数复制到指定目录\n"
"  -T, --no-target-directory\t将目标文件视为普通文件\n"
"  -v, --verbose\t\t\t创建目录时显示其名称\n"

#: src/install.c:624
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z, --context=CONTEXT  set SELinux security context of files and "
"directories\n"
msgstr ""
"      --preserve-context\t保持SELinux 的安全环境\n"
"  -Z, --context=CONTEXT\t\t设置文件和目录的SELinux 安全环境\n"

#: src/install.c:841
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr "警告：忽略--preserve-context 参数，当前运行的内核没有启用SELinux 支持"

#: src/install.c:851
#, c-format
msgid "WARNING: ignoring --context (-Z); this kernel is not SELinux-enabled"
msgstr "警告：忽略--context (-Z) 参数，当前运行的内核没有启用SELinux 支持"

#: src/install.c:868
#, c-format
msgid "the strip option may not be used when installing a directory"
msgstr "安装目录时不能用strip 选项"

#: src/install.c:871
#, c-format
msgid "target directory not allowed when installing a directory"
msgstr "安装目录时不能用目标目录选项"

#: src/install.c:875
#, c-format
msgid "cannot force target context to %s and preserve it"
msgstr "无法对%s 强制为目标环境，保持原样"

#: src/install.c:929 src/mkdir.c:203 src/stdbuf.c:328
#, c-format
msgid "invalid mode %s"
msgstr "无效模式%s"

#: src/install.c:936
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr "警告：忽略--strip-program 选项，因为-s 选项没有指明"

#: src/install.c:941
#, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr "选项--compare (-C) 和--preserve-timestamps 是互斥的"

#: src/install.c:948
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "选项--compare (-C) 和--strip 是互斥的"

#: src/install.c:954
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr "当您使用不允许的比特数指定模式是--compare (-C) 选项被忽略"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:40 src/sort.c:67
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:192
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a FILENUM        print unpairable lines coming from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"针对每一对具有相同内容的输入行，整合为一行写到标准输出，\n"
"默认的内容连接区块是由第一个空白符代表的分界符号。当文件1\n"
"或文件2 都被指定为\"-\"时，程序将从标准输入读取数据。\n"
"\n"
"  -a  文件编号    \t文件编号的值可以是1 或2，分别对应文件1 和 文件2。\n"
"                      \t此选项用于根据指定文件编号输出不成对的行目。\n"
"  -e 字符    \t\t将缺失的输入区块替换为指定字符\n"

#: src/join.c:201
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to `-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case \t比较时忽略大小写\n"
"  -j 域 \t\t等于\"-1 域 -2 域\"\n"
"  -o 格式 \t\t按照指定格式构造输出行\n"
"  -t 字符 \t\t使用指定字符作为输入和输出的分隔符\n"

#: src/join.c:207
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
"  --header          treat the first line in each file as field headers,\n"
"                      print them without trying to pair them\n"
msgstr ""
"  -v 文件编号        \t类似 -a 文件编号，但禁止组合输出行\n"
"  -1 域          \t在文件1 的此域组合\n"
"  -2 域          \t在文件2 的此域组合\n"
"  --check-order     \t检查输入行是否正确排序，即使所有输入行均是成对的\n"
"  --nocheck-order   \t不检查输入是否正确排序\n"
"  --header          \t将首行视作域的头部，直接输出而不对其进行匹配\n"

#: src/join.c:219
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `FILENUM.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use ` sort -k 1b,1 ' if `join' has no options,\n"
"or use ` join -t '' ' if `sort' has no options.\n"
"Note, comparisons honor the rules specified by `LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"除非使用了\"-t 字符串\" 选项，否则前导空格分隔的域将被忽略，如果指定了字符"
"串，\n"
"则使用指定字符串分隔任意的域并从1 开始计数的域编号。可以指定的格式是由一个\n"
"或多个逗号活空格所分隔的描述，其形式为\"文件编号.域\"或者\"0\"。默认的\n"
"格式输出合并后的域、文件1 和文件2 剩下的域，均由该指定字符串分隔。\n"
"\n"
"重要提示：文件1 和文件2 必须在合并域中排序。\n"
"例如，如果\"join\"后没有选项，使用\"sort -k 1b,1\"。\n"
"注意，所进行的比较遵从\"LC_COLLATE\"所指定的的规则。\n"
"如果输入没有被排序并导致某些行无法合并，将会显示警告信息。\n"

#: src/join.c:404
#, c-format
msgid "%s:%ju: is not sorted: %.*s"
msgstr ""

#: src/join.c:841 src/join.c:1039
#, c-format
msgid "invalid field number: %s"
msgstr "无效的区块编号%s"

#: src/join.c:862 src/join.c:871
#, c-format
msgid "invalid field specifier: %s"
msgstr "无效的区块定义符：%s"

#: src/join.c:878
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "在区块定义中出现无效的文件编号：%s"

#: src/join.c:921
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "不兼容的连接区块%lu，%lu"

#: src/join.c:1050
#, c-format
msgid "conflicting empty-field replacement strings"
msgstr "有冲突的空区块替换字符串"

#: src/join.c:1102 src/sort.c:4402
#, c-format
msgid "multi-character tab %s"
msgstr "多字符标签%s"

#: src/join.c:1106 src/sort.c:4407
#, c-format
msgid "incompatible tabs"
msgstr "不兼容的标签"

#: src/join.c:1175
#, c-format
msgid "both files cannot be standard input"
msgstr "不能从标准输入同时读取两个文件"

#: src/kill.c:77
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"用法：%s [-s 信号 | -信号] 进程号...\n"
"　或：%s -l [信号]...\n"
"　或：%s -t [信号]...\n"

#: src/kill.c:83
msgid ""
"Send signals to processes, or list signals.\n"
"\n"
msgstr ""
"向进程发送信号，或是列出可用信号。\n"
"\n"

#: src/kill.c:90
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=信号，-信号\n"
"                   \t指定要发送的信号名或信号代码。\n"
"  -l, --list    \t列出可用的信号名称，同时提供信号名与信号代码的对照\n"
"  -t, --table    \t显示一个有关信号具体信息的表格。\n"

#: src/kill.c:98
msgid ""
"\n"
"SIGNAL may be a signal name like `HUP', or a signal number like `1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"参数中的信号可以是类似\"HUP\"的信号名称，也可以是如\"1\"这样的信号编码，或者"
"进程被\n"
"信号终止后的退出状态号。\n"
"进程号(PID) 是一个整数，如果为负数则表示一个进程组。\n"

#: src/kill.c:207
#, c-format
msgid "%s: invalid process id"
msgstr "%s：无效的进程号"

#: src/kill.c:261
#, c-format
msgid "invalid option -- %c"
msgstr "无效的选项 -- %c"

#: src/kill.c:270
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s：同时指定了多个信号"

#: src/kill.c:284
#, c-format
msgid "multiple -l or -t options specified"
msgstr "同时指定了多个-l 或-t 选项"

#: src/kill.c:301
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "无法将-l 或-t 选项结合使用"

#: src/kill.c:307
#, c-format
msgid "no process ID specified"
msgstr "未指定进程号"

#: src/libstdbuf.c:109
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "分配 %<PRIuMAX> 字节标准输入输出(stdio)缓冲区失败\n"

#: src/libstdbuf.c:116
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "%2$s 的缓冲模式%1$s 无效\n"

#: src/libstdbuf.c:124
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "无法将%2$s 的缓冲模式设置为%1$s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:36 src/unlink.c:36 src/who.c:50
msgid "Michael Stone"
msgstr "Michael Ston"

#: src/link.c:46
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 文件1 文件2\n"
"　或：%s 选项\n"

#: src/link.c:49
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"调用 link 函数创建从既存的文件1 到文件2 的链接。\n"
"\n"

#: src/link.c:91
#, c-format
msgid "cannot create link %s to %s"
msgstr "无法创建指向%2$s 的链接%1$s"

#: src/ln.c:156
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: 不允许将硬链接指向目录"

#: src/ln.c:221
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s：无法覆盖目录"

#: src/ln.c:226
#, c-format
msgid "%s: replace %s? "
msgstr "%s：是否替换%s？ "

#: src/ln.c:307
#, c-format
msgid "failed to create symbolic link %s"
msgstr "无法创建符号链接%s"

#: src/ln.c:308
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "无法创建符号链接%s -> %s"

#: src/ln.c:310
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "无法创建硬链接%.0s%s"

#: src/ln.c:313
#, c-format
msgid "failed to create hard link %s"
msgstr "无法创建硬链接%s"

#: src/ln.c:314
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "无法创建硬链接%s => %s"

#: src/ln.c:336
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME   (1st form)\n"
"  or:  %s [OPTION]... TARGET                  (2nd form)\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY     (3rd form)\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...  (4th form)\n"
msgstr ""
"用法：%s [选项]... [-T] 目标 链接名\t(第一种格式)\n"
"　或：%s [选项]... 目标\t\t(第二种格式)\n"
"　或：%s [选项]... 目标... 目录\t(第三种格式)\n"
"　或：%s [选项]... -t 目录 目标...\t(第四种格式)\n"

#: src/ln.c:343
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
"\n"
msgstr ""
"在第一种格式中，创建指定名称且指向指定目标链接。\n"
"在第二种格式中，在当前目录创建指向目标位置的链接。\n"
"在第三、四种格式中，在指定目录中创建指向指定目标的链接。\n"
"默认创建硬链接，当使用--symbolic 时创建符号链接。\n"
"当创建硬链接时每个指定的目标都必须存在。符号链接可以指向任意的位置，\n"
"当链接解析正常时，将其解析为一个与其父目录关联的链接。\n"
"\n"

#: src/ln.c:356
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=CONTROL]\t为每个已存在的目标文件创建备份文件\n"
"  -b\t\t\t\t类似--backup，但不接受任何参数\n"
"  -d, -F, --directory\t\t创建指向目录的硬链接(只适用于超级用户)\n"
"  -f, --force\t\t\t强行删除任何已存在的目标文件\n"

#: src/ln.c:364
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               make hard links to symbolic link references\n"
"  -n, --no-dereference        treat destination that is a symlink to a\n"
"                                directory as if it were a normal file\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -i, --interactive\t\t删除文件前进行确认\n"
"  -L, --logical\t\t将硬链接创建为符号链接引用\n"
"  -n, --no-dereference\t\t如果目的地是一个链接至某目录的符号链接，会将\n"
"\t\t\t\t该符号链接当作普通文件处理，先将该已存在的链\n"
"\t\t\t\t接备份或删除\n"
"  -s, --symbolic\t\t创建符号链接而非硬链接\n"

#: src/ln.c:372
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=后缀\t\t自行指定备份文件的后缀\n"
"  -t, --target-directory=目录\t在指定目录中创建链接\n"
"  -T, --no-target-directory\t将链接名称当作普通文件\n"
"  -v, --verbose\t\t链接前先列出每个文件的名称\n"

#: src/ln.c:388
#, c-format
msgid ""
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when the source is a symbolic link, defaulting to %s.\n"
"\n"
msgstr ""
"使用 -s 选项会忽略 -L 和 -P。\n"
"否则当源为一个符号链接(默认%s)时，会由最后指定的一个选项来控制行为。\n"
"\n"

#: src/ln.c:511
#, c-format
msgid "cannot combine --target-directory and --no-target-directory"
msgstr "无法同时使用 --target-directory 和 --no-target-directory"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:30
msgid "FIXME: unknown"
msgstr "FIXME：未知"

#: src/logname.c:40 src/sync.c:41
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "用法：%s [选项]\n"

#: src/logname.c:41
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"显示当前用户的名称。\n"
"\n"

#: src/logname.c:85
#, c-format
msgid "no login name"
msgstr "无登录名"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:733
msgid "%b %e  %Y"
msgstr "%b %e %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:746
msgid "%b %e %H:%M"
msgstr "%b %e %H:%M"

#: src/ls.c:1580
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr "忽略无效的环境变量QUOTING_STYLE 的键值：%s"

#: src/ls.c:1607
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr "忽略无效的环境变量 COLUMNS 所示的宽度值：%s"

#: src/ls.c:1637
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr "忽略无效的环境变量 TABSIZE 所示的制表符尺寸值：%s"

#: src/ls.c:1758 src/ptx.c:1977
#, c-format
msgid "invalid line width: %s"
msgstr "无效的行宽：%s"

#: src/ls.c:1832
#, c-format
msgid "invalid tab size: %s"
msgstr "无效的制表符尺寸：%s"

#: src/ls.c:2022
#, c-format
msgid "invalid time style format %s"
msgstr "无效的日期时间格式%s"

#: src/ls.c:2061
#, c-format
msgid "error initializing month strings"
msgstr "初始化月份字符串出错"

#: src/ls.c:2372
#, c-format
msgid "unrecognized prefix: %s"
msgstr "无法识别的前缀：%s"

#: src/ls.c:2402
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "LS_COLORS 环境变量中存在无法解些的值"

#: src/ls.c:2479 src/pwd.c:162
#, c-format
msgid "cannot open directory %s"
msgstr "无法打开目录%s"

#: src/ls.c:2494
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "无法决定%s 所在的设备及inode"

#: src/ls.c:2503
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s：不会再列出已经列出的目录"

#: src/ls.c:2580 src/pwd.c:230
#, c-format
msgid "reading directory %s"
msgstr "正在读取目录%s"

#: src/ls.c:2590
#, c-format
msgid "closing directory %s"
msgstr "关闭目录%s"

#: src/ls.c:3182
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "无法比较文件名%s 和 %s"

#: src/ls.c:4597
#, fuzzy
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
"\n"
msgstr ""
"列出 FILE 的信息(默认为当前目录)。\n"
"如果不指定-cftuvSUX 或--sort 选项，则根据字母大小排序。\n"
"\n"

#: src/ls.c:4605
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all\t\t\t不隐藏任何以. 开始的项目\n"
"  -A, --almost-all\t\t列出除. 及.. 以外的任何项目\n"
"      --author\t\t\t与-l 同时使用时列出每个文件的作者\n"
"  -b, --escape\t\t\t以八进制溢出序列表示不可打印的字符\n"

#: src/ls.c:4611
#, fuzzy
msgid ""
"      --block-size=SIZE      scale sizes by SIZE before printing them.  E."
"g.,\n"
"                               `--block-size=M' prints sizes in units of\n"
"                               1,048,576 bytes.  See SIZE format below.\n"
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information)\n"
"                               with -l: show ctime and sort by name\n"
"                               otherwise: sort by ctime, newest first\n"
msgstr ""
"      --block-size=大小\t\t块以指定大小的字节为单位。例如\n"
"\t\t\t\t--block-size=M 以 1,048,576 字节为单位\t\t\t\t显示大小。参看SIZE 格"
"式。  -B, --ignore-backups\t\t不列出任何以\"~\"字符结束的项目\n"
"  -c\t\t\t\t配合-lt：根据ctime 排序并显示ctime(文件\n"
"\t\t\t\t状态最后更改的时间)\n"
"\t\t\t\t配合-l：显示ctime 但根据名称排序\t\t\t\t其他情况：按ctime 排序\n"

#: src/ls.c:4621
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output.  WHEN defaults to "
"`always'\n"
"                               or can be `never' or `auto'.  More info "
"below\n"
"  -d, --directory            list directory entries instead of contents,\n"
"                               and do not dereference symbolic links\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C\t\t\t\t每栏由上至下列出项目\n"
"      --color[=WHEN]\t\t控制是否使用色彩分辨文件。WHEN 可以是\n"
"\t\t\t\t\"never\"(默认)、\"always\"或\"auto\"其中之一\n"
"  -d, --directory\t\t当遇到目录时列出目录本身而非目录内的文件\n"
"  -D, --dired\t\t\t产生适合Emacs 的dired 模式使用的结果\n"

#: src/ls.c:4629
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append `*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f\t\t\t\t不进行排序，-aU 选项生效，-lst 选项失效\n"
"  -F, --classify\t\t加上文件类型的指示符号(*/=@| 其中一个)\n"
"      --format=关键字\t\t交错-x，逗号分隔-m，水平-x，长-l，\n"
"\t\t\t\t单栏-1，详细-l，垂直-C\n"
"      --full-time\t\t即-l --time-style=full-iso\n"

#: src/ls.c:4637
msgid "  -g                         like -l, but do not list owner\n"
msgstr "  -g\t\t\t\t类似-l，但不列出所有者\n"

#: src/ls.c:4640
msgid ""
"      --group-directories-first\n"
"                             group directories before files.\n"
"                               augment with a --sort option, but any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""
"      --group-directories-first\n"
"\t\t\t在文件前分组目录。此选项可与--sort 一起使用，\n"
"\t\t\t但是一旦使用--sort=none (-U)将禁用分组\n"

#: src/ls.c:4646
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
"  -h, --human-readable       with -l, print sizes in human readable format\n"
"                               (e.g., 1K 234M 2G)\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -G, --no-group\t\t以一个长列表的形式，不输出组名\n"
"  -h, --human-readable\t\t与-l 一起，以易于阅读的格式输出文件大小\n"
"\t\t\t\t(例如 1K 234M 2G)\n"
"      --si\t\t\t同上面类似，但是使用1000 为基底而非1024\n"

#: src/ls.c:4652
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                             that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""
"  -H, --dereference-command-line\n"
"\t\t\t\t跟随命令行列出的符号链接\n"
"      --dereference-command-line-symlink-to-dir\n"
"\t\t\t\t跟随命令行列出的目录的符号链接\n"
"      --hide=PATTERN         \t隐藏符合PATTERN 模式的项目\n"
"\t\t\t\t(-a 或 -A 将覆盖此选项)\n"

#: src/ls.c:4662
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
"  -k                         like --block-size=1K\n"
msgstr ""
"      --indicator-style=方式\t指定在每个项目名称后加上指示符号方式：\n"
"\t\t\t\tnone (默认)，classify (-F)，file-type (-p)\n"
"  -i, --inode\t\t\t显示每个文件的inode 号\n"
"  -I, --ignore=PATTERN\t\t不显示任何符合指定shell PATTERN 的项目\n"
"  -k\t\t\t\t即--block-size=1K\n"

#: src/ls.c:4672
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l\t\t\t\t使用较长格式列出信息\n"
"  -L, --dereference\t\t当显示符号链接的文件信息时，显示符号链接所指示\n"
"\t\t\t\t的对象而并非符号链接本身的信息\n"
"  -m\t\t\t\t所有项目以逗号分隔，并填满整行行宽\n"

#: src/ls.c:4680
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print raw entry names (don't treat e.g. "
"control\n"
"                               characters specially)\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid\t\t类似 -l，但列出UID 及GID 号\n"
"  -N, --literal\t\t\t输出未经处理的项目名称 (如不特别处理控制字符)\n"
"  -o\t\t\t\t类似 -l，但不列出有关组的信息\n"
"  -p,  --indicator-style=slash\t对目录加上表示符号\"/\"\n"

#: src/ls.c:4688
msgid ""
"  -q, --hide-control-chars   print ? instead of non graphic characters\n"
"      --show-control-chars   show non graphic characters as-is (default\n"
"                             unless program is `ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always, c, "
"escape\n"
msgstr ""
"  -q, --hide-control-chars\t以\"?\"字符代替无法打印的字符\n"
"      --show-control-chars\t直接显示无法打印的字符 (这是默认方式，除非调用\n"
"\t\t\t\t的程序名称是\"ls\"而且是在终端输出结果)\n"
"  -Q, --quote-name\t\t将条目名称括上双引号\n"
"      --quoting-style=方式\t使用指定的quoting 方式显示条目的名称：\n"
"\t\t\t\tliteral、locale、shell、shell-always、c、escape\n"

#: src/ls.c:4697
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse\t\t\t逆序排列\n"
"  -R, --recursive\t\t递归显示子目录\n"
"  -s, --size\t\t\t以块数形式显示每个文件分配的尺寸\n"

#: src/ls.c:4702
msgid ""
"  -S                         sort by file size\n"
"      --sort=WORD            sort by WORD instead of name: none -U,\n"
"                             extension -X, size -S, time -t, version -v\n"
"      --time=WORD            with -l, show time as WORD instead of "
"modification\n"
"                             time: atime -u, access -u, use -u, ctime -c,\n"
"                             or status -c; use specified time as sort key\n"
"                             if --sort=time\n"
msgstr ""
"  -S\t\t\t\t根据文件大小排序\n"
"      --sort=WORD\t\t以下是可选用的WORD 和它们代表的相应选项：\n"
"\t\t\t\textension -X       status   -c\n"
"\t\t\t\tnone      -U       time     -t\n"
"\t\t\t\tsize      -S       atime    -u\n"
"\t\t\t\ttime      -t       access   -u\n"
"\t\t\t\tversion   -v       use      -u\n"
"      --time=WORD\t\t和-l 同时使用时显示WORD 所代表的时间而非修改时\n"
"\t\t\t\t间：atime、access、use、ctime 或status；加上\n"
"\t\t\t\t--sort=time 选项时会以指定时间作为排序关键字\n"

#: src/ls.c:4712
msgid ""
"      --time-style=STYLE     with -l, show times using style STYLE:\n"
"                             full-iso, long-iso, iso, locale, +FORMAT.\n"
"                             FORMAT is interpreted like `date'; if FORMAT "
"is\n"
"                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n"
"                             non-recent files and FORMAT2 to recent files;\n"
"                             if STYLE is prefixed with `posix-', STYLE\n"
"                             takes effect only outside the POSIX locale\n"
msgstr ""
"      --time-style=STYLE\t和-l 同时使用时根据STYLE 代表的格式显示时间：\n"
"\t\t\t\tfull-iso、iso、locale、posix-iso、+FORMAT。\n"
"\t\t\t\tFORMAT 即是\"date\"所用的时间格式；如果FORMAT\n"
"\t\t\t\t是FORMAT1<换行>FORMAT2，FORMAT1 适用于较旧\n"
"\t\t\t\t的文件而FORMAT2 适用于较新的文件；如果STYLE\n"
"\t\t\t\t以\"posix-\"开头，则STYLE 仅在POSIX 语系之外\n"
"\t\t\t\t生效。\n"
"  -t\t\t\t\t根据修改时间排序\n"
"  -T, --tabsize=宽度\t指定制表符(Tab)的宽度，而非8 个字符\n"

#: src/ls.c:4721
#, fuzzy
msgid ""
"  -t                         sort by modification time, newest first\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t\t\t\t按修改时间排序\n"
"  -T, --tabsize=COLS\t指定制表符(Tab)的宽度，而非8个字符\n"

#: src/ls.c:4725
msgid ""
"  -u                         with -lt: sort by, and show, access time\n"
"                               with -l: show access time and sort by name\n"
"                               otherwise: sort by access time\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -u\t\t\t同-lt 一起使用：按照访问时间排序并显示\n"
"\t\t\t同-l一起使用：显示访问时间并按文件名排序\n"
"\t\t\t其他：按照访问时间排序\n"
"  -U\t\t\t不进行排序；按照目录顺序列出项目\n"
"  -v\t\t\t在文本中进行数字(版本)的自然排序\n"

#: src/ls.c:4732
msgid ""
"  -w, --width=COLS           assume screen width instead of current value\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any SELinux security context of each "
"file\n"
"  -1                         list one file per line\n"
msgstr ""
"  -w, --width=COLS\t自行指定萤幕宽度而不使用目前的数值\n"
"  -x\t\t\t逐行列出项目而不是逐栏列出\n"
"  -X\t\t\t根据扩展名排序\n"
"  -1\t\t\t每行只列出一个文件\n"

#: src/ls.c:4742
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"使用色彩来区分文件类型的功能已被禁用，默认设置和 --color=never 同时禁用了"
"它。\n"
"使用 --color=auto 选项，ls 只在标准输出被连至终端时才生成颜色代码。\n"
"LS_COLORS 环境变量可改变此设置，可使用 dircolors 命令来设置。\n"
"\n"

#: src/ls.c:4749
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"退出状态：\n"
" 0  正常\n"
" 1  一般问题 (例如：无法访问子文件夹)\n"
" 2  严重问题 (例如：无法使用命令行参数)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:94 src/seq.c:39
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:95
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:96
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:160
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"显示或检查 %s(%d-bit) 校验和。\n"
"若没有文件选项，或者文件处为\"-\"，则从标准输入读取。\n"
"\n"

#: src/md5sum.c:170
msgid ""
"  -b, --binary         read in binary mode (default unless reading tty "
"stdin)\n"
msgstr "  -b, --binary\t\t以二进制模式读取(除非从tty 标准输入读取否则为默认)\n"

#: src/md5sum.c:174
msgid "  -b, --binary         read in binary mode\n"
msgstr "  -b, --binary\t\t以二进制模式读取\n"

#: src/md5sum.c:177
#, c-format
msgid "  -c, --check          read %s sums from the FILEs and check them\n"
msgstr "  -c, --check\t\t从文件中读取%s 的校验值并予以检查\n"

#: src/md5sum.c:181
msgid ""
"  -t, --text           read in text mode (default if reading tty stdin)\n"
msgstr "  -t, --text\t\t以纯文本模式读取(从tty 标准输入读取时为默认)\n"

#: src/md5sum.c:185
msgid "  -t, --text           read in text mode (default)\n"
msgstr "  -t, --text\t\t以纯文本模式读取(默认)\n"

#: src/md5sum.c:188
msgid ""
"\n"
"The following three options are useful only when verifying checksums:\n"
"      --quiet          don't print OK for each successfully verified file\n"
"      --status         don't output anything, status code shows success\n"
"  -w, --warn           warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"以下三个选项在进行校验时非常有用：\n"
"      --quiet\t\t不为校验成功的文件输出OK\n"
"      --status\t\t不输出任何内容，使用退出状态号显示成功\n"
"  -w, --warn\t\t对格式不准确的校验和行进行警告\n"
"\n"

#: src/md5sum.c:196
msgid ""
"      --strict         with --check, exit non-zero for any invalid input\n"
msgstr ""

#: src/md5sum.c:201
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""
"\n"
"校验和会按照%s 规范生成。当进行检查时，给出的输入格式应该和程序的输出\n"
"样板格式相同。默认的输出模式时输出一行校验和的校验结果，并有一个字符来\n"
"表示文件类型(\"*\"代表二进制，\" \"代表纯文本)，并同时显示每个文件的名称。\n"

#: src/md5sum.c:485
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s：校验和的行数过多"

#: src/md5sum.c:509
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s：%<PRIuMAX>：%s 的校验和行目格式不适当"

#: src/md5sum.c:534
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s：打开或读取失败\n"

#: src/md5sum.c:557
msgid "FAILED"
msgstr "失败"

#: src/md5sum.c:559
msgid "OK"
msgstr "确定"

#: src/md5sum.c:583
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s：找不到格式适用的%s 校验和"

#: src/md5sum.c:593
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] "警告：%<PRIuMAX> 行的格式不适当"

#: src/md5sum.c:601
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "警告：%<PRIuMAX> 个列出的文件无法读取"

#: src/md5sum.c:609
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "警告：%<PRIuMAX> 个校验和不匹配"

#: src/md5sum.c:687
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "在校验时--binary 和--text 选项是无意义的"

#: src/md5sum.c:695
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "只有在校验时--status 选项才有意义"

#: src/md5sum.c:702
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "只有在校验时--warn 选项才有意义"

#: src/md5sum.c:709
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "只有在校验时--quiet 选项才有意义"

#: src/md5sum.c:716
#, fuzzy, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr "只有在校验时--status 选项才有意义"

#: src/mkdir.c:57 src/rmdir.c:165
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "用法：%s [选项]... 目录...\n"

#: src/mkdir.c:58
msgid ""
"Create the DIRECTORY(ies), if they do not already exist.\n"
"\n"
msgstr ""
"若指定目录不存在则创建目录。\n"
"\n"

#: src/mkdir.c:65
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
"  -Z, --context=CTX  set the SELinux security context of each created\n"
"                      directory to CTX\n"
msgstr ""
"  -m, --mode=模式   \t设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask\n"
"  -p, --parents     \t需要时创建目标目录的上层目录，但即使这些目录已存在也不"
"当作错误处理\n"
"  -v, --verbose     \t每次创建新目录都显示信息\n"
"  -Z, --context=CTX  \t将每个创建的目录的SELinux 安全环境设置为CTX\n"

#: src/mkdir.c:170
#, c-format
msgid "created directory %s"
msgstr "已创建目录 %s"

#: src/mkfifo.c:52 src/pathchk.c:90
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "用法：%s [选项]... 名称...\n"

#: src/mkfifo.c:53
msgid ""
"Create named pipes (FIFOs) with the given NAMEs.\n"
"\n"
msgstr ""
"以指定的名称创建先进先出文件(FIFO)。\n"
"\n"

#: src/mkfifo.c:60 src/mknod.c:62
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=模式   \t设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask\n"

#: src/mkfifo.c:63
msgid ""
"  -Z, --context=CTX  set the SELinux security context of each NAME to CTX\n"
msgstr "  -Z, --context=CTX  \t将每个创建的目录的SELinux 安全环境设置为CTX\n"

#: src/mkfifo.c:123 src/mknod.c:129
#, c-format
msgid "invalid mode"
msgstr "无效的权限模式"

#: src/mkfifo.c:128 src/mknod.c:134
#, c-format
msgid "mode must specify only file permission bits"
msgstr "模式必须只指定文件许可位"

#: src/mknod.c:53
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "用法：%s [选项]... 名称 类型 [主设备号 次设备号]\n"

#: src/mknod.c:55
msgid ""
"Create the special file NAME of the given TYPE.\n"
"\n"
msgstr ""
"创建指定类型和名称的特殊文件。\n"
"\n"

#: src/mknod.c:65
msgid "  -Z, --context=CTX  set the SELinux security context of NAME to CTX\n"
msgstr "  -Z, --context=CTX \t将对应名称文件的SELinux 安全环境设置为CTX\n"

#: src/mknod.c:70
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"当类型为\"p\"时可不指定主设备号和次设备号，否则它们是必须指定的。\n"
"如果主设备号和次设备号以\"0x\"或\"0X\"开头，它们会被视作十六进制数来\n"
"解析；如果以\"0\"开头，则被视作八进制数；其余情况下被视作十进制数。\n"
"可用的类型包括：\n"

#: src/mknod.c:77
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      创建(有缓冲的)区块特殊文件\n"
"  c, u   创建(没有缓冲的)字符特殊文件\n"
"  p      创建先进先出(FIFO)特殊文件\n"

#: src/mknod.c:152
msgid "Special files require major and minor device numbers."
msgstr "创建块设备文件时，必需指定主、次设备号。"

#: src/mknod.c:162
msgid "Fifos do not have major and minor device numbers."
msgstr "先进先出(FIFO)文件不需要指定主、次设备号。"

#: src/mknod.c:178
#, c-format
msgid "block special files not supported"
msgstr "不支持区块特殊文件"

#: src/mknod.c:187
#, c-format
msgid "character special files not supported"
msgstr "不支持字符特殊文件"

#: src/mknod.c:203
#, c-format
msgid "invalid major device number %s"
msgstr "无效的主设备号 %s"

#: src/mknod.c:208
#, c-format
msgid "invalid minor device number %s"
msgstr "无效的次设备号 %s"

#: src/mknod.c:213
#, c-format
msgid "invalid device %s %s"
msgstr "无效的设备文件%s %s"

#: src/mknod.c:227
#, c-format
msgid "invalid device type %s"
msgstr "无效的设备类型 %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:69
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "用法：%s [选项]... [TEMPLATE]\n"

#: src/mktemp.c:70
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive `X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""
"安全地创建一个临时文件或目录，并且打输出它的名字。\n"
"TEMPLATE 最后部分必须含有至少 3 个连续的 X。\n"
"如果 TEMPLATE 没有指定，将会使用 tmp.XXXXXXXXXX。\n"

#: src/mktemp.c:75
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr ""

#: src/mktemp.c:79
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""
"  -d, --directory     创建一个目录而非文件\n"
"  -u, --dry-run       不创建任何东西，仅打印出名字。(仅供测试)\n"
"  -q, --quiet         不显示任何有关文件或目录创建错误信息\n"

#: src/mktemp.c:84
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE.  SUFF must not contain "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X.\n"
msgstr ""
"      --suffix=SUFF   将 SUFF 添加至 TEMPLATE。SUFF 不能带斜杠。\n"
"                        若 TEMPLATE 不以 X 结尾，则此选项隐式实现。\n"

#: src/mktemp.c:88
msgid ""
"      --tmpdir[=DIR]  interpret TEMPLATE relative to DIR.  If DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name.\n"
"                        Unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""
"  --tmpdir[=DIR]        将TEMPLATE 和DIR 目录关联。如果DIR 没有被指定，则\n"
"                        根据$TMPDIR 是否被设置来选择是$TMPDIR 还是 /tmp。\n"
"                        在这个选项中，TEMPLATE 不能是绝对路径。\n"
"                        与-t 不同，TEMPLATE 允许带斜线。\n"
"                        但此种情况下mktemp 仅以斜线后部分生成目录。\n"

#: src/mktemp.c:96
msgid ""
"  -p DIR              use DIR as a prefix; implies -t [deprecated]\n"
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""
"  -p DIR                使用 DIR 作为目录名；隐式实现 -t(已废除)\n"
"  -t\t\t\t把 TEMPLATE 相对于目录$TMPDIR 作为单独的文件名\n"
"\t\t\t(如果设置了该参数的话)；此目录也可以通过-p 指定；还可\n"
"\t\t\t以通过/tmp指定[不推荐]\n"

#: src/mktemp.c:223
#, c-format
msgid "failed to redirect stderr to /dev/null"
msgstr "重定向标准错误到/dev/null 失败"

#: src/mktemp.c:229
#, c-format
msgid "too many templates"
msgstr "模板过多"

#: src/mktemp.c:249
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr "使用 --suffix，模板 %s 必须以 X 结尾"

#: src/mktemp.c:274
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "无效后缀 %s，含有目录分隔符"

#: src/mktemp.c:279
#, c-format
msgid "too few X's in template %s"
msgstr "模板%s 中X 太少"

#: src/mktemp.c:292
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "无效模板，%s，包含目录分隔符"

#: src/mktemp.c:306
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr "无效模板，%s；如果与--tmpdir 同时使用则不可以是绝对路径"

#: src/mktemp.c:326
#, c-format
msgid "failed to create directory via template %s"
msgstr "无法通过模板%s 创建目录"

#: src/mktemp.c:336
#, c-format
msgid "failed to create file via template %s"
msgstr "无法通过模板%s 创建文件"

#: src/mv.c:291
msgid ""
"Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
"\n"
msgstr ""
"将源文件重命名为目标文件，或将源文件移动至指定目录。\n"
"\n"

#: src/mv.c:298
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=CONTROL]       为每个已存在的目标文件创建备份\n"
"  -b                           类似--backup 但不接受参数\n"
"  -f, --force                  覆盖前不询问\n"
"  -i, --interactive            覆盖前询问\n"
"  -n, --no-clobber             不覆盖已存在文件\n"
"如果您指定了-i、-f、-n 中的多个，仅最后一个生效。\n"

#: src/mv.c:307
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes\t去掉每个源文件参数尾部的斜线\n"
"  -S, --suffix=SUFFIX\t\t替换常用的备份文件后缀\n"

#: src/mv.c:312
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
msgstr ""
"  -t, --target-directory=DIRECTORY\t将所有参数指定的源文件或目录\n"
"\t\t\t\t\t移动至 指定目录\n"
"  -T, --no-target-directory\t将目标文件视作普通文件处理\n"
"  -u, --update\t\t\t只在源文件文件比目标文件新，或目标文件\n"
"\t\t\t\t不存在时才进行移动\n"
"  -v, --verbose\t\t详细显示进行的步骤\n"

#: src/nice.c:73
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "用法：%s [选项] [命令 [参数]...]\n"

#: src/nice.c:74
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Nicenesses range from\n"
"%d (most favorable scheduling) to %d (least favorable).\n"
"\n"
"  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""
"以指定的优先级运行命令，这会影响相应进程的调度。\n"
"如果不指定命令，程序会显示当前的优先级。优先级的范围是从 %d\n"
"(最大优先级) 到 %d (最小优先级)。\n"
"\n"
"  -n, --adjustment=N    对优先级数值加上指定整数N (默认为10)\n"

#: src/nice.c:169
#, c-format
msgid "invalid adjustment %s"
msgstr "无效的调整值%s"

#: src/nice.c:178
#, c-format
msgid "a command must be given with an adjustment"
msgstr "命令必须和调整值配合指定"

#: src/nice.c:185 src/nice.c:196
#, c-format
msgid "cannot get niceness"
msgstr "无法获取优先级"

#: src/nice.c:202
#, c-format
msgid "cannot set niceness"
msgstr "无法设置优先级"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:40
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:187
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"将指定的各个文件添加行号标注后写到标准输出。\n"
"如果不指定文件或指定文件为\"-\" ，程序将从标准输入读取数据。\n"
"\n"

#: src/nl.c:195
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=样式\t使用指定样式编号文件的正文行目\n"
"  -d, --section-delimiter=CC\t使用指定的CC 分割逻辑页数\n"
"  -f, --footer-numbering=样式\t使用指定样式编号文件的页脚行目\n"

#: src/nl.c:200
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=样式\t使用指定样式编号文件的页眉行目\n"
"  -i, --page-increment=数值\t设置每一行遍历后的自动递增值\n"
"  -l, --join-blank-lines=数值\t设置数值为多少的若干空行被视作一行\n"
"  -n, --number-format=格式\t根据指定格式插入行号\n"
"  -p, --no-renumber\t\t在逻辑页数切换时不将行号值复位\n"
"  -s, --number-separator=字符串\t可能的话在行号后添加字符串\n"

#: src/nl.c:208
msgid ""
"  -v, --starting-line-number=NUMBER  first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=数字\t每个逻辑页上的第一行的行号\n"
"  -w, --number-width=数字\t为行号使用指定的栏数\n"

#: src/nl.c:214
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""
"\n"
"默认的选项设置是-v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn。CC 是用于分隔\n"
"逻辑页数的两个分界符，其中缺失的第二个字符暗含了\":\"，如果您要指定\"\\\"，\n"
"请输入\"\\\\\"。可用的样式如下：\n"

#: src/nl.c:220
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pBRE      number only lines that contain a match for the basic regular\n"
"            expression, BRE\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"  a\t对所有行编号\n"
"  t\t对非空行编号\n"
"  n\t不编行号\n"
"  pBRE\t只对符合正则表达式BRE 的行编号\n"
"\n"
"FORMAT 是下列之一:\n"
"\n"
"  ln\t左对齐，空格不用0 填充\n"
"  rn \t右对齐，空格不用0 填充\n"
"  rz \t右对齐，空格用0 填充\n"
"\n"

#: src/nl.c:287
#, c-format
msgid "line number overflow"
msgstr "行号溢出"

#: src/nl.c:487
#, c-format
msgid "invalid header numbering style: %s"
msgstr "无效的页眉号样式：%s"

#: src/nl.c:495
#, c-format
msgid "invalid body numbering style: %s"
msgstr "无效的正文号样式：%s"

#: src/nl.c:503
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "无效的页脚号样式：%s"

#: src/nl.c:512
#, c-format
msgid "invalid starting line number: %s"
msgstr "无效的起始行号：%s"

#: src/nl.c:518
#, c-format
msgid "WARNING: --page-increment is deprecated; use --line-increment instead"
msgstr "警告：不推荐使用--page-increment，请使用--line-increment"

#: src/nl.c:525
#, c-format
msgid "invalid line number increment: %s"
msgstr "无效的行号递增值：%s"

#: src/nl.c:537
#, c-format
msgid "invalid number of blank lines: %s"
msgstr "无效的空行数：%s"

#: src/nl.c:551
#, c-format
msgid "invalid line number field width: %s"
msgstr "无效的行宽数值：%s"

#: src/nl.c:570
#, c-format
msgid "invalid line numbering format: %s"
msgstr "无效的编号格式：%s"

#: src/nohup.c:54
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 命令 [参数]...\n"
"　或：%s 选项\n"

#: src/nohup.c:60
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"忽略挂起信号运行指定的命令。\n"
"\n"

#: src/nohup.c:66
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from /dev/null.\n"
"If standard output is a terminal, append output to `nohup.out' if possible,\n"
"`$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use `%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"如果标准输入是一个终端，重定向自/dev/null。\n"
"如果标准输出是一个终端，尽可能将输出添加到\"nohup.out\"，\n"
"否则添加到\"$HOME/nohup.out\"。\n"
"如果标准错误输出是一个终端，重定向它到标准输出。\n"
"要保存输出内容到一个文件，使用 \"%s COMMAND > FILE\" 形式的命令。\n"

#: src/nohup.c:128
#, c-format
msgid "failed to render standard input unusable"
msgstr "标准输入不可用，无法重定向"

#: src/nohup.c:132
#, c-format
msgid "ignoring input"
msgstr "忽略输入"

#: src/nohup.c:164 src/nohup.c:166
#, c-format
msgid "failed to open %s"
msgstr "打开%s 失败"

#: src/nohup.c:176
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "忽略输入并把输出追加到%s"

#: src/nohup.c:177
#, c-format
msgid "appending output to %s"
msgstr "把输出追加到%s"

#: src/nohup.c:194
#, c-format
msgid "failed to set the copy of stderr to close on exec"
msgstr "执行时关闭标准错误失败"

#: src/nohup.c:199
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr "忽略输入重定向错误到标准输出端"

#: src/nohup.c:200
#, c-format
msgid "redirecting stderr to stdout"
msgstr "重定向标准错误到标准输出"

#: src/nohup.c:204
#, c-format
msgid "failed to redirect standard error"
msgstr "重定向标准错误失败"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:32
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:65 src/uname.c:122 src/whoami.c:46
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "用法：%s [选项]...\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"打印当前进程可用的处理器数，\n"
"此数目可能小于实际工作数\n"
"\n"

#: src/nproc.c:63
msgid ""
"     --all       print the number of installed processors\n"
"     --ignore=N  if possible, exclude N processing units\n"
msgstr ""
"     --all       打印所拥有的处理器数目\n"
"     --ignore=N  如果有可能，忽略 N 个处理器\n"

#: src/nproc.c:107
#, c-format
msgid "%s: invalid number to ignore"
msgstr "%s：无效的忽略数"

#: src/od.c:295
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"　或：%s [-abcdfilosx]... [文件] [[+]偏移量[.][b]]\n"
"　或：%s --traditional [选项]... [文件] [[+]偏移量[.][b] [+][标签][.][b]]\n"

#: src/od.c:301
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"\n"
"将指定文件以八进制形式(默认)转储到标准输出。如果指定了多于一个的文件\n"
"参数，程序会自动将输入的内容整合为列表并以同样的形式输出。\n"
"如果没有指定文件，或指定文件为\"-\"，程序从标准输入读取数据。\n"
"\n"

#: src/od.c:308
msgid "All arguments to long options are mandatory for short options.\n"
msgstr "长选项必须用的参数在使用短选项时也是必须的。\n"

#: src/od.c:311
msgid ""
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=初始偏移\t设置要显示的文件的初始偏移量\n"
"  -j, --skip-bytes=字节数\t略过指定字节数的输入内容\n"

#: src/od.c:315
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in traditional form\n"
msgstr ""
"  -N, --read-bytes=字节数\t限制要转储的输入字节为指定的字节数\n"
"  -S, --strings[=字节数]\t输出至少包含指定字节数的字符相应的字串\n"
"  -t, --format=类型\t\t选取输出格式类型\n"
"  -v, --output-duplicates\t不使用\"*\"字符标记屏蔽的行\n"
"  -w, --width[=字节数]\t\t每一行只输出指定的字节数\n"
"      --traditional\t\t接受传统形式提交的参数\n"

#: src/od.c:325
msgid ""
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"传统格式命令可混合使用，不同的格式可叠加：\n"
"  -a\t即 -t a， 使用命名的字符，忽略高阶位\n"
"  -b\t即 -t o1，使用八进制单字节字符\n"
"  -c\t即 -t c， 使用ASCII 字符，或者反斜杠正名的特殊字符\n"
"  -d\t即 -t u2，使用无符号十进制双字节字符\n"

#: src/od.c:333
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f\t即 -t fF，指定浮点数对照输出格式\n"
"  -i\t即 -t dl，指定十进制整数对照输出格式\n"
"  -l\t即 -t dL，指定十进制长整数对照输出格式\n"
"  -o\t即 -t o2，指定双字节单位八进制数的对照输出格式\n"
"  -s\t即 -t d2，指定双字节单位十进制数的对照输出格式\n"
"  -x\t即 -t x2，指定双字节单位十六进制数的对照输出格式\n"

#: src/od.c:341
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"如果两个调用格式都适用，系统会在最后一个运算量以\"+\"或数字开始\n"
"(如果有两个运算量)的情况下采用第二种格式。\n"
"偏移量是指 -j 偏移量。标签是第一个字节的伪地址，\n"
"随着累积过程递增。偏移量和标签如果冠以\"0x\"或\"0X\"前缀则\n"
"表示十六进制数；后缀\".\"代表八进制数，后缀\"b\"表示乘以 512。\n"

#: src/od.c:350
msgid ""
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character, ignoring high-order bit\n"
"  c          ASCII character or backslash escape\n"
msgstr ""
"\n"
"TYPE 是由下面一种或几种参数组成的：\n"
"\n"
"  a\t\t重定义字符，忽略高位字节\n"
"  c\t\tASCII 码字符或者是反斜线字串(如\\n)\n"

#: src/od.c:357
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[尺寸]\t有符号十进制数，每个整形数占指定尺寸的字节\n"
"  f[尺寸]\t浮点数，每个整形数占指定尺寸的字节\n"
"  o[尺寸]\t八进制数，每个整形数占指定尺寸的字节\n"
"  u[尺寸]\t无符号十进制数，每个整形数占指定尺寸的字节\n"
"  x[尺寸]\t十六进制数，每个整形数占指定尺寸的字节\n"

#: src/od.c:364
msgid ""
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"尺寸应该是一个数字。对 doux 等类型来说，适用的尺寸有：\n"
"C 代表 sizeof(char)、S 代表 sizeof(short)、I 代表 \n"
"sizeof(int)，或 L 代表 sizeof(long)；\n"
"如果类型是 f，可适用的尺寸有：\n"
"F 代表 sizeof(float)、D 代表sizeof(double)，或 L 代表\n"
"sizeof(long double)。\n"

#: src/od.c:371
msgid ""
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, and may have a multiplier "
"suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Adding a z suffix to any type displays printable characters at the end of "
"each\n"
"output line.\n"
msgstr ""
"\n"
"当 RADIX 为\"d\"时代表十进制，为\"o\"时代表八进制，为\"x\"时代表十六进制，\n"
"\"n\"则代表无。\n"
"BYTES 是以0x 或0X 为前缀的十六进制数，可能有以下几种后缀：\n"
"b 512，kB 1000，K 1024，MB 1000*1000，M 1024*1024，\n"
"GB 1000*1000*1000，G 1024*1024*1024，对于T，P，E，Z，Y 同样适用。\n"
"为任何类型添加\"z\"后缀都将在每个输出行的行尾显示可显示字符\n"

#: src/od.c:381
msgid ""
"Option --string without a number implies 3; option --width without a number\n"
"implies 32.  By default, od uses -A o -t oS -w16.\n"
msgstr ""
"不带数字的--string 选项代表3；不带数字的--width 选项代表32。\n"
"默认情况下od 使用 -A o -t oS -w16 参数。\n"

#: src/od.c:634 src/od.c:753
#, c-format
msgid "invalid type string %s"
msgstr "无效类型的字符串%s"

#: src/od.c:644
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"无效的类型字符串%s；\n"
"系统无法提供对%lu-字节整形类型数值的支持"

#: src/od.c:763
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"无效的类型字符串%s；\n"
"系统无法提供对%lu-字节浮点类型数值的支持"

#: src/od.c:818
#, c-format
msgid "invalid character `%c' in type string %s"
msgstr "无效字符\"%c\"出现在类型字符串%s 中"

#: src/od.c:1044
#, c-format
msgid "cannot skip past end of combined input"
msgstr "无法略过输入内容的报尾"

#: src/od.c:1600
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr "无效的输出地址基数\"%c\"，它必须是 [doxn] 四个字符中的一个"

#: src/od.c:1726
#, c-format
msgid "no type may be specified when dumping strings"
msgstr "在转储字符串时不能指定类型"

#: src/od.c:1801
msgid "compatibility mode supports at most one file"
msgstr "兼容模式最多支持一个文件"

#: src/od.c:1822
#, c-format
msgid "skip-bytes + read-bytes is too large"
msgstr "略过字节数+ 读入字节数的值过大"

#: src/od.c:1865
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "警告：无效的宽度值%lu，已使用%d 代替"

#: src/operand2sig.c:69
#, c-format
msgid "%s: invalid signal"
msgstr "%s：无效的信号"

#: src/paste.c:220
#, c-format
msgid "standard input is closed"
msgstr "标准输入已关闭"

#: src/paste.c:440
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"将每个指定文件里的每一行整合到对应一行里写到标准输出，之间用制表符分隔。\n"
"如果没有指定文件，或指定文件为\"-\"，程序将从标准输入读取数据。\n"
"\n"

#: src/paste.c:449
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=列表\t改用指定列表里的字符替代制表分隔符\n"
"  -s, --serial\t\t不使用平行的行目输出模式，而是每个文件占用一行\n"

#: src/paste.c:510
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "分割符列表以一个未跳过的反斜线结束：%s"

#: src/pathchk.c:91
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"判断无效或未移植的文件名。\n"
"\n"
"  -p                  \t为类POSIX 兼容系统检查\n"
"  -P                  \t检查空文件名和前导\"-\"文件名\n"
"      --portability   \t为完整POSIX 兼容系统检查(等于-p -P)\n"

#: src/pathchk.c:171
#, c-format
msgid "leading `-' in a component of file name %s"
msgstr "文件名%s 以\"-\"符号开头"

#: src/pathchk.c:197
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "有不通用的字符%s 被包含在文件名%s 中"

#: src/pathchk.c:273
#, c-format
msgid "empty file name"
msgstr "空文件名"

#: src/pathchk.c:315
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s：不能确定最大文件名长度"

#: src/pathchk.c:326
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "文件名%3$s 的长度%2$lu 超出限值%1$lu"

#: src/pathchk.c:412
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr "文件名成分%3$s 的长度%2$lu 超出限值%1$lu"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:36 src/uptime.c:45 src/users.c:35 src/who.c:48
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:38 src/uptime.c:47
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:250
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:274
msgid "?????"
msgstr "?????"

#: src/pinky.c:323
#, c-format
msgid "Login name: "
msgstr "登录名： "

#: src/pinky.c:326
#, c-format
msgid "In real life: "
msgstr "实名： "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:330
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:350
#, c-format
msgid "Directory: "
msgstr "主目录： "

#: src/pinky.c:352
#, c-format
msgid "Shell: "
msgstr "Shell： "

#: src/pinky.c:371
#, c-format
msgid "Project: "
msgstr "项目： "

#: src/pinky.c:395
#, c-format
msgid "Plan:\n"
msgstr "计划：\n"

#: src/pinky.c:414
msgid "Login"
msgstr "登录"

#: src/pinky.c:416
msgid "Name"
msgstr "名字"

#: src/pinky.c:417
msgid " TTY"
msgstr " TTY"

#: src/pinky.c:419
msgid "Idle"
msgstr "空闲"

#: src/pinky.c:420
msgid "When"
msgstr "从"

#: src/pinky.c:423
msgid "Where"
msgstr "来自"

#: src/pinky.c:503
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "用法: %s [选项]... [用户]...\n"

#: src/pinky.c:504
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l\t对指定用户输出完整的长格式信息\n"
"  -b\t在长格式中省略用户主目录以及登录 shell\n"
"  -h\t在长格式中省略用户的项目文件\n"
"  -p\t在长格式中省略用户的计划文件\n"
"  -s\t输出短格式信息(默认)\n"

#: src/pinky.c:512
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f\t在短格式中省略列栏报头\n"
"  -w\t在短格式中省略用户全名\n"
"  -i\t在短格式中省略用户全名以及远程主机\n"
"  -q\t在短格式中省略用户全名、远程主机以及空闲时间\n"

#: src/pinky.c:521
#, c-format
msgid ""
"\n"
"A lightweight `finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"一个轻量级的\"finger\"程序，用于显示用户信息。\n"
"用到的utmp 文件为%s。\n"

#: src/pinky.c:605
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr "没有指定用户名，当使用-l 选项时至少需要指定一个"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:330
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:331
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:913
#, c-format
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "\"--pages=首页[:末页]\"缺失参数"

#: src/pr.c:915
#, c-format
msgid "invalid page range %s"
msgstr "页码范围%s 无效"

#: src/pr.c:980
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: %s"
msgstr "\"-l 页长\"中含有无效的行号：%s"

#: src/pr.c:1004
#, c-format
msgid "`-N NUMBER' invalid starting line number: %s"
msgstr "\"-N 编号\"中含有无效的起始行号：%s"

#: src/pr.c:1016
#, c-format
msgid "`-o MARGIN' invalid line offset: %s"
msgstr "\"-o 页边距\"中含有无效的行偏移量：%s"

#: src/pr.c:1057
#, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: %s"
msgstr "\"-w \"中含有无效的字符数：%s"

#: src/pr.c:1071
#, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: %s"
msgstr "\"-w \"中含有无效的字符数：%s"

#: src/pr.c:1101
#, c-format
msgid "cannot specify number of columns when printing in parallel"
msgstr "在平行输出参数时不能指定栏数"

#: src/pr.c:1105
#, c-format
msgid "cannot specify both printing across and printing in parallel"
msgstr "无法同时指定相交输出和平行输出参数"

#: src/pr.c:1201
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: %s"
msgstr "有多余字符\"-%c\"或无效数字出现在参数%s 中"

#: src/pr.c:1305
#, c-format
msgid "page width too narrow"
msgstr "过窄"

#: src/pr.c:2370
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr "起始页码%<PRIuMAX> 超出了最大页数%<PRIuMAX>"

#: src/pr.c:2397
#, c-format
msgid "page number overflow"
msgstr "页码溢出"

#: src/pr.c:2402
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "第 %<PRIuMAX> 页"

#: src/pr.c:2775
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
msgstr ""
"对指定文件附注打印所需的页码或聚焦。\n"
"\n"

#: src/pr.c:2782
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +首页[:末页], --pages=首页[:末页]\n"
"\t\t\t在指定的首页/末页处开始/停止打印\n"
"  -列数, --columns=列数\n"
"\t\t\t输出指定的列数。如果指定了-a 选项，则从上到下列印。\n"
"\t\t\t程序会自动在每一页均衡每列占用的行数。\n"

#: src/pr.c:2790
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across\t\t设置每列从上到下输出，配合\"-列数\"选项一起使用\n"
"  -c, --show-control-chars\n"
"\t\t\t使用头标(^G)和八进制反斜杠标记\n"
"  -d, --double-space\t加倍输出空白区域\n"

#: src/pr.c:2798
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=格式\n"
"\t\t\t使用遵循指定格式的页眉日期\n"
"  -e[字符[宽度]], --expand-tabs[=字符[宽度]]\n"
"\t\t\t扩展输入的字符(制表符) 到制表符宽度(8)\n"
"  -F, -f, --form-feed\t使用出纸页页标代替新行作为页面间的分隔符\n"
"\t\t\t(使用-F 选项时报头为3 行,不使用时为5 行)\n"

#: src/pr.c:2808
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h, --header=页眉\t在页眉中使用居中的指定字符代替文件名\n"
"\t\t\t-h \"\" 输出一个空行，不要使用 -h\"\"\n"
"  -i[字符[宽度]], --output-tabs[=字符[宽度]]\n"
"\t\t\t使用指定字符(或制表符)代替空格不足到指定制表符宽度(默认8)\n"
"  -J, --join-lines\t合并整个行，关闭-W 选项的行截断，不使用栏调整，使用\n"
"\t\t\t\t--sep-string[=字符串] 设置分隔符\n"

#: src/pr.c:2817
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -l, --length=页长\n"
"\t\t\t使用指定页长的行数(默认66)\n"
"\t\t\t(默认文本行数为56，当启用-F 时为 63)\n"
"  -m, --merge\t\t在同一行显示所有文件，每个文件占用一栏，分割行，但是当\n"
"\t\t\t使用-J 时将行合并到完整长度\n"

#: src/pr.c:2824
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[分隔符[位数]], --number-lines[=分隔符[位数]]\n"
"\t\t\t显示行号，使用指定(默认5) 位数，后接分隔符(默认TAB)\n"
"\t\t\t默认从输入文件的第一行开始计数\n"
"  -N, --first-line-number=数字\n"
"\t\t\t从首页的首行以指定数字开始计数(参看\"+首页\")\n"

#: src/pr.c:2832
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=缩进量\n"
"\t\t\t将每行缩进(默认0)个空格，不影响-w 或-W 参数，\n"
"\t\t\t缩进亮的值将被加入页面宽度\n"
"  -r, --no-file-warnings\n"
"\t\t\t当文件无法打开时忽略警告\n"

#: src/pr.c:2839
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[CHAR], --separator[=CHAR]\n"
"\t\t\t由单个字符分隔各列，未附加-w 时默认为制表符，否则为空。\n"
"\t\t\t另外除非-w 选项被指定，否则\"-s[CHAR]\"会屏蔽三个列相关\n"
"\t\t\t的截行选项(-COLUMN|-a -COLUMN|-m)\n"

#: src/pr.c:2846
msgid ""
"  -SSTRING, --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header  omit page headers and trailers\n"
msgstr ""
"  -S字符串, --sep-string[=字符串]\n"
"\t\t\t使用指定的字符串分栏，不使用-S 则使用默认的制表符\n"
"\t\t\tTAB 作为分隔符，与-J 和空格一起使用(等于-S\" \")对\n"
"\t\t\t分栏选项无影响\n"
"  -t, --omit-header\t忽略页眉和页脚\n"

#: src/pr.c:2853
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"\t\t\t按照输入文件中的设置忽略页眉和页脚并除去所有分页记号\n"
"  -v, --show-nonprinting\n"
"\t\t\t使用八进制反斜杠标记\n"
"  -w, --width=页面宽度\n"
"\t\t\t为多栏页面输出将设置为指定的字符数(默认72)，\n"
"\t\t\t仅当-s[char] 选项不启用时有效(即保持默认值 72)。\n"

#: src/pr.c:2863
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W, --page-width=页宽\n"
"\t\t\t总是将页宽设置为指定的(默认72)字符数，\n"
"\t\t\t除非-J 选项启用总是截断行，此参数与-S 或-s 冲突\n"

#: src/pr.c:2871
msgid ""
"\n"
"-t is implied if PAGE_LENGTH <= 10.  With no FILE, or when FILE is -, read\n"
"standard input.\n"
msgstr ""
"\n"
"如果页长<=10 则使用-t 选项。如果FILE 没有定义，\n"
"或者FILE 是\"-\"，则从标准输入读入。\n"

#: src/printenv.c:63
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"用法： %s [选项]... [变量]...\n"
"显示指定的环境变量的值。\n"
"如果没有指定变量，则打印出所有变量的名称和值。\n"
"\n"

#: src/printenv.c:70
msgid "  -0, --null     end each output line with 0 byte rather than newline\n"
msgstr "  -0, --null     以空字符而非新行符结束每一输出行\n"

#: src/printf.c:79
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr "警告：%s：跟随在常量字符后的其它字符已被忽略"

#: src/printf.c:89
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 格式 [参数]\n"
"　或：%s 选项\n"

#: src/printf.c:94
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"按照指定格式打印参数或按照选项执行该参数：\n"
"\n"

#: src/printf.c:100
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"指定格式类似 C 中的 printf 函数，可控制输出。有效的解释序列有：\n"
"\n"
"  \\\"\t\t双引号\n"

#: src/printf.c:118
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN          字节以八进制数 NNN(1至3位数)表示\n"
"  \\xHH\t\t字节以十六进制数 HH(1至2位数)表示\n"
"  \\uHHHH\tUnicode(ISO/IEC 10646)字符以十六进制数 HHHH(4位数)表示\n"
"  \\UHHHHHHHH\tUnicode 字符以十六进制数 HHHHHHHH(8位数)表示\n"

#: src/printf.c:124
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with `\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%\t\t一个 \"%\"\n"
"  %b\t\t带\"\\\"的指定的参数是禁用转义符的字符串，\n"
"          例外：八进制数的转义串采用\"\\0\"或\"\\0NNN\"的形式\n"
"\n"
"同时，所有以diouxXfeEgGcs 结尾的C 格式化说明，将首先把指定的参数转换为\n"
"合适的类型。变量的宽度将得到恰当处理。\n"

#: src/printf.c:149
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s：需要一个数值"

#: src/printf.c:151
#, c-format
msgid "%s: value not completely converted"
msgstr "%s：给定值不能完全转换"

#: src/printf.c:248 src/printf.c:275
#, c-format
msgid "missing hexadecimal number in escape"
msgstr "Escape 中缺失十六进制数"

#: src/printf.c:287
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "无效的通用字符名称\\%c%0*x"

#: src/printf.c:548
#, c-format
msgid "invalid field width: %s"
msgstr "无效的域宽度：%s"

#: src/printf.c:583
#, c-format
msgid "invalid precision: %s"
msgstr "无效的精度：%s"

#: src/printf.c:610
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s：无效的转换声明"

#: src/printf.c:693
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "警告：从%s 开始已忽略超量的参数"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:42
msgid "F. Pinard"
msgstr "F. Pinard"

#: src/ptx.c:419
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (正则表达式 %s)"

#: src/ptx.c:1818
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"用法：%s [选项]... [输入]... (不包括 -G 选项)\n"
"　或：%s -G [选项]... [输入 [输出]]\n"

#: src/ptx.c:1822
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
"\n"
msgstr ""
"输出一串预排的文件索引信息，包括输入文件中各单词的环境。\n"
"\n"

#: src/ptx.c:1829
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
msgstr ""
"  -A,--auto-reference\t\t输出自动生成的引用\n"
"  -G,--traditional\t\t行为类似System V 的\"ptx\"\n"
"  -F,--flag-trunctaion=字符串\t使用指定字符串来标识行的截断\n"

#: src/ptx.c:1834
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=字符串\t指定代替\"xx\"的宏名\n"
"  -O, --format=roff\t\t生成roff 格式输出\n"
"  -R, --right-side-refs\t\t将关联引用放置在右侧，不能和-w 选项叠加\n"
"  -S, --sentence-regexp=正则表达式\t用于匹配行末或句末\n"
"  -T, --format=tex\t\t生成TeX 格式输出\n"

#: src/ptx.c:1841
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=正则表达式\t使用正则表达式匹配每个关键字\n"
"  -b, --break-file=文件\t\t以文件中包含的单词为分隔字符\n"
"  -f, --ignore-case\t\t排序时合并小写字母和大写字母\n"
"  -g, --gap-size=数值\t\t指定多个输出区块间的列间隙尺寸\n"
"  -i, --ignore-file=文件\t从指定文件中读取忽略单词的列表\n"
"  -o, --only-file=文件\t\t只从指定文件中读取单词列表\n"

#: src/ptx.c:1849
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references\t\t设置每行的第一个区块为关联引用\n"
"  -t, --typeset-mode\t\t -- 此功能尚未实现 --\n"
"  -w, --width=数值\t\t每列的输出宽度，不计关联引用\n"

#: src/ptx.c:1856
msgid ""
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""
"\n"
"如果不指定文件，或者文件为 \"-\"，程序将从标准输入读取数据。默认时隐含\n"
"\"-F /\"选项。\n"

#: src/ptx.c:1950
#, c-format
msgid "invalid gap width: %s"
msgstr "无效的间隙宽度：%s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"输出当前工作目录的完整名称。\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical\t\t使用环境变量中的PWD，即使其中包含符号链接\n"
"  -P, --physical\t避免所有符号链接\n"

#: src/pwd.c:167
#, c-format
msgid "failed to chdir to %s"
msgstr "无法切换到目录%s"

#: src/pwd.c:171 src/pwd.c:278
#, c-format
msgid "failed to stat %s"
msgstr "获取%s 的文件状态失败(stat)"

#: src/pwd.c:236
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "在匹配的inode %s 上找不到目录入口"

#: src/pwd.c:363
#, c-format
msgid "ignoring non-option arguments"
msgstr "忽略不是选项的参数"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:33
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:63
#, c-format
msgid "Usage: %s [OPTION]... FILE\n"
msgstr "用法：%s [选项]... 文件\n"

#: src/readlink.c:64
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"输出符号链接值或权威文件名。\n"
"\n"

#: src/readlink.c:66
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize\t\t递归跟随给出文件名的所有符号链接以标准化，\n"
"\t\t\t\t除最后一个外所有组件必须存在\n"
"  -e, --canonicalize-existing\t递归跟随给出文件名的所有符号链接以标准化，\n"
"\t\t\t\t所有组件都必须存在\n"

#: src/readlink.c:76
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing newline\n"
"  -q, --quiet,\n"
"  -s, --silent                  suppress most error messages\n"
"  -v, --verbose                 report error messages\n"
msgstr ""
"  -m, --canonicalize-missing\t递归跟随给出文件名的所有符号链接以标准化，\n"
"\t\t\t\t但不对组件存在性作出要求\n"
"  -n, --no-newline\t不输出尾随的新行\n"
"  -q, --quiet,\n"
"  -s, --silent\t\t缩减大多数的错误消息\n"
"  -v, --verbose\t\t报告所有错误消息\n"

#: src/remove.c:313
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s：是否进入有写保护的目录%s ？"

#: src/remove.c:314
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s：是否进入目录%s? "

#. TRANSLATORS: You may find it more convenient to
#. translate "%s: remove %s (write-protected) %s? "
#. instead.  It should avoid grammatical problems
#. with the output of file_type.
#: src/remove.c:330
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s：是否删除有写保护的%s %s？"

#: src/remove.c:331
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s：是否删除%s %s？"

#: src/remove.c:444
#, c-format
msgid "removed directory: %s\n"
msgstr "已删除目录：%s\n"

#: src/remove.c:508
#, c-format
msgid "cannot remove directory: %s"
msgstr "无法删除目录：%s"

#: src/remove.c:564
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "跳过%s，因为它位于不同的设备上"

#: src/remove.c:584
#, c-format
msgid "traversal failed: %s"
msgstr "遍历失败：%s"

#: src/remove.c:590
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""
"异常错误：fts_info=%d: %s\n"
"请报告给 %s"

#: src/rm.c:118
#, c-format
msgid "Try `%s ./%s' to remove the file %s.\n"
msgstr "尝试使用\"%s ./%s\"删除文件%s。\n"

#: src/rm.c:135 src/shred.c:159 src/stat.c:1322 src/touch.c:217
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "用法：%s [选项]... 文件...\n"

#: src/rm.c:136
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files, never prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"删除 (unlink) 文件。\n"
"\n"
"  -f, --force\t\t强制删除。忽略不存在的文件，不提示确认\n"
"  -i\t\t\t在删除前需要确认\n"

#: src/rm.c:142
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively.  Less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i).  Without WHEN, prompt always\n"
msgstr ""
"  -I\t\t\t在删除超过三个文件或者递归删除前要求确认。此选项比-i 提\n"
"\t\t\t示内容更少，但同样可以阻止大多数错误发生\n"
"      --interactive[=WHEN]\t根据指定的WHEN 进行确认提示：never，once (-I)，\n"
"\t\t\t\t或者always (-i)。如果此参数不加WHEN 则总是提示\n"

#: src/rm.c:149
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system\t\t递归删除一个层级时，跳过所有不符合命令行参\n"
"\t\t\t\t数的文件系统上的文件\n"

#: src/rm.c:154
msgid ""
"      --no-preserve-root  do not treat `/' specially\n"
"      --preserve-root   do not remove `/' (default)\n"
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"      --no-preserve-roo\t不特殊对待\"/\"\n"
"      --preserve-root\t不允许删除\"/\"(默认)\n"
"  -r, -R, --recursive\t递归删除目录及其内容\n"
"  -v, --verbose\t\t详细显示进行的步骤\n"

#: src/rm.c:162
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"默认时，rm 不会删除目录。使用--recursive(-r 或-R)选项可删除每个给定\n"
"的目录，以及其下所有的内容。\n"

#: src/rm.c:167
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a `-', for example `-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"要删除第一个字符为\"-\"的文件 (例如\"-foo\")，请使用以下方法之一：\n"
"  %s -- -foo\n"
"  %s ./-foo\n"

#: src/rm.c:176
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"请注意，如果使用rm 来删除文件，通常仍可以将该文件恢复原状。如果想保证\n"
"该文件的内容无法还原，请考虑使用shred。\n"

#: src/rm.c:336
#, c-format
msgid "%s: remove all arguments recursively? "
msgstr "%s：递归删除所有参数？"

#: src/rm.c:337
#, c-format
msgid "%s: remove all arguments? "
msgstr "%s：删除所有参数？"

#: src/rmdir.c:134 src/rmdir.c:234
#, c-format
msgid "removing directory, %s"
msgstr "正在删除目录 %s"

#: src/rmdir.c:148
#, c-format
msgid "failed to remove directory %s"
msgstr "删除目录 %s 失败"

#: src/rmdir.c:166
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"删除指定的空目录。\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"\t\t\t忽略仅由目录非空产生的所有错误\n"

#: src/rmdir.c:173
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., `rmdir -p a/b/c' "
"is\n"
"                    similar to `rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents\t\t删除指定目录及其上级文件夹，例如\"rmdir -p a/b/c'\"\n"
"\t\t\t与\"rmdir a/b/c a/b a'\" 基本相同\n"
"  -v, --verbose\t\t输出处理的目录详情\n"

#: src/rmdir.c:243
#, c-format
msgid "failed to remove %s"
msgstr "删除 %s 失败"

#: src/runcon.c:84
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"用法: %s 环境 命令 [参数]\n"
"　或: %s [ -c ] [-u 用户] [-r 角色] [-t 类型] [-l 范围] 命令 [参数]\n"

#: src/runcon.c:88
msgid ""
"Run a program in a different security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
"\n"
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""
"以不同的安全环境运行程序。\n"
"如果没有指定环境或命令之一，输出当前安全环境。\n"
"\n"
"  环境\t\t\t完整的安全环境描述\n"
"  -c, --compute\t\t在更改前计算环境变化\n"
"  -t, --type=类型\t类型(与父进程角色相同)\n"
"  -u, --user=用户\t用户身份\n"
"  -r, --role=角色\t角色\n"
"  -l, --range=范围\t级别范围\n"
"\n"

#: src/runcon.c:141
#, c-format
msgid "multiple roles"
msgstr "多角色"

#: src/runcon.c:146
#, c-format
msgid "multiple types"
msgstr "多类型"

#: src/runcon.c:151
#, c-format
msgid "multiple users"
msgstr "多用户"

#: src/runcon.c:156
#, c-format
msgid "multiple levelranges"
msgstr "复合级别范围"

#: src/runcon.c:174 src/runcon.c:210
#, c-format
msgid "failed to get current context"
msgstr "无法获得当前安全环境"

#: src/runcon.c:184
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "您必须指定-c，-t，-u，-l，-r 或环境"

#: src/runcon.c:192
#, c-format
msgid "no command specified"
msgstr "没有指定命令"

#: src/runcon.c:198
#, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "%s 只能用于启用了SELinux 支持的内核"

#: src/runcon.c:224
#, c-format
msgid "failed to compute a new context"
msgstr "计算新的环境失败"

#: src/runcon.c:238
#, c-format
msgid "failed to set new user %s"
msgstr "设置新用户%s 失败"

#: src/runcon.c:240
#, c-format
msgid "failed to set new type %s"
msgstr "设置新类型%s 失败"

#: src/runcon.c:242
#, c-format
msgid "failed to set new range %s"
msgstr "设置新范围%s 失败"

#: src/runcon.c:244
#, c-format
msgid "failed to set new role %s"
msgstr "设置新角色%s 失败"

#: src/runcon.c:252
#, c-format
msgid "unable to set security context %s"
msgstr "无法设置安全环境%s"

#: src/seq.c:69
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"用法：%s [选项]... 尾数\n"
"　或：%s [选项]... 首数 尾数\n"
"　或：%s [选项]... 首数 增量 尾数\n"

#: src/seq.c:74
msgid ""
"Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
"\n"
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"以指定增量从首数开始打印数字到尾数。\n"
"\n"
"  -f, --format=格式\t使用printf 样式的浮点格式\n"
"  -s, --separator=字符串\t使用指定字符串分隔数字(默认使用：\\n)\n"
"  -w, --equal-width\t在列前添加0 使得宽度相同\n"

#: src/seq.c:83
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
msgstr ""
"\n"
"如果省略了首数或者增量，则默认其值为1，即使这样尾数仍小于首数。\n"
"首数、增量和尾数均以浮点数形式解释。当首数小于尾数时增量一般为正值，\n"
"相反在首数大于尾数时增量一般为负数。\n"

#: src/seq.c:91
msgid ""
"FORMAT must be suitable for printing one argument of type `double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""
"指定的格式必须适用于显示\"double\"类型的参数；当首数、增量和尾数均为指定\n"
"精确度的定点十进制数时默认为\"%.精确度f\"，否则默认为\"%g\"。\n"

#: src/seq.c:137
#, c-format
msgid "invalid floating point argument: %s"
msgstr "无效的浮点参数：%s"

#: src/seq.c:194
#, c-format
msgid "format %s has no %% directive"
msgstr "格式%s 没有%% 指令"

#: src/seq.c:211
#, c-format
msgid "format %s ends in %%"
msgstr "格式%s 以%% 结束"

#: src/seq.c:214
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "格式%s 中包含未知%%%c 指令"

#: src/seq.c:218
#, c-format
msgid "format %s has too many %% directives"
msgstr "格式%s 中%% 指令过多"

#: src/seq.c:432
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr "当输出等宽字符串时不应再指定格式字符串"

#: src/setuidgid.c:50
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... USER COMMAND [ARGUMENT]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"用法：%s [短选项]... 用户 命令 [参数]...\n"
"　或：%s 长选项\n"

#: src/setuidgid.c:56
msgid ""
"Drop any supplemental groups, assume the user-ID and group-ID of the "
"specified\n"
"USER (numeric ID or user name), and run COMMAND with any specified "
"ARGUMENTs.\n"
"Exit with status 111 if unable to assume the required user and group ID.\n"
"Otherwise, exit with the exit status of COMMAND.\n"
"This program is useful only when run by root (user ID zero).\n"
"\n"
msgstr ""
"使用指定的用户(数字ID 或者用户名) 替代原有用户ID 和组ID 运行连同参数的指定命"
"令\n"
"如果无法指定请求的用户和组ID 则以状态号111 退出，否则以所执行命令的终止状态号"
"退出。\n"
"此程序通常仅在使用root 运行时有用 (root 的用户ID 为0)。\n"

#: src/setuidgid.c:65
msgid ""
"  -g GID[,GID1...]  also set the primary group-ID to the numeric GID, and\n"
"                    (if specified) supplemental group IDs to GID1, ...\n"
msgstr ""
"  -g GID[,GID1...]\t将主组ID 设置为指定的数字GID，如果指定了GID1，\n"
"\t\t\t\t则同时添加这些附加组ID，...\n"

#: src/setuidgid.c:164
#, c-format
msgid "unknown user-ID: %s"
msgstr "未知的用户ID：%s"

#: src/setuidgid.c:175
#, c-format
msgid "to use user-ID %s you need to use -g too"
msgstr "您应当将-g 与用户ID %s 一起使用"

#: src/setuidgid.c:192
#, c-format
msgid "failed to set supplemental group(s)"
msgstr "设置附加组失败"

#: src/setuidgid.c:202
#, c-format
msgid "cannot set group-ID to %lu"
msgstr "无法设置组ID 为%lu"

#: src/setuidgid.c:206
#, c-format
msgid "cannot set user-ID to %lu"
msgstr "无法设置用户ID 为%lu"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:85
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:160
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
"\n"
msgstr ""
"多次覆盖文件，使得即使是昂贵的硬件探测仪器也难以将数据复原。\n"
"\n"

#: src/shred.c:168
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force\t\t必要时修改权限以使目标可写\n"
"  -n, --iterations=N\t覆盖N 次，而非使用默认的%d 次\n"
"      --random-source=文件\t从指定文件中取出随机字节\n"
"  -s, --size=N\t\t粉碎数据为指定字节的碎片(可使用K、M 和G 作为单位)\n"

#: src/shred.c:174
msgid ""
"  -u, --remove   truncate and remove file after overwriting\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u, --remove\t\t覆盖后截断并删除文件\n"
"  -v, --verbose\t\t显示详细信息\n"
"  -x, --exact\t\t不将文件大小增加至最接近的块大小\n"
"  -z, --zero \t\t最后一次使用0 进行覆盖以隐藏覆盖动作\n"

#: src/shred.c:183
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.  When operating on regular\n"
"files, most people use the --remove option.\n"
"\n"
msgstr ""
"\n"
"如果指定文件为\"-\"，粉碎标准输出的数据。\n"
"\n"
"如果加上--remove (-u)选项表示删除文件。默认的方式是不删除文件，因为\n"
"覆盖像/dev/hda 等的设备文件是很普遍的，而这些文件通常不应删除。当覆盖\n"
"一般文件时，绝大多数人都会使用--remove 选项。\n"
"\n"

#: src/shred.c:193
msgid ""
"CAUTION: Note that shred relies on a very important assumption:\n"
"that the file system overwrites data in place.  This is the traditional\n"
"way to do things, but many modern file system designs do not satisfy this\n"
"assumption.  The following are examples of file systems on which shred is\n"
"not effective, or is not guaranteed to be effective in all file system "
"modes:\n"
"\n"
msgstr ""
"警告：请注意使用shred 时有一个很重要的条件：\n"
"文件系统会在原来的位置覆盖指定的数据。传统的文件系统符合此条件，但许多现代\n"
"的文件系统都不符合条件。以下是会令shred 无效或不担保一定有效的文件系统的\n"
"例子：\n"
"\n"

#: src/shred.c:201
msgid ""
"* log-structured or journaled file systems, such as those supplied with\n"
"AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
"\n"
"* file systems that write redundant data and carry on even if some writes\n"
"fail, such as RAID-based file systems\n"
"\n"
"* file systems that make snapshots, such as Network Appliance's NFS server\n"
"\n"
msgstr ""
"* 有纪录结构或是日志式文件系统，如AIX 及Solaris 使用的文件系统 (以及\n"
"   JFS、ReiserFS、XFS、Ext3 等)\n"
"\n"
"* 会重复写入数据，及即使一部份写入动作失败后仍可继续的文件系统，如使用\n"
"   RAID 的文件系统\n"
"\n"
"* 会不时进行快照记录的文件系统，像Network Applicance 的NFS 服务器\n"
"\n"

#: src/shred.c:211
msgid ""
"* file systems that cache in temporary locations, such as NFS\n"
"version 3 clients\n"
"\n"
"* compressed file systems\n"
"\n"
msgstr ""
"* 文件系统是存放于缓存位置，比如NFS 第三版用户端\n"
"\n"
"* 压缩文件系统\n"
"\n"

#: src/shred.c:218
msgid ""
"In the case of ext3 file systems, the above disclaimer applies\n"
"(and shred is thus of limited effectiveness) only in data=journal mode,\n"
"which journals file data in addition to just metadata.  In both the\n"
"data=ordered (default) and data=writeback modes, shred works as usual.\n"
"Ext3 journaling modes can be changed by adding the data=something option\n"
"to the mount options for a particular file system in the /etc/fstab file,\n"
"as documented in the mount man page (man mount).\n"
"\n"
msgstr ""
"在Ext3 文件系统中，以上免责声明仅适用于启用了data=journal 模式的情况，\n"
"此时文件日志记录了附加的元数据 shred 的作用将受到影响。在data=ordered(默认)\n"
"或data=writeback 模式下shred 仍然有效。\n"
"Ext3 日志模式可通过向/etc/fstab 的挂载选项中添加data=something 进行设置，\n"
"您可以查看mount 的man 页面以获得详细信息。\n"
"\n"

#: src/shred.c:228
msgid ""
"In addition, file system backups and remote mirrors may contain copies\n"
"of the file that cannot be removed, and that will allow a shredded file\n"
"to be recovered later.\n"
msgstr ""
"另外，文件系统备份和远程镜像可能会\n"
"包含不能被删除的文件副本，这将会\n"
"允许碎片文件被恢复。\n"

#: src/shred.c:308
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s：fadatsync 失败"

#: src/shred.c:319
#, c-format
msgid "%s: fsync failed"
msgstr "%s：fsync 失败"

#: src/shred.c:396
#, c-format
msgid "%s: cannot rewind"
msgstr "%s：无法反绕操作"

#: src/shred.c:415
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s：第%lu 次，共%lu 次 (%s)..."

#: src/shred.c:465
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s：在位置%s 写入时出现错误"

#: src/shred.c:483
#, c-format
msgid "%s: lseek failed"
msgstr "%s：lseek 失败"

#: src/shred.c:494
#, c-format
msgid "%s: file too large"
msgstr "%s：文件过大"

#: src/shred.c:517
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s：第%lu 次，共%lu 次 (%s)...%s"

#: src/shred.c:533
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s：第%lu 次，共%lu 次 (%s)...%s/%s %d%%"

#: src/shred.c:780
#, c-format
msgid "%s: fstat failed"
msgstr "%s：获取文件状态失败(fstat)"

#: src/shred.c:791
#, c-format
msgid "%s: invalid file type"
msgstr "%s：无效的文件类型"

#: src/shred.c:810
#, c-format
msgid "%s: file has negative size"
msgstr "%s：文件的大小为负数"

#: src/shred.c:877
#, c-format
msgid "%s: error truncating"
msgstr "%s：截断文件时出错"

#: src/shred.c:893
#, c-format
msgid "%s: fcntl failed"
msgstr "%s：文件控制操作失败(fcntl)"

#: src/shred.c:898
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s：不能对只可追加数据的文件描述符(file descriptor) 进行粉碎"

#: src/shred.c:980
#, c-format
msgid "%s: removing"
msgstr "%s：正在删除"

#: src/shred.c:1004
#, c-format
msgid "%s: renamed to %s"
msgstr "%s：名称已更改为 %s"

#: src/shred.c:1026
#, c-format
msgid "%s: failed to remove"
msgstr "%s：删除失败"

#: src/shred.c:1030
#, c-format
msgid "%s: removed"
msgstr "%s：已删除"

#: src/shred.c:1037 src/shred.c:1080
#, c-format
msgid "%s: failed to close"
msgstr "%s：无法关闭"

#: src/shred.c:1073
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s：无法以写模式打开"

#: src/shred.c:1138
#, c-format
msgid "%s: invalid number of passes"
msgstr "%s：覆盖次数无效"

#: src/shred.c:1147 src/shuf.c:292 src/sort.c:4375
#, c-format
msgid "multiple random sources specified"
msgstr "指定了多个随机源"

#: src/shred.c:1161
#, c-format
msgid "%s: invalid file size"
msgstr "%s：文件大小无效"

#: src/shuf.c:49
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"用法： %s [选项]... [文件]\n"
"　或者:  %s -e [选项]... [参数]...\n"
"　或者:  %s -i LO-HI [选项]...\n"

#: src/shuf.c:55
msgid ""
"Write a random permutation of the input lines to standard output.\n"
"\n"
msgstr ""
"把输入行按随机顺序输出到标准输出。\n"
"\n"

#: src/shuf.c:62
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -e, --echo\t\t\t将每个参数视为输入行\n"
"  -i, --input-range=LO-HI\t将LO 到HI 的每个数字视为输入行\n"
"  -n, --head-count=行数\t\t最多输出指定的行数\n"
"  -o, --output=文件\t\t将结果输出到指定文件而非标准输出\n"
"      --random-source=文件\t从指定文件获得随机比特\n"
"  -z, --zero-terminated\t以0 结束行而非新行\n"

#: src/shuf.c:246
#, c-format
msgid "multiple -i options specified"
msgstr "指定了多个-i 选项"

#: src/shuf.c:266
#, c-format
msgid "invalid input range %s"
msgstr "无效的输入范围：%s"

#: src/shuf.c:279
#, c-format
msgid "invalid line count %s"
msgstr "无效的行数%s"

#: src/shuf.c:286 src/sort.c:4369
#, c-format
msgid "multiple output files specified"
msgstr "指定了多个输出文件"

#: src/shuf.c:312
#, c-format
msgid "cannot combine -e and -i options"
msgstr "不能同时指定-e 和-i 选项"

#: src/sleep.c:46
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be `s' for seconds (the default),\n"
"`m' for minutes, `h' for hours or `d' for days.  Unlike most "
"implementations\n"
"that require NUMBER be an integer, here NUMBER may be an arbitrary floating\n"
"point number.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"用法：%s 数字[时间单位]...\n"
"　或：%s 选项\n"
"暂停指定的秒数。时间单位可以是s 表示秒(默认设置)，m 表示分钟，\n"
"h 表示小时，d 表示天。 指定数字可以是一个整数，也可以是浮点数。\n"
"如果参数个数超过2 个，暂停的总时间为各个参数的值的和。\n"
"\n"

#: src/sleep.c:137 src/timeout.c:293
#, c-format
msgid "invalid time interval %s"
msgstr "无效的时间间隔%s"

#: src/sleep.c:148 src/tail.c:1218
#, c-format
msgid "cannot read realtime clock"
msgstr "无法读取实时时钟"

#: src/sort.c:398
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
msgstr ""
"串联排序所有指定文件并将结果写到标准输出。\n"
"\n"

#: src/sort.c:405
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"排序选项：\n"
"\n"

#: src/sort.c:409
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks\t忽略前导的空白区域\n"
"  -d, --dictionary-order\t只考虑空白区域和字母字符\n"
"  -f, --ignore-case\t\t忽略字母大小写\n"

#: src/sort.c:415
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n"
msgstr ""
"  -g, --general-numeric-sort\t按照常规数值排序\n"
"  -i, --ignore-nonprinting\t只排序可打印字符\n"
"  -M, --month-sort\t\t比较 (未知) < \"一月\" < ... < \"十二月\"\n"
"\t\t\t\t在LC_ALL=C 时为(unknown) < `JAN' < ... < `DEC'\n"

#: src/sort.c:420
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr "  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)\n"

#: src/sort.c:423
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           sort by random hash of keys\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort\t\t根据字符串数值比较\n"
"  -R, --random-sort\t\t根据随机hash 排序\n"
"      --random-source=文件\t从指定文件中获得随机字节\n"
"  -r, --reverse\t\t\t逆序输出排序结果\n"

#: src/sort.c:429
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=WORD\t\t按照WORD 指定的格式排序：\n"
"\t\t\t\t\t一般数字-g，高可读性-h，月份-M，数字-n，\n"
"\t\t\t\t\t随机-R，版本-V\n"
"  -V, --version-sort\t\t在文本内进行自然版本排序\n"
"\n"

#: src/sort.c:437
msgid ""
"Other options:\n"
"\n"
msgstr ""
"其他选项：\n"
"\n"

#: src/sort.c:441
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=NMERGE\t一次最多合并NMERGE 个输入；如果输入更多\n"
"\t\t\t\t\t则使用临时文件\n"

#: src/sort.c:445
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first\t检查输入是否已排序，若已有序则不进行操"
"作\n"
"  -C, --check=quiet, --check=silent\t类似-c，但不报告第一个无序行\n"
"      --compress-program=程序\t使用指定程序压缩临时文件；使用该程序\n"
"\t\t\t\t\t的-d 参数解压缩文件\n"

#: src/sort.c:452
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug\t\t\t为用于排序的行添加注释，并将有可能有问题的\n"
"\t\t\t\t\t用法输出到标准错误输出\n"
"      --files0-from=文件\t从指定文件读取以NUL 终止的名称，如果该文件被\n"
"\t\t\t\t\t指定为\"-\"则从标准输入读文件名\n"

#: src/sort.c:459
msgid ""
"  -k, --key=POS1[,POS2]     start a key at POS1 (origin 1), end it at POS2\n"
"                            (default end of line).  See POS syntax below\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=位置1[,位置2]\t在位置1 开始一个key，在位置2 终止(默认为行尾)\n"
"\t\t\t\t参看POS 语法。\n"
"  -m, --merge\t\t\t合并已排序的文件，不再进行排序\n"

#: src/sort.c:464
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=文件\t\t将结果写入到文件而非标准输出\n"
"  -s, --stable\t\t\t禁用last-resort 比较以稳定比较算法\n"
"  -S, --buffer-size=大小\t指定主内存缓存大小\n"

#: src/sort.c:470
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=分隔符\t使用指定的分隔符代替非空格到空格的转换\n"
"  -T, --temporary-directory=目录\t使用指定目录而非$TMPDIR 或%s 作为\n"
"\t\t\t\t\t临时目录，可用多个选项指定多个目录\n"
"      --parallel=N\t\t将同时运行的排序数改变为N\n"
"  -u, --unique\t\t配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n"

#: src/sort.c:479
msgid "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr "  -z, --zero-terminated\t以0 字节而非新行作为行尾标志\n"

#: src/sort.c:484
msgid ""
"\n"
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field; both are origin 1.  If neither -t nor -b is in effect, "
"characters\n"
"in a field are counted from the beginning of the preceding whitespace.  OPTS "
"is\n"
"one or more single-letter ordering options, which override global ordering\n"
"options for that key.  If no key is given, use the entire line as the key.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"POS 是F[.C][OPTS]，F 代表域编号，C 是域中字母的位置，F 和C 均从1开始计数\n"
"如果没有有效的-t 或-b 选项存在，则从前导空格后开始计数字符。OPTS 是一个或多"
"个\n"
"由单个字母表示的顺序选项，以此覆盖此key 的全局顺序设置。如果没有指定key 则\n"
"将其整个行。\n"
"\n"
"指定的大小可以使用以下单位之一：\n"

#: src/sort.c:496
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"内存使用率% 1%，b 1、K 1024 (默认)，M、G、T、P、E、Z、Y 等依此类推。\n"
"\n"
"如果不指定文件，或者文件为\"-\"，则从标准输入读取数据。\n"
"\n"
"*** 警告 ***\n"
"本地环境变量会影响排序结果。\n"
"如果希望以字节的自然值获得最传统的排序结果，请设置LC_ALL=C。\n"

#: src/sort.c:697
#, c-format
msgid "waiting for %s [-d]"
msgstr "等待 %s [-d]"

#: src/sort.c:702
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "%s [-d] 不正常结束"

#: src/sort.c:856 src/tac.c:458
#, c-format
msgid "cannot create temporary file in %s"
msgstr "无法在%s 创建临时文件"

#: src/sort.c:942 src/sort.c:1995 src/sort.c:3041 src/sort.c:3743
#: src/sort.c:3746
msgid "open failed"
msgstr "打开失败"

#: src/sort.c:962
msgid "fflush failed"
msgstr "冲洗流失败(fflush)"

#: src/sort.c:967 src/sort.c:1998 src/sort.c:4634
msgid "close failed"
msgstr "关闭失败"

#: src/sort.c:976
#, c-format
msgid "dup2 failed"
msgstr "复制已打开文件描述符失败(dup2)"

#: src/sort.c:1093
#, c-format
msgid "couldn't execute %s"
msgstr "无法执行%s"

#: src/sort.c:1100
msgid "couldn't create temporary file"
msgstr "无法创建临时文件"

#: src/sort.c:1139
#, c-format
msgid "couldn't create process for %s -d"
msgstr "无法创建进程%s -d"

#: src/sort.c:1153
#, c-format
msgid "couldn't execute %s -d"
msgstr "无法执行%s -d"

#: src/sort.c:1212
#, c-format
msgid "warning: cannot remove: %s"
msgstr "警告：无法删除：%s"

#: src/sort.c:1298
#, c-format
msgid "invalid --%s argument %s"
msgstr "无效的 --%s 参数%s"

#: src/sort.c:1301
#, c-format
msgid "minimum --%s argument is %s"
msgstr "最小 --%s 参数是%s"

#: src/sort.c:1316
#, c-format
msgid "--%s argument %s too large"
msgstr "--%s 参数%s 太长"

#: src/sort.c:1319
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "最大 --%s 参数在当前资源限制(rlimit)设置下是%s"

#: src/sort.c:1401
#, c-format
msgid "number in parallel must be nonzero"
msgstr "单个的数字必须不为零"

#: src/sort.c:1482
msgid "stat failed"
msgstr "获取文件状态失败(stat)"

#: src/sort.c:1743
msgid "read failed"
msgstr "读取失败"

#: src/sort.c:2013
#, c-format
msgid "string transformation failed"
msgstr "字符串转换失败"

#: src/sort.c:2016
#, c-format
msgid "the untransformed string was %s"
msgstr "未转换的字符串为%s"

#: src/sort.c:2179
#, c-format
msgid "^ no match for key\n"
msgstr "^ 没有匹配项\n"

#: src/sort.c:2359
#, c-format
msgid "obsolescent key `%s' used; consider `%s' instead"
msgstr "使用了旧的值%s，考虑转为使用%s"

#: src/sort.c:2365
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "值%lu 宽度为零，忽略"

#: src/sort.c:2376
#, c-format
msgid "leading blanks are significant in key %lu; consider also specifying `b'"
msgstr "值%lu 开头有大量空格，考虑同时指定\"b\""

#: src/sort.c:2389
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "值%lu 为数字且跨多个域"

#: src/sort.c:2421
#, c-format
msgid "option `-%s' is ignored"
msgid_plural "options `-%s' are ignored"
msgstr[0] "选项\"-%s\"被忽略"

#: src/sort.c:2427
#, c-format
msgid "option `-r' only applies to last-resort comparison"
msgstr "选项\"-r\" 仅用于last-resort 比较"

#: src/sort.c:2701 src/sort.c:2710
msgid "write failed"
msgstr "写入失败"

#: src/sort.c:2753
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s：%s:%s：无序： "

#: src/sort.c:2756
msgid "standard error"
msgstr "标准错误"

#: src/sort.c:3914
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s：无效的区块规格%s"

#: src/sort.c:3925
#, c-format
msgid "options `-%s' are incompatible"
msgstr "选项\"-%s\"不兼容"

#: src/sort.c:3976
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s：在%s 处的计数无效"

#: src/sort.c:4233
msgid "invalid number after `-'"
msgstr "在\"-\"后的编号无效"

#: src/sort.c:4236 src/sort.c:4322 src/sort.c:4350
msgid "invalid number after `.'"
msgstr "在\".\"后的编号无效"

#: src/sort.c:4249 src/sort.c:4355
msgid "stray character in field spec"
msgstr "区块中有孤立字符"

#: src/sort.c:4296
#, c-format
msgid "multiple compress programs specified"
msgstr "指定了多个压缩程序"

#: src/sort.c:4313
msgid "invalid number at field start"
msgstr "区块起始处的编号无效"

#: src/sort.c:4317 src/sort.c:4345
msgid "field number is zero"
msgstr "区块编号为零"

#: src/sort.c:4326
msgid "character offset is zero"
msgstr "字符偏移量为零"

#: src/sort.c:4341
msgid "invalid number after `,'"
msgstr "在\",\"后的编号无效"

#: src/sort.c:4391
#, c-format
msgid "empty tab"
msgstr "空标签"

#: src/sort.c:4484 src/wc.c:693
#, c-format
msgid "cannot read file names from %s"
msgstr "无法从%s 中读取文件名"

#: src/sort.c:4506
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "%s：%lu：无效的 0 长度文件名"

#: src/sort.c:4512
#, c-format
msgid "no input from %s"
msgstr "没有来自%s 的输入"

#: src/sort.c:4558
#, c-format
msgid "using %s sorting rules"
msgstr "使用%s 排序规则"

#: src/sort.c:4561
#, c-format
msgid "using simple byte comparison"
msgstr "使用简单字节比较"

#: src/sort.c:4592
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "不允许额外的操作数%s 与-%c 一起使用"

#: src/split.c:165
#, c-format
msgid "the suffix length needs to be at least %zu"
msgstr "后缀长度至少应为%zu"

#: src/split.c:182
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [PREFIX]]\n"
msgstr "用法：%s [选项]... [输入 [前缀]]\n"

#: src/split.c:186
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"size is 1000 lines, and default PREFIX is `x'.  With no INPUT, or when "
"INPUT\n"
"is -, read standard input.\n"
"\n"
msgstr ""
"将输入内容拆分为固定大小的分片并输出到\"前缀aa\"、\"前缀ab\",...；\n"
"默认以 1000 行为拆分单位，默认前缀为\"x\"。如果不指定文件，或\n"
"者文件为\"-\"，则从标准输入读取数据。\n"
"\n"

#: src/split.c:195
#, fuzzy, c-format
msgid ""
"  -a, --suffix-length=N   use suffixes of length N (default %d)\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -d, --numeric-suffixes  use numeric suffixes instead of alphabetic\n"
"  -e, --elide-empty-files  do not generate empty output files with `-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files.  See below\n"
"  -u, --unbuffered        immediately copy input to output with `-n r/...'\n"
msgstr ""
"  -a, --suffix-length=N\t指定后缀长度为N (默认为%d)\n"
"  -b, --bytes=大小\t\t指定每个输出文件的字节大小\n"
"  -C, --line-bytes=大小\t指定每个输出文件里最大行字节大小\n"
"  -d, --numeric-suffixes \t使用数字后缀代替字母后缀\n"
"  -e, --elide-empty-files\t和-n 一起使用时不生成空的输出文件\n"
"  -l, --lines=数值\t\t指定每个输出文件有多少行\n"
"  -n, --number=块数\t\t生成块数输出文件。参看下面的说明。\n"
"  -u, --unbuffered\t\t立即使用-n r/... 复制输入到输出\n"

#: src/split.c:206
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr "      --verbose\t\t在每个输出文件打开前输出文件特征\n"

#: src/split.c:213
msgid ""
"\n"
"CHUNKS may be:\n"
"N       split into N files based on size of input\n"
"K/N     output Kth of N to stdout\n"
"l/N     split into N files without splitting lines\n"
"l/K/N   output Kth of N to stdout without splitting lines\n"
"r/N     like `l' but use round robin distribution\n"
"r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""
"\n"
"块数可能为：\n"
"N\t基于输入的大小分割为N 个文件\n"
"K/N\t将N 个文件中的第K 个输出到标准输出\n"
"l/N\t分割为N 个文件，但分割时不切断行\n"
"l/K/N\t将N 个文件中的第K 个输出到标准输出，但分割时不切断行\n"
"r/N\t类似l 但使用轮询分配\n"
"r/K/N\t类似r/N 但尽将N 个文件中的第K 个输出到标准输出\n"

#: src/split.c:279
#, c-format
msgid "output file suffixes exhausted"
msgstr "已排除输出文件后缀"

#: src/split.c:291
#, c-format
msgid "creating file %s\n"
msgstr "正在创建文件%s\n"

#: src/split.c:304
#, fuzzy, c-format
msgid "failed to set FILE environment variable"
msgstr "更新%s 的环境失败"

#: src/split.c:306
#, c-format
msgid "executing with FILE=%s\n"
msgstr ""

#: src/split.c:308
#, fuzzy, c-format
msgid "failed to create pipe"
msgstr "无法创建硬链接%s"

#: src/split.c:322
#, fuzzy, c-format
msgid "closing prior pipe"
msgstr "关闭目录%s"

#: src/split.c:324
#, fuzzy, c-format
msgid "closing output pipe"
msgstr "正在关闭输出文件%s"

#: src/split.c:328
#, fuzzy, c-format
msgid "moving input pipe"
msgstr "正在关闭输入文件%s"

#: src/split.c:330
#, fuzzy, c-format
msgid "closing input pipe"
msgstr "正在关闭输入文件%s"

#: src/split.c:335
#, fuzzy, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr "无法运行命令%s"

#: src/split.c:341
#, fuzzy, c-format
msgid "failed to close input pipe"
msgstr "关闭目录 %s 失败"

#: src/split.c:377
#, fuzzy, c-format
msgid "waiting for child process"
msgstr "等待拆解"

#: src/split.c:387
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr ""

#: src/split.c:395
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr ""

#: src/split.c:402 src/timeout.c:447
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "来自命令的未知状态 (0x%X)"

#: src/split.c:964
#, c-format
msgid "cannot split in more than one way"
msgstr "无法以多于一种的方式切分输入"

#: src/split.c:977 src/split.c:1108 src/split.c:1245
#, c-format
msgid "%s: invalid number of chunks"
msgstr "%s：无效的块数"

#: src/split.c:981
#, c-format
msgid "%s: invalid chunk number"
msgstr "%s：无效块数"

#: src/split.c:1033
#, c-format
msgid "%s: invalid suffix length"
msgstr "%s：文件类型无效"

#: src/split.c:1047 src/split.c:1055 src/split.c:1078 src/split.c:1083
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s：无效的字节数"

#: src/split.c:1066 src/split.c:1196
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s：无效的行数"

#: src/split.c:1139
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "行数选项-%s%c... 过大"

#: src/split.c:1162
#, c-format
msgid "%s: invalid IO block size"
msgstr "%s：无效的IO 块大小"

#: src/split.c:1183
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr ""

#: src/split.c:1238
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s：无法确定文件大小"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:169
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:824
#, c-format
msgid "failed to canonicalize %s"
msgstr "标准化%s 失败"

#: src/stat.c:1036
#, c-format
msgid "warning: unrecognized escape `\\%c'"
msgstr "警告：无法识别的转义字符\"\\%c\""

#: src/stat.c:1091
#, c-format
msgid "%s: invalid directive"
msgstr "%s：无效指令"

#: src/stat.c:1137
#, c-format
msgid "warning: backslash at end of format"
msgstr "警告：格式末尾出现反斜杠"

#: src/stat.c:1168
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr "用 %s 进行标准输入在文件系统模式下无法工作"

#: src/stat.c:1175
#, c-format
msgid "cannot read file system information for %s"
msgstr "无法为 %s 读取文件系统信息"

#: src/stat.c:1195
#, c-format
msgid "cannot stat standard input"
msgstr "无法从标准输入获取文件信息(stat)"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1231
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""
"  文件：\"%n\"\n"
"    ID：%-8i 文件名长度：%-7l 类型：%T\n"
"块大小：%-10s 基本块大小：%S\n"
"    块：总计：%-10b 空闲：%-10f 可用：%a\n"
"Inodes: 总计：%-10c 空闲：%d\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1256
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""
"  文件：%N\n"
"  大小：%-10s\t块：%-10b IO 块：%-6o %F\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1266
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %-5h Device type: %t,%T\n"
msgstr "设备：%Dh/%dd\tInode：%-10i  硬链接：%-5h 设备类型：%t,%T\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1274
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
msgstr "设备：%Dh/%dd\tInode：%-10i  硬链接：%h\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1283
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr "权限：(%04a/%10.10A)  Uid：(%5u/%8U)   Gid：(%5g/%8G)\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1293
#, c-format
msgid "Context: %C\n"
msgstr "环境：%C\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1302
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""
"最近访问：%x\n"
"最近更改：%y\n"
"最近改动：%z\n"
"创建时间：%w\n"

#: src/stat.c:1323
msgid ""
"Display file or file system status.\n"
"\n"
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"显示文件或文件系统的状态。\n"
"\n"
"  -L, --dereference\t跟随链接\n"
"  -f, --file-system\t显示文件系统状态而非文件状态\n"

#: src/stat.c:1329
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline.\n"
"                          If you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c --format=格式\t使用指定输出格式代替默认值，每用一次指定格式换一新行\n"
"      --printf=格式\t类似 --format，但是会解释反斜杠转义符，不使用换行作\n"
"\t\t\t\t输出结尾。如果您仍希望使用换行，可以在格式中\n"
"\t\t\t\t加入\"\\n\"\n"
"  -t, --terse\t\t使用简洁格式输出\n"

#: src/stat.c:1340
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   Access rights in octal\n"
"  %A   Access rights in human readable form\n"
"  %b   Number of blocks allocated (see %B)\n"
"  %B   The size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"有效的文件格式序列(不使用 --file-system)：\n"
"\n"
"  %a\t八进制权限\n"
"  %A   用可读性较好的方式输出权限\n"
"  %b   计算已分配块数(参见%B)\n"
"  %B   以字节为单位输出%b 所报告的每个块的大小\n"
"  %C   SELinux 安全环境字符串\n"

#: src/stat.c:1349
msgid ""
"  %d   Device number in decimal\n"
"  %D   Device number in hex\n"
"  %f   Raw mode in hex\n"
"  %F   File type\n"
"  %g   Group ID of owner\n"
"  %G   Group name of owner\n"
msgstr ""
"  %d\t十进制设备编号\n"
"  %D\t十六进制设备编号\n"
"  %f\t十六进制原始模式\n"
"  %F\t文件类型\n"
"  %g\t文件的属组ID\n"
"  %G\t文件的属组组名\n"

#: src/stat.c:1357
msgid ""
"  %h   Number of hard links\n"
"  %i   Inode number\n"
"  %m   Mount point\n"
"  %n   File name\n"
"  %N   Quoted file name with dereference if symbolic link\n"
"  %o   I/O block size\n"
"  %s   Total size, in bytes\n"
"  %t   Major device type in hex\n"
"  %T   Minor device type in hex\n"
msgstr ""
"  %h\t硬链接数量\n"
"  %i\tInode 编号\n"
"  %m\t挂载点\n"
"  %n\t文件名\n"
"  %N\t如果对象是一个符号链接，显示引用到的其它文件名\n"
"  %o\tI/O 块大小\n"
"  %s\t总计大小，以字节为单位\n"
"  %t\t十六进制主设备类型\n"
"  %T\t十六进制子设备类型\n"

#: src/stat.c:1368
msgid ""
"  %u   User ID of owner\n"
"  %U   User name of owner\n"
"  %w   Time of file birth, human-readable; - if unknown\n"
"  %W   Time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   Time of last access, human-readable\n"
"  %X   Time of last access, seconds since Epoch\n"
"  %y   Time of last modification, human-readable\n"
"  %Y   Time of last modification, seconds since Epoch\n"
"  %z   Time of last change, human-readable\n"
"  %Z   Time of last change, seconds since Epoch\n"
"\n"
msgstr ""
"  %u\t文件的属主ID\n"
"  %U\t文件的属主用户名\n"
"  %w\t文件创建时间，若未知则显示\"-\"\n"
"  %W\t从UNIX 元年起以秒计的文件创建时间，若未知则显示\"-\"\n"
"  %x\t上次访问时间\n"
"  %X\t从UNIX 元年起以秒计的上次访问时间\n"
"  %y\t上次修改时间\n"
"  %Y\t从UNIX 元年起以秒计的上次修改时间\n"
"  %z\t上次更改时间\n"
"  %Z\t从UNIX 元年起以秒计的上次更改时间\n"
"\n"

#: src/stat.c:1382
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   Free blocks available to non-superuser\n"
"  %b   Total data blocks in file system\n"
"  %c   Total file nodes in file system\n"
"  %d   Free file nodes in file system\n"
"  %f   Free blocks in file system\n"
msgstr ""
"有效的文件系统格式序列：\n"
"\n"
"  %a\t非超级用户可用的剩余块数\n"
"  %b\t文件系统的总数据块数\n"
"  %c\t文件系统中文件节点总数\n"
"  %d\t文件系统中空闲文件节点数\n"
"  %f\t文件系统中空闲块数\n"

#: src/stat.c:1391
msgid ""
"  %i   File System ID in hex\n"
"  %l   Maximum length of filenames\n"
"  %n   File name\n"
"  %s   Block size (for faster transfers)\n"
"  %S   Fundamental block size (for block counts)\n"
"  %t   Type in hex\n"
"  %T   Type in human readable form\n"
msgstr ""
"  %i\t十六进制文件系统ID\n"
"  %I\t允许的文件名最大长度\n"
"  %n\t文件名\n"
"  %s\t块大小(用于快速传输)\n"
"  %S\t基本块大小(用于块计数)\n"
"  %t\t十六进制类型描述\n"
"  %T\t可读性较好的类型描述\n"

#: src/stdbuf.c:91
#, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "用法：%s [选项]... 命令\n"

#: src/stdbuf.c:92
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
"\n"
msgstr ""
"运行标准流缓冲区操作已改变的 COMMAND。\n"
"\n"

#: src/stdbuf.c:99
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""
"  -i, --input=MODE   调整标准输入流缓冲区\n"
"  -o, --output=MODE  调整标准输出流缓冲区\n"
"  -e, --error=MODE   调整标准错误流缓冲区\n"

#: src/stdbuf.c:106
msgid ""
"\n"
"If MODE is `L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""
"\n"
"若 MODE 是 L，则相应的流将是行缓冲模式。\n"
"标准输入流下此选项无效。\n"

#: src/stdbuf.c:109
msgid ""
"\n"
"If MODE is `0' the corresponding stream will be unbuffered.\n"
msgstr ""
"\n"
"若 MODE 是 0，则相应的流将不缓冲。\n"

#: src/stdbuf.c:112
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"否则 MODE 就应该是以下数字单位中的一个：\n"
"KB 1000，K 1024，MB 1000*1000，M 1024*1024，以及 G、T、P、E、Z、Y。\n"
"在此情况下，相应的流将缓冲由 MODE 指定大小的缓冲字节。\n"
"\n"

#: src/stdbuf.c:118
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams (`tee' does\n"
"for e.g.) then that will override corresponding settings changed by "
"`stdbuf'.\n"
"Also some filters (like `dd' and `cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by `stdbuf' settings.\n"
msgstr ""
"\n"
"注意：若 COMMAND 调整其自身的标准流缓冲区(如 tee 就是)，\n"
"则此操作会覆盖由stdbuf 所做出的相应设置。\n"
"还有某些滤件程序(如dd 和cat 之类)，它们不使用输入输出流，\n"
"因此不受stdbuf 设置的影响。\n"

#: src/stdbuf.c:228
#, c-format
msgid "failed to find %s"
msgstr "查找%s 失败"

#: src/stdbuf.c:248 src/stdbuf.c:280
#, c-format
msgid "failed to update the environment with %s"
msgstr "更新%s 的环境失败"

#: src/stdbuf.c:322
#, c-format
msgid "line buffering stdin is meaningless"
msgstr "对标准输入进行行缓冲无意义"

#: src/stty.c:510
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"用法：%s [-F 设备 | --file=设备] [设置]...\n"
"　或：%s [-F 设备 | --file=设备] [-a|--all]\n"
"　或：%s [-F 设备 | --file=设备] [-g|--save]\n"

#: src/stty.c:516
msgid ""
"Print or change terminal characteristics.\n"
"\n"
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"输出或修改终端参数。\n"
"\n"
"  -a, --all\t\t以可读性较好的方式输出全部当前设置\n"
"  -g, --save\t\t以stty 可读取的格式输出当前全部设置\n"
"  -F, --file=设备\t打开并使用指定设备代替标准输入\n"

#: src/stty.c:525
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"可选- 在设置前的指示中，* 标记出了非POSIX 标准的设置。以下系\n"
"统定义象征了哪些设置是有效的。\n"

#: src/stty.c:530
msgid ""
"\n"
"Special characters:\n"
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"\n"
"特殊字符：\n"
" * dsusp 字符\t每当输入刷新时会发送一个用于终端阻塞信号的字符\n"
"   eof\t字符\t表示文件末尾而发送的字符(用于终止输入)\n"
"   eol\t字符\t为表示行尾而发送的字符\n"

#: src/stty.c:537
msgid ""
" * eol2 CHAR     alternate CHAR for ending the line\n"
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
" * eol2 字符\t为表示行尾而发送的另一个可选字符\n"
"   erase 字符\t擦除前一个输入文字的字符\n"
"   intr 字符\t用于发送中断信号的字符\n"
"   kill 字符\t用于擦除当前终端行的字符\n"

#: src/stty.c:543
msgid ""
" * lnext CHAR    CHAR will enter the next character quoted\n"
"   quit CHAR     CHAR will send a quit signal\n"
" * rprnt CHAR    CHAR will redraw the current line\n"
"   start CHAR    CHAR will restart the output after stopping it\n"
msgstr ""
" * lnext 字符\t用于输入下一个引用文字的字符\n"
"   quit 字符\t用于发送退出信号的字符\n"
" * rprnt 字符\t用于重绘当前行的字符\n"
"   start 字符\t在停止后重新开启输出的字符\n"

#: src/stty.c:549
msgid ""
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
" * swtch CHAR    CHAR will switch to a different shell layer\n"
" * werase CHAR   CHAR will erase the last word typed\n"
msgstr ""
"   stop 字符\t停止输出的字符\n"
"   susp 字符\t发送终端阻断信号的字符\n"
" * swtch 字符\t在不同的shell 层次间切换的字符\n"
" * werase 字符\t擦除前一个输入的单词的字符\n"

#: src/stty.c:555
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
"\n"
"特殊设置：\n"
"   N\t\t设置输入输出速度为N 波特\n"
" * cols N\t统治内核终端上有N 栏\n"
" * columns N\t等于cols N\n"

#: src/stty.c:562
msgid ""
"   ispeed N      set the input speed to N\n"
" * line N        use line discipline N\n"
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"   ispeed N\t设置输入速度为N 波特\n"
" * line N\t设置行约束规则为N\n"
"   min N\t和 -icanon 配合使用，设置每次一完整读入的最小字符数为<N>\n"
"   ospeed N\t设置输出速度为N 波特\n"

#: src/stty.c:568
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
" * rows N\t向内核通告此终端有N 行\n"
" * size\t根据内核信息输出当前终端的行数和列数\n"
"   speed\t输出终端速度(单位为波特)\n"
"   time N\t和-icanon 配合使用，设置读取超时为N 个十分之一秒\n"

#: src/stty.c:574
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
" * [-]crtscts    enable RTS/CTS handshaking\n"
"   csN           set character size to N bits, N in [5..8]\n"
msgstr ""
"\n"
"控制设置：\n"
"   [-]clocal\t禁用调制解调器控制信号\n"
"   [-]cread\t允许接收输入\n"
" * [-]crtscts\t启用RTS/CTS 握手\n"
"   csN\t\t设置字符大小为N 位，N 的范围为5 到8\n"

#: src/stty.c:582
msgid ""
"   [-]cstopb     use two stop bits per character (one with `-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (even with `-')\n"
msgstr ""
"   [-]cstopb\t每个字符使用2 位停止位 (要恢复成1 位配合\"-\"即可)\n"
"   [-]hup\t当最后一个进程关闭标准终端后发送挂起信号\n"
"   [-]hupcl\t等于[-]hup\n"
"   [-]parenb\t对输出生成奇偶校验位并等待输入的奇偶校验位\n"
"   [-]parodd\t设置校验位为奇数 (配合\"-\"则为偶数)\n"

#: src/stty.c:589
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
msgstr ""
"\n"
"输入设置：\n"
"   [-]brkint\t任务中断会触发中断信号\n"
"   [-]icrnl\t将回车转换为换行符\n"
"   [-]ignbrk\t忽略中断字符\n"
"   [-]igncr\t忽略回车\n"

#: src/stty.c:597
msgid ""
"   [-]ignpar     ignore characters with parity errors\n"
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"   [-]ignpar\t忽略含有奇偶不对称错误的字符\n"
" * [-]imaxbel\t发出终端响铃但不刷新字符的完整输入缓冲\n"
"   [-]inlcr\t将换行符转换为回车\n"
"   [-]inpck\t启用输入奇偶性校验\n"
"   [-]istrip\t剥除输入字符的高8 位比特\n"

#: src/stty.c:604
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr " * [-]iutf8\t假定输入字符都是UTF-8 编码\n"

#: src/stty.c:607
msgid ""
" * [-]iuclc      translate uppercase characters to lowercase\n"
" * [-]ixany      let any character restart output, not only start character\n"
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
" * [-]iuclc\t将大写字母转换为小写\n"
" * [-]ixany\t使得任何字符都会重启输出，不仅仅是起始字符\n"
"   [-]ixoff\t启用开始/停止字符传送\n"
"   [-]ixon\t启用XON/XOFF 流控制\n"
"   [-]parmrk\t标记奇偶校验错误 (结合255-0 字符序列)\n"
"   [-]tandem\t等于[-]ixoff\n"

#: src/stty.c:615
msgid ""
"\n"
"Output settings:\n"
" * bsN           backspace delay style, N in [0..1]\n"
" * crN           carriage return delay style, N in [0..3]\n"
" * ffN           form feed delay style, N in [0..1]\n"
" * nlN           newline delay style, N in [0..1]\n"
msgstr ""
"\n"
"输出设置：\n"
" * bsN\t\t退格延迟的风格，N 的值为0 至1\n"
" * crN\t\t回车延迟的风格，N 的值为0 至3\n"
" * ffN\t\t换页延迟的风格，N 的值为0 至1\n"
" * nlN\t\t换行延迟的风格，N 的值为0 至1\n"

#: src/stty.c:623
msgid ""
" * [-]ocrnl      translate carriage return to newline\n"
" * [-]ofdel      use delete characters for fill instead of null characters\n"
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
" * [-]olcuc      translate lowercase characters to uppercase\n"
" * [-]onlcr      translate newline to carriage return-newline\n"
" * [-]onlret     newline performs a carriage return\n"
msgstr ""
" * [-]ocrnl\t将回车转换为换行符\n"
" * [-]ofdel\t使用删除字符代替空字符作填充\n"
" * [-]ofill\t延迟时使用字符填充代替定时器同步\n"
" * [-]olcuc\t转换小写字母为大写\n"
" * [-]onlcr\t将换行符转换为回车\n"
" * [-]onlret\t使得换行符的行为表现和回车相同\n"

#: src/stty.c:631
msgid ""
" * [-]onocr      do not print carriage returns in the first column\n"
"   [-]opost      postprocess output\n"
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
" * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""
" * [-]onocr\t不在第一列输出回车\n"
"   [-]opost\t后续进程输出\n"
" * tabN\t水平制表符延迟的风格，N 的值为0 至3\n"
" * tabs\t等于tab0\n"
" * -tabs\t等于tab3\n"
" * vtN\t\t垂直制表符延迟的风格，N 的值为0 至1\n"

#: src/stty.c:639
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
"\n"
"本地设置：\n"
"   [-]crterase\t擦除字符回显为退格符\n"
" * crtkill\t依照echoprt 和echoe 的设置清除所有行\n"
" * -crtkill\t依照echoctl 和echol 的设置清除所有行\n"

#: src/stty.c:646
msgid ""
" * [-]ctlecho    echo control characters in hat notation (`^c')\n"
"   [-]echo       echo input characters\n"
" * [-]echoctl    same as [-]ctlecho\n"
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""
" * [-]ctlecho\t在头字符中输出控制符号(\"^c\")\n"
"   [-]echo\t回显输入字符\n"
" * [-]echoctl\t等于[-]ctlecho\n"
"   [-]echoe    等于[-]crterase\n"
"   [-]echok\t在每清除一个字符后输出一次换行\n"

#: src/stty.c:653
msgid ""
" * [-]echoke     same as [-]crtkill\n"
"   [-]echonl     echo newline even if not echoing other characters\n"
" * [-]echoprt    echo erased characters backward, between `\\' and '/'\n"
"   [-]icanon     enable erase, kill, werase, and rprnt special characters\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
" * [-]echoke\t等于[-]crtkill 意义相同\n"
"   [-]echonl\t即使没有回显任何其它字符也输出换行\n"
" * [-]echoprt\t在\"\\\"和\"/\"之间向后显示擦除的字符\n"
"   [-]icanon\t启用erase、kill、werase 和rprnt 等特殊字符\n"
"   [-]iexten\t允许POSIX 标准以外的特殊字符\n"

#: src/stty.c:660
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
" * [-]prterase   same as [-]echoprt\n"
" * [-]tostop     stop background jobs that try to write to the terminal\n"
" * [-]xcase      with icanon, escape with `\\' for uppercase characters\n"
msgstr ""
"   [-]isig\t启用interrupt、quit和suspend 等特殊字符\n"
"   [-]noflsh\t在interrupt 和 quit 特殊字符后禁止刷新\n"
" * [-]prterase\t等于[-]echoprt\n"
" * [-]tostop\t中止尝试向终端写入数据的后台任务\n"
" * [-]xcase\t和icanon 配合使用，用转义符\"\\\"退出大写状态\n"

#: src/stty.c:667
msgid ""
"\n"
"Combination settings:\n"
" * [-]LCASE      same as [-]lcase\n"
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"\n"
"综合设置：\n"
" * [-]LCASE\t等于[-]lcase\n"
"   cbreak\t等于-icanon\n"
"   -cbreak\t等于icanon\n"

#: src/stty.c:674
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
"   crt           same as echoe echoctl echoke\n"
msgstr ""
"   cooked\t等于brkint ignpar istrip icrnl ixon opost isig icanon eof \t\t"
"\teol 等的默认值\n"
"   -cooked\t等于-raw\n"
"   crt\t\t等于echoe echoctl echoke\n"

#: src/stty.c:680
msgid ""
"   dec           same as echoe echoctl echoke -ixany intr ^c erase 0177\n"
"                 kill ^u\n"
" * [-]decctlq    same as [-]ixany\n"
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
msgstr ""
"   dec\t\t等于echoe echoctl echoke -ixany intr ^c erase 0177 kill ^u\n"
" * [-]decctlq\t等于[-]ixany\n"
"   ek\t\t清除所有字符，将它们回溯为默认值\n"
"   evenp\t等于parenb -parodd cs7\n"

#: src/stty.c:687
msgid ""
"   -evenp        same as -parenb cs8\n"
" * [-]lcase      same as xcase iuclc olcuc\n"
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
"   nl            same as -icrnl -onlcr\n"
"   -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
msgstr ""
"   -evenp\t等于-parenb cs8\n"
" * [-]lcase\t等于xcase iuclc olcuc\n"
"   litout\t等于-parenb -istrip -opost cs8\n"
"   -litout\t等于parenb istrip opost cs7\n"
"   nl\t\t等于-icrnl -onlcr\n"
"   -nl\t\t等于icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"

#: src/stty.c:695
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"   oddp\t等于parenb parodd cs7\n"
"   -oddp\t等于-parenb cs8\n"
"   [-]parity\t等于[-]evenp\n"
"   pass8\t等于-parenb -istrip cs8\n"
"   -pass8\t等于parenb istrip cs7\n"

#: src/stty.c:702
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
"                 -imaxbel -opost -isig -icanon -xcase min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"   raw\t\t等于-ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -iuclc -ixany\n"
"                 -imaxbel -opost -isig -icanon -xcase min 1 time 0\n"
"   -raw\t等于cooked\n"

#: src/stty.c:708
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl -iutf8\n"
"                 -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"                 -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"                 isig icanon iexten echo echoe echok -echonl -noflsh\n"
"                 -xcase -tostop -echoprt echoctl echoke, all special\n"
"                 characters to their default values\n"
msgstr ""
"   sane\t等于cread -ignbrk brkint -inlcr -igncr icrnl -iutf8\n"
"\t\t-ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"\t\t-onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"\t\tisig icanon iexten echo echoe echok -echonl -noflsh\n"
"\t\t-xcase -tostop -echoprt echoctl echoke，所有特殊字符均\n"
"\t\t使用默认值\n"

#: src/stty.c:716
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"处理连接到标准输入的tty 终端行设置。当不附加参数时，程序会输出波特率、行约"
"束\n"
"规则以及与标准stty 设置间的偏差。在设置中，字符会被逐字读取或是被编码为^c、\n"
"0x37、0177 或127 这样的字符，其中有特殊值^- 或undef 被用于禁止特殊字符。\n"

#: src/stty.c:788
#, c-format
msgid "only one device may be specified"
msgstr "只能指定一个设备"

#: src/stty.c:818
#, c-format
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr "verbose 和 stty-readable 两种输入风格的选项是互相抵触的"

#: src/stty.c:824
#, c-format
msgid "when specifying an output style, modes may not be set"
msgstr "当指定了输出风格时，模式不能再被设置"

#: src/stty.c:839
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s：无法重置非阻塞模式"

#: src/stty.c:884 src/stty.c:994
#, c-format
msgid "invalid argument %s"
msgstr "无效的参数 %s"

#: src/stty.c:895 src/stty.c:912 src/stty.c:924 src/stty.c:937 src/stty.c:949
#: src/stty.c:969
#, c-format
msgid "missing argument to %s"
msgstr "缺少%s 的参数"

#: src/stty.c:975
#, c-format
msgid "invalid line discipline %s"
msgstr "无效的行约束%s"

#: src/stty.c:1045
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s：无法执行所有请求的操作"

#: src/stty.c:1391
#, c-format
msgid "%s: no size information for this device"
msgstr "%s：此设备没有大小信息"

#: src/stty.c:1905
#, c-format
msgid "invalid integer argument %s"
msgstr "无效的整数参数%s"

#: src/su.c:226
msgid "Password:"
msgstr "密码："

#: src/su.c:229
#, c-format
msgid "getpass: cannot open /dev/tty"
msgstr "getpass：无法打开 /dev/tty"

#: src/su.c:287
#, c-format
msgid "cannot set groups"
msgstr "无法设置组"

#: src/su.c:291
#, c-format
msgid "cannot set group id"
msgstr "无法设置组ID"

#: src/su.c:293
#, c-format
msgid "cannot set user id"
msgstr "无法设置用户ID"

#: src/su.c:369
#, c-format
msgid "Usage: %s [OPTION]... [-] [USER [ARG]...]\n"
msgstr "用法：%s [选项]... [-] [用户 [参数]... ]\n"

#: src/su.c:370
msgid ""
"Change the effective user id and group id to that of USER.\n"
"\n"
"  -, -l, --login               make the shell a login shell\n"
"  -c, --command=COMMAND        pass a single COMMAND to the shell with -c\n"
"  -f, --fast                   pass -f to the shell (for csh or tcsh)\n"
"  -m, --preserve-environment   do not reset environment variables\n"
"  -p                           same as -m\n"
"  -s, --shell=SHELL            run SHELL if /etc/shells allows it\n"
msgstr ""
"更改有效用户ID 和组ID 为指定用户。\n"
"\n"
"  -, -l, --login\t\t使该shell 成为登录shell\n"
"  -c, --command=命令\t\t向shell 传递单一命令\n"
"  -f, --fast                   针对csh 或tcsh 传递-f\n"
"  -m, --preserve-environment\t不重设环境变量\n"
"  -p\t\t\t\t等于-m\n"
"  -s, --shell=SHELL\t\t如果/etc/shells allows 则运行指定的SHELL\n"

#: src/su.c:382
msgid ""
"\n"
"A mere - implies -l.   If USER not given, assume root.\n"
msgstr ""
"\n"
"单独的\"-\"选项隐含了-l。如果不指定用户，则假设其为root。\n"

#: src/su.c:459
#, c-format
msgid "user %s does not exist"
msgstr "用户%s 不存在"

#: src/su.c:482
#, c-format
msgid "incorrect password"
msgstr "密码不正确"

#: src/su.c:499
#, c-format
msgid "using restricted shell %s"
msgstr "正在使用受限的shell %s"

#: src/su.c:507
#, c-format
msgid "warning: cannot change directory to %s"
msgstr "警告：无法切换到目录%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:38
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:64
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"为每个指定的文件输出校验和以及块计数。\n"
"\n"
"  -r\t\t使用BSD 加和算法，以1 KB 为一个块\n"
"  -s, --sysv\t使用System V 加和算法，以51双字节为一个块\n"

#: src/sync.c:42
msgid ""
"Force changed blocks to disk, update the super block.\n"
"\n"
msgstr ""
"强迫将已更改的数据写入磁盘，并更新超级块。\n"
"\n"

#: src/sync.c:70
#, c-format
msgid "ignoring all arguments"
msgstr "忽略任何参数"

#: src/system.h:323
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"注意：您的shell 内含自己的%s 程序版本，它会覆盖这里所提及的相应\n"
"版本。请查阅您的shell 文档获知它所支持的选项。\n"

#: src/system.h:329
msgid "      --help     display this help and exit\n"
msgstr "      --help\t\t显示此帮助信息并退出\n"

#: src/system.h:331
msgid "      --version  output version information and exit\n"
msgstr "      --version\t\t显示版本信息并退出\n"

#: src/system.h:503
msgid ""
"\n"
"SIZE may be (or may be an integer optionally followed by) one of following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
msgstr ""
"\n"
"SIZE 可以是一个可选的整数，后面跟着以下单位中的一个：\n"
"KB 1000，K 1024，MB 1000*1000，M 1024*1024，还有 G、T、P、E、Z、Y。\n"

#: src/system.h:512
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""
"\n"
"所显示的数值是来自 --block-size、%s_BLOCK_SIZE、BLOCK_SIZE \n"
"及 BLOCKSIZE 环境变量中第一个可用的 SIZE 单位。\n"
"否则，默认单位是 1024 字节(或是 512，若设定 POSIXLY_CORRECT 的话)。\n"

#: src/system.h:522
#, c-format
msgid ""
"\n"
"Report %s bugs to %s\n"
msgstr ""
"\n"
"请向%2$s 报告%1$s 的错误\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <http://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at http://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:536
#, c-format
msgid "Report %s translation bugs to <http://translationproject.org/team/>\n"
msgstr ""
"请向<http://translationproject.org/team/zh_CN.html> 报告%s 的翻译错误\n"

#: src/system.h:540
#, c-format
msgid "For complete documentation, run: info coreutils '%s invocation'\n"
msgstr "要获取完整文档，请运行：info coreutils '%s invocation'\n"

#: src/system.h:565
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"警告：发现循环的目录架构。\n"
"这几乎可以肯定文件系统已经损坏。\n"
"** 请通知系统管理员。**\n"
"以下的目录是循环的一部份：\n"
"  %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:137
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"将每个指定文件按行倒置并写到标准输出。\n"
"如果不指定文件，或文件为\"-\"，则从标准输入读取数据。\n"
"\n"

#: src/tac.c:145
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before\t\t\t在行前而非行尾添加分隔标志\n"
"  -r, --regex\t\t\t将分隔标志视作正则表达式来解析\n"
"  -s, --separator=字符串\t使用指定字符串代替换行作为分隔标志\n"

#: src/tac.c:235 src/tac.c:336
#, c-format
msgid "%s: seek failed"
msgstr "%s：检索失败"

#: src/tac.c:264
#, c-format
msgid "record too large"
msgstr "记录数据过大"

#: src/tac.c:466 src/truncate.c:376
#, c-format
msgid "cannot open %s for writing"
msgstr "无法打开%s 读取数据"

#: src/tac.c:487 src/tac.c:494
#, c-format
msgid "%s: write error"
msgstr "%s：写入出错"

#: src/tac.c:601
#, c-format
msgid "separator cannot be empty"
msgstr "分隔符不能为空"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:70
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:262
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"显示每个指定文件的最后%d 行到标准输出。\n"
"若指定了多于一个文件，程序会在每段输出的开始添加相应文件名作为头。\n"
"如果不指定文件或文件为\"-\" ，则从标准输入读取数据。\n"
"\n"

#: src/tail.c:271
msgid ""
"  -c, --bytes=K            output the last K bytes; alternatively, use -c "
"+K\n"
"                           to output bytes starting with the Kth of each "
"file\n"
msgstr ""
"  -c, --bytes=K\t\t输出最后K 字节；另外，使用-c +K 从每个文件的\n"
"\t\t\t第K 字节输出\n"

#: src/tail.c:275
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                           -f, --follow, and --follow=descriptor are\n"
"                           equivalent\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"\t\t即时输出文件变化后追加的数据。\n"
"\t\t\t-f, --follow 等于--follow=descriptor \n"
"  -F\t\t即--follow=name --retry\n"

#: src/tail.c:282
#, c-format
msgid ""
"  -n, --lines=K            output the last K lines, instead of the last %d;\n"
"                           or use -n +K to output lines starting with the "
"Kth\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                           changed size after N (default %d) iterations\n"
"                           to see if it has been unlinked or renamed\n"
"                           (this is the usual case of rotated log files).\n"
"                           With inotify, this option is rarely useful.\n"
msgstr ""
"  -n, --lines=K\t输出最后K 行，代替最后%d 行；使用-n +K 从每个文件的第K 字节"
"输出\n"
"      --max-unchanged-stats=N\n"
"\t\t\t使用--follow=name, 重新打开一个在N(默认为%d)\n"
"\t\t\t\t次迭代后没有改变大小的文件来看它是否被解除连\n"
"\t\t\t\t接或重命名(这是循环日志文件的通常情况)。\n"
"\t\t\t\t由于有inotify，这个选项很少使用。\n"

#: src/tail.c:295
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file even when it is or\n"
"                             becomes inaccessible; useful when following by\n"
"                             name, i.e., with --follow=name\n"
msgstr ""
"      --pid=PID\t\t同 -f 一起使用，当 PID 所对应的进程死去后终止\n"
"  -q, --quiet, --silent\t不输出给出文件名的头\n"
"      --retry\t\t即使目标文件不可访问依然试图打开；在与参数\n"
"\t\t\t--follow=name 同时使用时常常有用。\n"

#: src/tail.c:302
#, fuzzy
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations.\n"
"                             With inotify and --pid=P, check process P at\n"
"                             least once every N seconds.\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=秒数\t同-f 一起使用，在迭代间暂停约指定秒数的时间\n"
"\t\t\t\t(默认1.0 秒)\n"
"  -v, --verbose\t\t总是输出给出文件名的头\n"

#: src/tail.c:311
msgid ""
"\n"
"If the first character of K (the number of bytes or lines) is a `+',\n"
"print beginning with the Kth item from the start of each file, otherwise,\n"
"print the last K items in the file.  K may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
msgstr ""
"\n"
"如果字节数或行数K 的第一个字符是\"+\"，输出从文件开始第K 个项目，否则输出文"
"件\n"
"最后K 个项目。K 可以使用一下几种单位之一：\n"
"b 512，kB 1000，K 1024，MB 1000*1000，M 1024*1024,\n"
"GB 1000*1000*1000，G 1024*1024*1024，以及T，P，E，Z，Y。\n"
"\n"

#: src/tail.c:320
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"如果您希望即时追查一个文件的有效名称而非描述内容(例如循环日志)，默认\n"
"的程序动作并不如您所愿。在这种场合可以使用--follow=name 选项，它会使\n"
"tail 定期追踪打开给定名称的文件，以确认它是否被删除或被其它某些程序重新创建"
"过。\n"

#: src/tail.c:379
#, c-format
msgid "closing %s (fd=%d)"
msgstr "正在关闭 %s (fd=%d)"

#: src/tail.c:454
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s：无法检索相对偏移量 %s"

#: src/tail.c:458
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s：无法检索相对偏移量的末尾 %s"

#: src/tail.c:894
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr "无法定位 %s 的位置，回归为 polling 机制"

#: src/tail.c:963
#, c-format
msgid "%s has become inaccessible"
msgstr "%s 已不可访问"

#: src/tail.c:980
#, c-format
msgid "%s has been replaced with an untailable file; giving up on this name"
msgstr "%s 已被替换为tail 无法处理的文件，放弃跟踪"

#: src/tail.c:989
#, c-format
msgid "%s has been replaced with a remote file. giving up on this name"
msgstr "%s 已被替换为一个远程文件，放弃跟踪"

#: src/tail.c:1010
#, c-format
msgid "%s has become accessible"
msgstr "%s 已经可以访问"

#: src/tail.c:1018
#, c-format
msgid "%s has appeared;  following end of new file"
msgstr "%s 已被建立，正在跟随新文件的末尾"

#: src/tail.c:1029
#, c-format
msgid "%s has been replaced;  following end of new file"
msgstr "%s 已被替换，正在跟随新文件的末尾"

#: src/tail.c:1130
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s：无法更改非阻塞模式"

#: src/tail.c:1171 src/tail.c:1286
#, c-format
msgid "%s: file truncated"
msgstr "%s：文件已截断"

#: src/tail.c:1195 src/tail.c:1441
#, c-format
msgid "no files remaining"
msgstr "没有剩余文件"

#: src/tail.c:1368
#, c-format
msgid "cannot watch parent directory of %s"
msgstr "无法监视%s 的上级目录"

#: src/tail.c:1371 src/tail.c:1386
#, c-format
msgid "inotify resources exhausted"
msgstr "inotify 资源耗尽"

#: src/tail.c:1389 src/tail.c:1518
#, c-format
msgid "cannot watch %s"
msgstr "无法监视%s"

#: src/tail.c:1472
#, c-format
msgid "error monitoring inotify event"
msgstr "监视inotify 事件出错"

#: src/tail.c:1492
#, c-format
msgid "error reading inotify event"
msgstr "读取inotify 事件出错"

#: src/tail.c:1785
#, c-format
msgid "%s: cannot follow end of this type of file; giving up on this name"
msgstr "%s：无法跟随此类型文件的末尾，已放弃"

#: src/tail.c:1902
#, c-format
msgid "number in %s is too large"
msgstr "%s 中的数字过大"

#: src/tail.c:1974
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr "%s：两次打开的间隔因过大而无效"

#: src/tail.c:1990
#, c-format
msgid "%s: invalid PID"
msgstr "%s：无效的进程号"

#: src/tail.c:2009
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s：无效的秒数"

#: src/tail.c:2025
#, c-format
msgid "option used in invalid context -- %c"
msgstr "在未定义环境中的无效选项 -- %c"

#: src/tail.c:2033
#, c-format
msgid "warning: --retry is useful mainly when following by name"
msgstr "警告：--retry 参数需要在后面附加名称后使用"

#: src/tail.c:2037
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr "警告：已忽略进程号，只有在跟随模式下--pid=PID 选项才是有用的"

#: src/tail.c:2040
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "警告：此系统不支持--pid=PID"

#: src/tail.c:2141
#, c-format
msgid "cannot follow %s by name"
msgstr "无法按名称跟随%s"

#: src/tail.c:2147
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "警告：无限期跟随标准输入是无用的"

#: src/tail.c:2208
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "无法使用 inotify 机制，回归为 polling 机制"

#: src/tee.c:64
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"将标准输入复制到每个指定文件，并显示到标准输出。\n"
"\n"
"  -a, --append\t\t内容追加到给定的文件而非覆盖\n"
"  -i, --ignore-interrupts\t忽略中断信号\n"

#: src/tee.c:72
msgid ""
"\n"
"If a FILE is -, copy again to standard output.\n"
msgstr ""
"\n"
"如果文件指定为\"-\"，则将输入内容复制到标准输出。\n"

#: src/test.c:117
#, c-format
msgid "missing argument after %s"
msgstr "%s 后缺少参数"

#: src/test.c:153
#, c-format
msgid "invalid integer %s"
msgstr "无效的整数%s"

#: src/test.c:235
msgid "')' expected"
msgstr "预期为')'"

#: src/test.c:238
#, c-format
msgid "')' expected, found %s"
msgstr "预期为 ')'，实际为%s"

#: src/test.c:254 src/test.c:600
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: 预期为单目运算符"

#: src/test.c:323
msgid "-nt does not accept -l"
msgstr "-nt 不能与-l 同时使用"

#: src/test.c:336
msgid "-ef does not accept -l"
msgstr "-ef 不能与-l 同时使用"

#: src/test.c:352
msgid "-ot does not accept -l"
msgstr "-ot 不能于-l 同时使用"

#: src/test.c:361
msgid "unknown binary operator"
msgstr "未知双目运算符"

#: src/test.c:628
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: 预期为双目运算符"

#: src/test.c:687
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"用法：%s 表达式\n"
"　或：test\n"
"　或：[表达式]\n"
"　或：[ ]\n"
"　或：[ 选项\n"

#: src/test.c:694
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr ""
"退出状态值取决于表达式。\n"
"\n"

#: src/test.c:700
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"被省略的表达式的值默认为假，否则可能为真也可能为假，\n"
"并会被设为退出状态值。有效的表达式应属于下列之一：\n"

#: src/test.c:705
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( 表达式 )\t\t表达式的值为真\n"
"  ! 表达式\t\t表达式的值为假(非)\n"
"  表达式1 -a 表达式2\t两个表达式的值都为真时结果为真(与)\n"
"  表达式1 -o 表达式2\t两个表达式中任一的值为真时结果为真(或)\n"

#: src/test.c:712
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  -n 字符串\t\t字符串的长度非零\n"
"  字符串\t\t等于\"-n 字符串\"\n"
"  -z 字符串\t\t字符串的长度为零\n"
"  字符串1 = 字符串2\t两个字符串相等\n"
"  字符串1 != 字符串2\t两个字符串不等\n"

#: src/test.c:720
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  整数1 -eq 整数2\t整数1 等于整数2\n"
"  整数1 -ge 整数2\t整数1 大于等于整数2\n"
"  整数1 -gt 整数2\t整数1 大于 整数2\n"
"  整数1 -le 整数2\t整数1 大于等于整数2\n"
"  整数1 -lt 整数2\t整数1 小于 整数2\n"
"  整数1 -ne 整数2\t整数1 不等于整数2\n"

#: src/test.c:729
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  文件1 -ef  文件2\t文件1 与文件2 的设备和节点号相等\n"
"  文件1 -nt  文件2\t文件1 的上次修改时间新于文件2\n"
"  文件1 -ot  文件2\t文件1 的上次修改时间旧于文件2\n"

#: src/test.c:735
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b 文件\t\t指定文件存在且为块设备文件\n"
"  -c 文件\t\t指定文件存在且为字符设备文件\n"
"  -d 文件\t\t指定文件存在且为目录\n"
"  -e 文件\t\t指定文件存在\n"

#: src/test.c:742
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f 文件\t\t指定文件存在且为普通文件\n"
"  -g 文件\t\t指定文件存在且设置了setgid 位\n"
"  -G 文件\t\t指定文件存在且属组ID 有效\n"
"  -h 文件\t\t指定文件存在且为符号链接 (等价于 -L)\n"
"  -k 文件\t\t指定文件存在且设置了粘附位\n"

#: src/test.c:749
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L 文件\t\t指定文件存在且为符号链接(等于-h)\n"
"  -O 文件\t\t指定文件存在且属主ID 有效\n"
"  -p 文件\t\t指定文件存在且为命名管道\n"
"  -r 文件\t\t指定文件存在且具备读取权限\n"
"  -s 文件\t\t指定文件存在且其大小大于0\n"

#: src/test.c:756
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S 文件\t\t指定文件存在且为套接字文件\n"
"  -t FD\t\t\t已有一个终端打开了文件的描述符FD\n"
"  -u 文件\t\t指定文件存在且设置了setuid 位\n"
"  -w 文件\t\t指定文件存在且具备写入权限\n"
"  -x 文件\t\t指定文件存在且具备执行或搜索(针对目录)权限\n"

#: src/test.c:763
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"除-h 和-L 以外，其它所有与指定文件相关的测试都会作用于符号链接。\n"
"请留心您在必要时需由shell 转义圆括号字符(例如使用反斜杠)。\n"
"指定整数也可用\"-l 字符串\"表示，这会估算相应字符串的长度。\n"

#: src/test.c:769
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"注意：[ 服从 --help 和 --version 选项但 test 不同。\n"
"test 将其和其他非空字符串同能对待。\n"

#: src/test.c:774
msgid "test and/or ["
msgstr "test 和/或["

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:786
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:787
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:841
msgid "missing `]'"
msgstr "缺少\"]\""

#: src/test.c:855
#, c-format
msgid "extra argument %s"
msgstr "多余的参数%s"

#: src/timeout.c:125
#, c-format
msgid "warning: timer_settime"
msgstr ""

#: src/timeout.c:130
#, c-format
msgid "warning: timer_create"
msgstr ""

#: src/timeout.c:203
#, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"用法：%s [选项] 停留时间 命令 [参数]...\n"
"　或：%s 选项\n"

#: src/timeout.c:207
msgid ""
"Start COMMAND, and kill it if still running after DURATION.\n"
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"运行指定命令，在指定的停留时间后若该命令仍在运行则将其中止。\n"
"\n"
"长选项必须使用的参数对于短选项时也是必需使用的。\n"

#: src/timeout.c:212
#, fuzzy
msgid ""
"      --foreground\n"
"                 When not running timeout directly from a shell prompt,\n"
"                 allow COMMAND to read from the TTY and receive TTY "
"signals.\n"
"                 In this mode, children of COMMAND will not be timed out.\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                 this long after the initial signal was sent.\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout.\n"
"                 SIGNAL may be a name like `HUP' or a number.\n"
"                 See `kill -l` for a list of signals\n"
msgstr ""
"  -k, --kill-after=停留时间\n"
"\t\t初始信号发出后指定时间内如果进程仍在运行则向其发送KILL 信号。  -s, --"
"signal=信号\n"
"\t\t指定在超时时发送的信号。信号可以是类似\"HUP\"的信号名或是信号数。\n"
"\t\t查看\"kill -l\"以获得信号列表\n"

#: src/timeout.c:228
#, fuzzy
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"`s' for seconds (the default), `m' for minutes, `h' for hours or `d' for "
"days.\n"
msgstr ""
"\n"
"指定的时间应是一个附加有下列后缀的整数：\n"
"\"s\"代表秒(默认值)，\"m\"代表分，\"h\"代表小时，\"d\"代表天。\n"
"\n"

#: src/timeout.c:233
msgid ""
"\n"
"If the command times out, then exit with status 124.  Otherwise, exit\n"
"with the status of COMMAND.  If no signal is specified, send the TERM\n"
"signal upon timeout.  The TERM signal kills any process that does not\n"
"block or catch that signal.  For other processes, it may be necessary to\n"
"use the KILL (9) signal, since this signal cannot be caught.\n"
msgstr ""
"\n"
"如果程序超时则退出状态数为124，否则返回程序退出状态。\n"
"如果没有指定信号则默认为TERM 信号。TERM 信号在进程没有捕获此信号时杀死进"
"程。\n"
"对于另一些进程可能需要使用KILL (9)信号，当然此信号不能被捕获。\n"

#: src/timeout.c:417
#, c-format
msgid "error waiting for command"
msgstr "等待命令出错"

#: src/timeout.c:439
#, c-format
msgid "warning: disabling core dumps failed"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:116 src/touch.c:315
#, c-format
msgid "invalid date format %s"
msgstr "日期格式%s 无效"

#: src/touch.c:195
#, c-format
msgid "cannot touch %s"
msgstr "无法创建%s"

#: src/touch.c:201
#, c-format
msgid "setting times of %s"
msgstr "正在设置%s 的时间"

#: src/touch.c:218
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
"\n"
msgstr ""
"将每个文件的访问时间和修改时间改为当前时间。\n"
"\n"
"不存在的文件将会被创建为空文件，除非使用-c 或-h 选项。\n"
"\n"
"如果文件名为\"-\"则特殊处理，更改与标准输出相关的文件的访问时间。\n"
"\n"

#: src/touch.c:231
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a\t\t\t只更改访问时间\n"
"  -c, --no-create\t不创建任何文件\n"
"  -d, --date=字符串\t使用指定字符串表示时间而非当前时间\n"
"  -f\t\t\t(忽略)\n"

#: src/touch.c:237
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference\t\t会影响符号链接本身，而非符号链接所指示的目的地\n"
"\t\t\t\t(当系统支持更改符号链接的所有者时，此选项才有用)\n"
"  -m\t\t\t只更改修改时间\n"

#: src/touch.c:243
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"  --time=WORD            change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --reference=文件\t使用指定文件的时间属性而非当前时间\n"
"  -t STAMP\t\t使用[[CC]YY]MMDDhhmm[.ss] 格式的时间而非当前时间\n"
"  --time=WORD\t\t使用WORD 指定的时间：access、atime、use 都等于-a\n"
"\t\t\t选项的效果，而modify、mtime 等于-m 选项的效果\n"

#: src/touch.c:252
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"请注意，-d 和-t 选项可接受不同的时间/日期格式。\n"

#: src/touch.c:341
#, c-format
msgid "cannot specify times from more than one source"
msgstr "无法由多于一种的来源来指定时间"

#: src/touch.c:415
#, c-format
msgid ""
"warning: `touch %s' is obsolete; use `touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"警告：\"touch %s\"已过时，请使用\"touch -t %04ld%02d%02d%02d%02d.%02d\"代替"

#: src/tr.c:287
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "用法：%s [选项]... SET1 [SET2]\n"

#: src/tr.c:291
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each input sequence of a repeated "
"character\n"
"                            that is listed in SET1 with a single occurrence\n"
"                            of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。\n"
"\n"
"  -c, -C, --complement\t\t首先补足SET1\n"
"  -d, --delete\t\t\t删除匹配SET1 的内容，并不作替换\n"
"  -s, --squeeze-repeats\t如果匹配于SET1 的字符在输入序列中存在连续的\n"
"\t\t\t\t重复，在替换时会被统一缩为一个字符的长度\n"
"  -t, --truncate-set1\t\t先将SET1 的长度截为和SET2 相等\n"

#: src/tr.c:304
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"SET 是一组字符串，一般都可按照字面含义理解。解析序列如下：\n"
"\n"
"  \\NNN\t八进制值为NNN 的字符(1 至3 个数位)\n"
"  \\\\\t\t反斜杠\n"
"  \\a\t\t终端鸣响\n"
"  \\b\t\t退格\n"
"  \\f\t\t换页\n"
"  \\n\t\t换行\n"
"  \\r\t\t回车\n"
"  \\t\t\t水平制表符\n"

#: src/tr.c:318
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v\t\t垂直制表符\n"
"  字符1-字符2\t从字符1 到字符2 的升序递增过程中经历的所有字符\n"
"  [字符*]\t在SET2 中适用，指定字符会被连续复制直到吻合设置1 的长度\n"
"  [字符*次数]\t对字符执行指定次数的复制，若次数以 0 开头则被视为八进制数\n"
"  [:alnum:]\t所有的字母和数字\n"
"  [:alpha:]\t所有的字母\n"
"  [:blank:]\t所有呈水平排列的空白字符\n"
"  [:cntrl:]\t所有的控制字符\n"
"  [:digit:]\t所有的数字\n"

#: src/tr.c:329
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]\t所有的可打印字符，不包括空格\n"
"  [:lower:]\t所有的小写字母\n"
"  [:print:]\t所有的可打印字符，包括空格\n"
"  [:punct:]\t所有的标点字符\n"
"  [:space:]\t所有呈水平或垂直排列的空白字符\n"
"  [:upper:]\t所有的大写字母\n"
"  [:xdigit:]\t所有的十六进制数\n"
"  [=字符=]\t所有和指定字符相等的字符\n"

# ## Forward to here.
#: src/tr.c:339
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"\n"
"仅在SET1 和SET2 都给出，同时没有-d 选项的时候才会进行替换。\n"
"仅在替换时才可能用到-t 选项。如果需要SET2 将被通过在末尾添加原来的末字符的方"
"式\n"
"补充到同SET1 等长。SET2 中多余的字符将被省略。只有[:lower:] 和[:upper:]\n"
"以升序展开字符；在用于替换时的SET2 中以成对表示大小写转换。-s 作用于SET1，既"
"不\n"
"替换也不删除，否则在替换或展开后使用SET2 缩减。\n"

#: src/tr.c:510
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"警告：含义不清的八进制内容 \\%c%c%c 已被视作为双字节序列 \\0%c%c, %c 处理"

#: src/tr.c:519
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr "警告：在字符串结尾使用为转义的反斜杠是一种不可移植的做法"

#: src/tr.c:674
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr "\"%s-%s\"的结束点范围序列已经过反转处理"

#: src/tr.c:830
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "在参数结构 [c*n] 中有无效的重复次数%s"

#: src/tr.c:911
#, c-format
msgid "missing character class name `[::]'"
msgstr "缺失字符种类名\"[::]\""

#: src/tr.c:914
#, c-format
msgid "missing equivalence class character `[==]'"
msgstr "缺失类型等值的字符\"[==]\""

#: src/tr.c:929
#, c-format
msgid "invalid character class %s"
msgstr "无效的字符类型%s"

#: src/tr.c:948
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s：同类操作数必须是单个字符"

#: src/tr.c:1230
#, c-format
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "[:upper:] 和/或[:lower:] 的结构对齐不完整"

#: src/tr.c:1336
#, c-format
msgid "too many characters in set"
msgstr "设置中的字符数量过多"

#: src/tr.c:1421
#, c-format
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr "当字符串1 长度大于字符串2时，后者不能以字符类结尾"

#: src/tr.c:1481
#, c-format
msgid "the [c*] repeat construct may not appear in string1"
msgstr "在字符串1 中不能出现[c*] 结构的重复次数声明"

#: src/tr.c:1491
#, c-format
msgid "only one [c*] repeat construct may appear in string2"
msgstr "在字符串2 中只能出现一次[c*] 结构的重复次数声明"

#: src/tr.c:1499
#, c-format
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "在替换操作中字符串2 里不能出现表达式[=c=]"

#: src/tr.c:1506
#, c-format
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""
"当进行替换操作时，字符串2 里只能出现一种字符类型，即\"upper\"和\"lower\""

#: src/tr.c:1521
#, c-format
msgid "when not truncating set1, string2 must be non-empty"
msgstr "当不截断设置1 时，字符串2 不能为空"

#: src/tr.c:1530
#, c-format
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr "当以反相模式替换字符类型时，字符串2 必须将所有字符映射到一个字域"

#: src/tr.c:1539
#, c-format
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "当进行替换操作时[c*] 结构的参数只能出现在字符串2 中"

#: src/tr.c:1789
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr "当同时重复删除和缩减时必须给出两组字符串。"

#: src/tr.c:1791
msgid "Two strings must be given when translating."
msgstr "当进行替换操作时必须给定两组字符串。"

#: src/tr.c:1801
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr "当进行不含缩减的删除操作时只能给定一组字符串。"

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [忽略任何命令行参数]\n"
"　或：%s 选项\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "以表示成功的状态值退出"

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "以表示失败的状态值退出"

#: src/truncate.c:97
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "用法：%s 选项... 文件...\n"

#: src/truncate.c:98
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the extended part (hole)\n"
"reads as zero bytes.\n"
"\n"
msgstr ""
"将文件缩减或扩展至指定大小。\n"
"\n"
"如果指定文件不存在则创建。\n"
"\n"
"如果指定文件超出指定大小则超出的数据将丢失。\n"
"如果指定文件小于指定大小则用0 补足。\n"
"\n"

#: src/truncate.c:111
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create\t不创建文件\n"

#: src/truncate.c:114
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr "  -o, --io-blocks\t将SIZE 视为IO 块数而不使用字节数\n"

#: src/truncate.c:117
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE\n"
msgstr ""
"  -r, --reference=文件   使用此文件的大小\n"
"  -s, --size=大小\t使用此大小\n"

#: src/truncate.c:123
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"`+' extend by, `-' reduce by, `<' at most, `>' at least,\n"
"`/' round down to multiple of, `%' round up to multiple of.\n"
msgstr ""
"\n"
"指定大小也可使用以下前缀修饰：\n"
"\"+\" 增加，\"-\" 减少，\"<\" 至多，\">\" 至少，\n"
"\"/\" 小于等于原尺寸数字的指定数字的最小倍数，\"%\" 大于等于原尺寸数字的指定"
"数字的最大倍数。\n"
"译者注：当输入值为m，参考值为n 时，\n"
"\"/\" 运算的数学计算式为 m / n * n；\n"
"\"%\" 运算的数学计算式为( m + n - 1 ) / n * n\n"

#: src/truncate.c:151
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdMAX> byte blocks for file %s"
msgstr "在文件%3$s 的%1$<PRIdMAX> * %2$<PRIdMAX> 字节块中溢出"

#: src/truncate.c:167 src/truncate.c:355
#, c-format
msgid "cannot get the size of %s"
msgstr "无法获得%s 的大小"

#: src/truncate.c:174
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s 的文件大小为负数，无法使用"

#: src/truncate.c:194
#, c-format
msgid "overflow rounding up size of file %s"
msgstr "处理大于等于文件%s 的指定大小的最大倍数时溢出"

#: src/truncate.c:204
#, c-format
msgid "overflow extending size of file %s"
msgstr "扩展文件%s 大小时溢出"

#: src/truncate.c:219
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr "在%2$<PRIdMAX> 字节处截断%1$s 失败"

#: src/truncate.c:293
#, c-format
msgid "multiple relative modifiers specified"
msgstr "指定了多个相关修饰符"

#: src/truncate.c:323
#, c-format
msgid "you must specify either %s or %s"
msgstr "您必须在%s 或%s 中指定一个"

#: src/truncate.c:330
#, c-format
msgid "you must specify a relative %s with %s"
msgstr "您必须为%2$s 中指定一个相关的%1$s"

#: src/truncate.c:337
#, c-format
msgid "%s was specified but %s was not"
msgstr "已指定%s 但未指定%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:40
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:83
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"用法：%s [选项] [文件]\n"
"对不完全排序的文件实行完整的列表排序。\n"
"如果不指定文件，或者文件为\"-\"，则从标准输入读取数据。\n"
"\n"

#: src/tsort.c:473
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s：输入内容的行数为奇数"

#: src/tsort.c:519
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s：输入内容中含有循环段落："

#: src/tty.c:66
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"显示出连接到当前标准输入的终端设备文件名。\n"
"\n"
"  -s, --silent, --quiet\t什么也不显示，只返回退出状态值\n"

#: src/tty.c:121
msgid "not a tty"
msgstr "不是一个 tty"

#: src/uname.c:126
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"输出一组系统信息。如果不跟随选项，则视为只附加-s 选项。\n"
"\n"
"  -a, --all\t\t\t以如下次序输出所有信息。其中若-p 和\n"
"\t\t\t\t-i 的探测结果不可知则被省略：\n"
"  -s, --kernel-name\t\t输出内核名称\n"
"  -n, --nodename\t\t输出网络节点上的主机名\n"
"  -r, --kernel-release\t\t输出内核发行号\n"

#: src/uname.c:135
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type or \"unknown\"\n"
"  -i, --hardware-platform  print the hardware platform or \"unknown\"\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version\t\t输出内核版本\n"
"  -m, --machine\t\t输出主机的硬件架构名称\n"
"  -p, --processor\t\t输出处理器类型或\"unknown\"\n"
"  -i, --hardware-platform\t输出硬件平台或\"unknown\"\n"
"  -o, --operating-system\t输出操作系统名称\n"

#: src/uname.c:145
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"输出机器的体系结构。\n"
"\n"

#: src/uname.c:288
#, c-format
msgid "cannot get system name"
msgstr "无法获取系统名"

#: src/unexpand.c:119
msgid ""
"Convert blanks in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"将每个指定文件中的空白字符转换为制表符并写到标准输出。\n"
"如果不指定文件，或者文件为\"-\"，则从标准输入读取数据。\n"
"\n"

#: src/unexpand.c:127
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
"  -t, --tabs=LIST  use comma separated LIST of tab positions (enables -a)\n"
msgstr ""
"  -a, --all\t\t转换所有空格，包括但不只起始空格\n"
"      --first-only\t仅转换起始空格(覆盖-a 选项)\n"
"  -t, --tabs=N\t\t设置制表符宽度为N 而非默认的8(启用-a 选项)\n"
"  -t, --tabs=列表\t使用逗号分隔的列表列出制表符位置(启用-a 选项)\n"

#: src/unexpand.c:155
#, c-format
msgid "tabs are too far apart"
msgstr "制表符过于分散"

#: src/unexpand.c:507
#, c-format
msgid "tab stop value is too large"
msgstr "制表符限长过大"

#: src/uniq.c:135
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "用法：%s [选项]... [文件]\n"

#: src/uniq.c:139
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
"\n"
msgstr ""
"从输入文件或者标准输入中筛选相邻的匹配行并写入到输出文件或标准输出。\n"
"\n"
"不附加任何选项时匹配行将在首次出现处被合并。\n"
"\n"

#: src/uniq.c:149
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
msgstr ""
"  -c, --count\t\t在每行前加上表示相应行目出现次数的前缀编号\n"
"  -d, --repeated\t只输出重复的行\n"

#: src/uniq.c:153
msgid ""
"  -D, --all-repeated[=delimit-method]  print all duplicate lines\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        Delimiting is done with blank lines\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
"  -z, --zero-terminated  end lines with 0 byte, not newline\n"
msgstr ""
"  -D, --all-repeated[=delimit-method\t显示所有重复的行\n"
"\t\t\tdelimit-method={none(default),prepend,separate}\n"
"\t\t\t以空行为界限\n"
"  -f, --skip-fields=N\t比较时跳过前N 列\n"
"  -i, --ignore-case\t在比较的时候不区分大小写\n"
"  -s, --skip-chars=N\t比较时跳过前N 个字符\n"
"  -u, --unique\t\t只显示唯一的行\n"
"  -z, --zero-terminated\t使用'\\0'作为行结束符，而不是新换行\n"

#: src/uniq.c:163
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr "  -w, --check-chars=N\t对每行第N 个字符以后的内容不作对照\n"

#: src/uniq.c:168
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中字符前的空字符将"
"被跳过。\n"

#: src/uniq.c:173
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use `sort -u' without `uniq'.\n"
"Also, comparisons honor the rules specified by `LC_COLLATE'.\n"
msgstr ""
"\n"
"提示：uniq 不会检查重复的行，除非它们是相邻的行。\n"
"如果您想先对输入排序，使用没有uniq 的\"sort -u\"。\n"
"同时，比较服从\"LC_COLLATE\" 变量所指定的规则。\n"

#: src/uniq.c:360
#, c-format
msgid "too many repeated lines"
msgstr "重复行过多"

#: src/uniq.c:523
msgid "invalid number of fields to skip"
msgstr "要略过的区块数量无效"

#: src/uniq.c:532
msgid "invalid number of bytes to skip"
msgstr "要略过的字节数量无效"

#: src/uniq.c:541
msgid "invalid number of bytes to compare"
msgstr "要对照的字节数量无效"

#: src/uniq.c:560
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr "同时输出重复的行和重复计数是没有意义的"

#: src/unlink.c:46
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 文件\n"
"　或：%s 选项\n"

#: src/unlink.c:49
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"调用 unlink 函数删除指定的文件。\n"
"\n"

#: src/unlink.c:87
#, c-format
msgid "cannot unlink %s"
msgstr "无法清除%s 的链接"

#: src/uptime.c:125
#, c-format
msgid "couldn't get boot time"
msgstr "无法获取启动时间"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:136
msgid " %H:%M%P  "
msgstr " %H:%M "

#: src/uptime.c:138
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:140
#, c-format
msgid "up ???? days ??:??,  "
msgstr "已启动???? 天 ??:??，"

#: src/uptime.c:144
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "已启动%ld 天%2d:%02d，"

#: src/uptime.c:151
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu 个用户"

#: src/uptime.c:161
#, c-format
msgid ",  load average: %.2f"
msgstr "，平均负载：%.2f"

#: src/uptime.c:198
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"输出当前时间，系统启动时间，当前登录用户数以及最近1、5 和15 分钟系统运行\n"
"队列中的平均任务数。"

#: src/uptime.c:207
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr "  处于不可中断睡眠状态的程序同样影响系统平均负载。\n"

#: src/uptime.c:211
#, c-format
msgid "\n"
msgstr "\n"

#: src/uptime.c:213
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"如果文件没有指定，则使用%s，%s 是通用的相关文件。\n"
"\n"

#: src/users.c:107
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"根据文件判断输出当前有谁正登录在系统上。\n"
"如果文件未予指定，则使用%s，%s 是通用的相关文件。\n"
"\n"

#: src/wc.c:118
#, fuzzy
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.  A word is a non-zero-length sequence of characters\n"
"delimited by white space.\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"输出每个指定文件的行数、单词计数和字节数，如果指定了\n"
"多于一个文件，继续给出所有相关数据的总计。如果没有指定\n"
"文件，或者文件为\"-\"，则从标准输入读取数据。\n"
"  -c, --bytes\t\t输出字节数统计\n"
"  -m, --chars\t\t输出字符数统计\n"
"  -l, --lines\t\t输出行数统计\n"

#: src/wc.c:129
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=文件\t从指定文件读取以NUL 终止的名称，如果该文件被\n"
"\t\t\t\t\t指定为\"-\"则从标准输入读文件名\n"
"  -L, --max-line-length\t显示最长行的长度\n"
"  -w, --words\t\t\t显示单词计数\n"

#: src/who.c:210
msgid " old "
msgstr " 旧的 "

#: src/who.c:449
msgid "system boot"
msgstr "系统引导"

#: src/who.c:456 src/who.c:458
msgid "id="
msgstr "id="

#: src/who.c:471 src/who.c:476
msgid "term="
msgstr "终端="

#: src/who.c:473 src/who.c:477
msgid "exit="
msgstr "退出="

#: src/who.c:494
msgid "LOGIN"
msgstr "登录"

#: src/who.c:514
msgid "clock change"
msgstr "时钟更改"

#: src/who.c:526 src/who.c:527
msgid "run-level"
msgstr "运行级别"

#: src/who.c:530 src/who.c:531
msgid "last="
msgstr "最近="

#: src/who.c:562
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"# 用户数=%lu\n"

#: src/who.c:568
msgid "NAME"
msgstr "名称"

#: src/who.c:568
msgid "LINE"
msgstr "线路"

#: src/who.c:568
msgid "TIME"
msgstr "时间"

#: src/who.c:568
msgid "IDLE"
msgstr "空闲"

#: src/who.c:569
msgid "PID"
msgstr "进程号"

#: src/who.c:569
msgid "COMMENT"
msgstr "备注"

#: src/who.c:569
msgid "EXIT"
msgstr "退出"

#: src/who.c:650
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "用法：%s [选项]... [ 文件 | 参数1 参数2 ]\n"

#: src/who.c:651
msgid "Print information about users who are currently logged in.\n"
msgstr "显示当前已登录的用户信息。\n"

#: src/who.c:654
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all\t\t等于-b -d --login -p -r -t -T -u 选项的组合\n"
"  -b, --boot\t\t上次系统启动时间\n"
"  -d, --dead\t\t显示已死的进程\n"
"  -H, --heading\t输出头部的标题列\n"

#: src/who.c:661
msgid "  -l, --login       print system login processes\n"
msgstr "  -l，--login\t\t显示系统登录进程\n"

#: src/who.c:664
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup\t\t尝试通过 DNS 查验主机名\n"
"  -m\t\t\t只面对和标准输入有直接交互的主机和用户\n"
"  -p, --process\t显示由 init 进程衍生的活动进程\n"

#: src/who.c:669
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count\t\t列出所有已登录用户的登录名与用户数量\n"
"  -r, --runlevel\t显示当前的运行级别\n"
"  -s, --short\t\t只显示名称、线路和时间(默认)\n"

#: src/who.c:675
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg\t用+，- 或 ? 标注用户消息状态\n"
"  -u, --users\t\t列出已登录的用户\n"
"      --message\t等于-T\n"
"      --writable\t等于-T\n"

#: src/who.c:683
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: `am i' or `mom likes' are usual.\n"
msgstr ""
"\n"
"如果文件未被指定，则使用%s。%s 是通用的相关文件。\n"
"如果给定了参数1 和参数2，-m 会假定：\"am i\"或\"mom likes\"\n"
"为参数。\n"

#: src/whoami.c:47
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"显示与当前的有效用户ID 相关联的用户名。\n"
"与id -un 相同。\n"
"\n"

#: src/whoami.c:91
#, c-format
msgid "%s: cannot find name for user ID %lu\n"
msgstr "%s：无法找到用户ID 为%lu 的用户名\n"

#: src/yes.c:42
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [字符串]...\n"
"　或：%s 选项\n"

#: src/yes.c:48
msgid ""
"Repeatedly output a line with all specified STRING(s), or `y'.\n"
"\n"
msgstr ""
"重复输出一行指定的字符串，或者重复输出\"y\"。\n"
"\n"

#~ msgid "cannot create link %s"
#~ msgstr "无法创建链接%s"

#, fuzzy
#~ msgid "%s: option '%s' is ambiguous\n"
#~ msgstr "%s：选项\"-W %s\"歧义\n"

#~ msgid ""
#~ "WARNING: --preserve_context is deprecated; use --preserve-context instead"
#~ msgstr "警告：不推荐使用--preserve_context，请使用--preserve-context"

#~ msgid "truncating %s"
#~ msgstr "正在截断%s"

#~ msgid "invalid number of lines: 0"
#~ msgstr "无效的行数：0"

#~ msgid "invalid format width"
#~ msgstr "无效的格式宽度"

#~ msgid "invalid format precision"
#~ msgstr "无效的格式精确度"

#~ msgid "%s"
#~ msgstr "%s"

#~ msgid "creating symbolic link %s"
#~ msgstr "创建符号链接 %s"

#~ msgid "creating symbolic link %s -> %s"
#~ msgstr "创建符号链接%s -> %s"

#~ msgid "creating hard link %s"
#~ msgstr "创建硬链接%s"

#~ msgid "creating hard link %s => %s"
#~ msgstr "创建硬链接%s => %s"

#~ msgid "extra operand %s\n"
#~ msgstr "额外的操作数 %s\n"

#~ msgid "both SI and IEC prefixes present on units"
#~ msgstr "单位中既有 SI 单位又有 IEC 单位"

#~ msgid ""
#~ "the --context (-Z) option is obsolete and will be removed\n"
#~ "in a future release"
#~ msgstr "--context (-Z)选项已废弃，将在未来的发行中删除"

#~ msgid "warning: the --%s option is obsolete; use --reference"
#~ msgstr "警告：--%s 选项已过时，请使用--reference"

#~ msgid ""
#~ "\n"
#~ "Note that the -r and -s options are mutually exclusive.\n"
#~ msgstr ""
#~ "\n"
#~ "请注意-r 和-s 是互斥的选项。\n"

#~ msgid ""
#~ "  -w, --wrap=COLS       Wrap encoded lines after COLS character (default "
#~ "76).\n"
#~ "                        Use 0 to disable line wrapping.\n"
#~ "\n"
#~ "  -d, --decode          Decode data.\n"
#~ "  -i, --ignore-garbage  When decoding, ignore non-alphabet characters.\n"
#~ "\n"
#~ msgstr ""
#~ "  -w, --wrap=COLS\t限制编码后每行的长度为COLS(默认为76个字符)。\n"
#~ "\t\t\t如果COLS为0，表示无此限制。\n"
#~ "\n"
#~ "  -d, --decode\t\t解码。\n"
#~ "  -i, --ignore-garbage\t在解码的时候忽略非字母表(a-zA-Z)的字符。\n"
#~ "\n"

#~ msgid ""
#~ "Usage: %s [OPTION] NUMBER[SUFFIX] COMMAND [ARG]...\n"
#~ "  or:  %s [OPTION]\n"
#~ msgstr ""
#~ "用法：%s [选项] 数字[后缀] 命令 [参数]...\n"
#~ "　或：%s [选项]\n"

#~ msgid "%s: illegal option -- %c\n"
#~ msgstr "%s：非法选项 -- %c\n"

#~ msgid ""
#~ "      --help            Display this help and exit.\n"
#~ "      --version         Output version information and exit.\n"
#~ msgstr ""
#~ "      --help            显示此帮助并退出。\n"
#~ "      --version         输出版本信息并退出\n"

#~ msgid ""
#~ "With --follow (-f), tail defaults to following the file descriptor, "
#~ "which\n"
#~ "means that even if a tail'ed file is renamed, tail will continue to "
#~ "track\n"
#~ "its end.  "
#~ msgstr ""
#~ "当同--follow (-f)一起使用时，tail 默认以文件描述内容为观察。这意味着\n"
#~ "即使被指定的文件已被改名，tail 仍会继续追踪其尾部内容。"

#~ msgid "invalid argument: %s"
#~ msgstr "无效的参数：%s"

#~ msgid "Report %s bugs to <%s>.\n"
#~ msgstr "请向<%s> 报告%s 的错误。\n"

#~ msgid "%s home page: <http://www.gnu.org/software/%s/>.\n"
#~ msgstr "%s 主页：<http://www.gnu.org/software/%s/>。\n"

#~ msgid "General help using GNU software: <http://www.gnu.org/gethelp/>.\n"
#~ msgstr "使用GNU 软件的一般帮助：<http://www.gnu.org/gethelp/>。\n"

#~ msgid "the --megabytes option is deprecated; use -m instead"
#~ msgstr "警告：--megabytes 选项已经过时，请使用-m。"

#~ msgid ""
#~ "\n"
#~ "If -e is in effect, the following sequences are recognized:\n"
#~ "\n"
#~ "  \\0NNN   the character whose ASCII code is NNN (octal)\n"
#~ "  \\\\     backslash\n"
#~ "  \\a     alert (BEL)\n"
#~ "  \\b     backspace\n"
#~ msgstr ""
#~ "\n"
#~ "如果 -e 选项生效，以下特殊序列可以被识别：\n"
#~ "\n"
#~ "  \\0NNN\tASCII 码为NNN 的字符(八进制)\n"
#~ "  \\\\\t反斜杠\n"
#~ "  \\a\t终端响铃\n"
#~ "  \\b\t退格\n"

#~ msgid "  -d, --directory  create a directory, not a file\n"
#~ msgstr "  -d, --directory  \t创建一个目录而非文件\n"

#~ msgid ""
#~ "  -q, --quiet      suppress diagnostics about file/dir-creation failure\n"
#~ msgstr "  -q， --quiet \t\t隐藏创建文件或目录失败时的诊断信息\n"

#~ msgid ""
#~ "  -u, --dry-run    do not create anything; merely print a name (unsafe)\n"
#~ msgstr "  -u, --dry-run \t不创建任务; 只显示一个名称(不安全)\n"

#~ msgid "  -p DIR           use DIR as a prefix; implies -t [deprecated]\n"
#~ msgstr "  -p DIR \t\t用DIR 作为前缀；隐含-t [不推荐]\n"

#~ msgid ""
#~ "  \\a      alert (BEL)\n"
#~ "  \\b      backspace\n"
#~ "  \\c      produce no further output\n"
#~ "  \\f      form feed\n"
#~ msgstr ""
#~ "  \\a\t\t终端响铃\n"
#~ "  \\b\t\t退格\n"
#~ "  \\c\t\t不产生成更多输出\n"
#~ "  \\f\t\t换页\n"

#~ msgid ""
#~ "  \\n      new line\n"
#~ "  \\r      carriage return\n"
#~ "  \\t      horizontal tab\n"
#~ "  \\v      vertical tab\n"
#~ msgstr ""
#~ "  \\n\t\t换行\n"
#~ "  \\r\t\t回车\n"
#~ "  \\t\t\t水平制表符\n"
#~ "  \\v\t\t垂直制表符\n"

#~ msgid "path truncated when looking for %s"
#~ msgstr "查找%s 时已截断路径"

#~ msgid "%s: warning: making a hard link to a symbolic link is not portable"
#~ msgstr "%s：警告：将硬链接连至符号链接是不通用的功能"

#~ msgid ""
#~ "\n"
#~ "By default, color is not used to distinguish types of files.  That is\n"
#~ "equivalent to using --color=none.  Using the --color option without the\n"
#~ "optional WHEN argument is equivalent to using --color=always.  With\n"
#~ "--color=auto, color codes are output only if standard output is "
#~ "connected\n"
#~ "to a terminal (tty).  The environment variable LS_COLORS can influence "
#~ "the\n"
#~ "colors, and can be set easily by the dircolors command.\n"
#~ msgstr ""
#~ "\n"
#~ "默认情况下不使用色彩来区别文件，此方式等于使用了 --color=none 选项。若使"
#~ "用\n"
#~ "--color 选项但不指定 WHEN 参数则等于--color=always。当使用 --color=auto "
#~ "时，\n"
#~ "只当输出至终端(tty)时才会显示色彩。\n"

#~ msgid "FATAL: failed to close directory %s"
#~ msgstr "致命错误：关闭目录%s 失败"

#~ msgid "FATAL: cannot open .. from %s"
#~ msgstr "致命错误：无法从%s 打开 .."

#~ msgid "FATAL: cannot ensure %s (returned to via ..) is safe"
#~ msgstr "致命错误：不能确定%s (已使用 .. 返回)是安全的"

#~ msgid "FATAL: directory %s changed dev/ino"
#~ msgstr "致命错误：目录%s 的dev/ino 发生了变动"

#~ msgid "FATAL: cannot enter directory %s"
#~ msgstr "致命错误：无法进入目录%s"

#~ msgid "FATAL: just-changed-to directory %s changed dev/ino"
#~ msgstr "致命错误：刚刚进入的目录%s 的dev/ino 发生了变动"

#~ msgid "FATAL: cannot return to .. from %s"
#~ msgstr "致命错误：不能回到%s 的上级目录(..)"

#~ msgid "cannot remove %s directory %s"
#~ msgstr "无法删除%s 目录%s"

#~ msgid "cannot remove root directory %s"
#~ msgstr "无法删除根目录%s"

#~ msgid "cannot remove relative-named %s"
#~ msgstr "不能移除相对命名的%s"

#~ msgid "cannot restore current working directory"
#~ msgstr "无法回到当前工作目录"

#~ msgid ""
#~ "\n"
#~ "SIZE may have a multiplier suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ msgstr ""
#~ "\n"
#~ "指定的大小可以使用以下单位：\n"
#~ "xM=M，c=1，w=2，b=512，kB=1000，K=1024，MB=1000000，M=1048576，\n"
#~ "GB=1000000000，G=1073741824，T、P、E、Z、Y 依此类推。\n"

#~ msgid ""
#~ "Discard all but one of successive identical lines from INPUT (or\n"
#~ "standard input), writing to OUTPUT (or standard output).\n"
#~ "\n"
#~ msgstr ""
#~ "只保留<输入> (或标准输入) 中接连的相同行目中的一个节段，并写到\n"
#~ "<输出> (或标准输出)。\n"
#~ "\n"

#~ msgid ""
#~ "  -p                           same as --preserve=mode,ownership,"
#~ "timestamps\n"
#~ "      --preserve[=ATTR_LIST]   preserve the specified attributes "
#~ "(default:\n"
#~ "                                 mode,ownership,timestamps), if possible\n"
#~ "                                 additional attributes: context, links, "
#~ "all\n"
#~ msgstr ""
#~ "  -p                           等于--preserve=mode,ownership,timestamps\n"
#~ "      --preserve[=ATTR_LIST]   若可能，保留指定的文件属性\n"
#~ "                                 (默认值为：mode,ownership,timestamps)\n"
#~ "                                 额外的属性有：links、all\n"

#~ msgid "invalid output flag: %s"
#~ msgstr "无效的输出标志：%s"

#~ msgid ""
#~ "      --backup[=CONTROL]  make a backup of each existing destination "
#~ "file\n"
#~ "  -b                  like --backup but does not accept an argument\n"
#~ "  -c                  (ignored)\n"
#~ "  -d, --directory     treat all arguments as directory names; create all\n"
#~ "                        components of the specified directories\n"
#~ msgstr ""
#~ "      --backup[=CONTROL] 为每个已存在的目标文件进行备份\n"
#~ "  -b                  类似 --backup，但不接受任何参数\n"
#~ "  -c                  (此选项不作处理)\n"
#~ "  -d, --directory     所有参数都作为目录处理；而且会创建指定目录的所有主目"
#~ "录\n"

#~ msgid ""
#~ "  -P, --no-dereference         never follow symbolic links in SOURCE\n"
#~ msgstr "  -P, --no-dereference         从不跟随符号链接\n"

#~ msgid "File operands cannot be combined with --print-database (-p)."
#~ msgstr "文件操作数无法与 --print-database (-p) 组合使用。"

#~ msgid "Usage: %s [OPTION]... [STRING]...\n"
#~ msgstr "用法：%s [选项]... [字符串]...\n"

#~ msgid ""
#~ "  -a, --all             include dummy file systems\n"
#~ "  -B, --block-size=SIZE  use SIZE-byte blocks\n"
#~ "  -h, --human-readable  print sizes in human readable format (e.g., 1K "
#~ "234M 2G)\n"
#~ "  -H, --si              likewise, but use powers of 1000 not 1024\n"
#~ msgstr ""
#~ "  -a, --all             包括大小为 0 个块的文件系统\n"
#~ "  -B, --block-size=大小 块以指定<大小>的字节为单位\n"
#~ "  -h, --human-readable  以容易理解的格式输出文件系统大小 (例如 1K 234M "
#~ "2G)\n"
#~ "  -H, --si              类似 -h，但取 1000 的次方而不是 1024\n"

#~ msgid ""
#~ "      --files0-from=F   summarize disk usage of the NUL-terminated file\n"
#~ "                          names specified in file F\n"
#~ "  -H                    like --si, but also evokes a warning; will soon\n"
#~ "                          change to be equivalent to --dereference-args (-"
#~ "D)\n"
#~ "  -h, --human-readable  print sizes in human readable format (e.g., 1K "
#~ "234M 2G)\n"
#~ "      --si              like -h, but use powers of 1000 not 1024\n"
#~ msgstr ""
#~ "      -h, --human-readable  以容易理解的格式输出文件大小 (例如 1K 234M "
#~ "2G)\n"
#~ "  -H, --si              类似 -h，但取 1000 的次方而不是 1024\n"
#~ "  -k                    即--block-size=1K\n"
#~ "  -l, --count-links     连硬链接的大小也计算在内\n"

#~ msgid "Usage: %s [OPTION] FILE...\n"
#~ msgstr "用法：%s [选项] 文件...\n"

#~ msgid "???? days ??:??,  "
#~ msgstr "???? 天 ??:??，  "

#~ msgid "invalid input flag: %s"
#~ msgstr "无效的输入标志：%s"

#~ msgid ""
#~ "  -r, --reverse              reverse order while sorting\n"
#~ "  -R, --recursive            list subdirectories recursively\n"
#~ "  -s, --size                 print the size of each file, in blocks\n"
#~ msgstr ""
#~ "  -r, --reverse              逆序排序\n"
#~ "  -R, --recursive            递归列出所有子目录\n"
#~ "  -s, --size                 和 -l 同时使用时以块为单位列出每个文件的大"
#~ "小\n"

#~ msgid ""
#~ "  -f, --force                  if an existing destination file cannot be\n"
#~ "                                 opened, remove it and try again\n"
#~ "  -i, --interactive            prompt before overwrite\n"
#~ "  -H                           follow command-line symbolic links in "
#~ "SOURCE\n"
#~ msgstr ""
#~ "  -f, --force                  如果无法打开已存在的文件，会删除该文件并"
#~ "再\n"
#~ "                                 尝试打开\n"
#~ "  -i, --interactive            覆盖文件前需要确认\n"
#~ "  -H                           使用命令列中的符号链接指示的真正目的地\n"

#~ msgid "Usage: %s [OPTION] DIRECTORY...\n"
#~ msgstr "用法：%s [选项] 目录...\n"

#~ msgid ""
#~ "  -p, --preserve-timestamps   apply access/modification times of SOURCE "
#~ "files\n"
#~ "                        to corresponding destination files\n"
#~ "  -s, --strip         strip symbol tables\n"
#~ "  -S, --suffix=SUFFIX  override the usual backup suffix\n"
#~ "  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
#~ "DIRECTORY\n"
#~ "  -T, --no-target-directory  treat DEST as a normal file\n"
#~ "  -v, --verbose       print the name of each directory as it is created\n"
#~ msgstr ""
#~ "  -p, --preserve-timestamps   以<源>文件的访问/修改时间作为相应的目的\n"
#~ "                      地文件的时间属性\n"
#~ "  -s, --strip         用 strip 命令删除 symbol table，只适用于第一及第二"
#~ "种\n"
#~ "                      使用格式\n"
#~ "  -S, --suffix=后缀   自行指定备份文件的<后缀>\n"
#~ "  -v, --verbose       处理每个文件/目录时输出名称\n"

#~ msgid "invalid format string: %s"
#~ msgstr "无效的格式字符串：%s"

#~ msgid "cannot create temporary file"
#~ msgstr "无法创建临时文件"

#~ msgid "changing security context of %s"
#~ msgstr "更改 %s 的权限"

#~ msgid "Cannot combine --target-directory and --no-target-directory"
#~ msgstr "无法组合使用 --target-directory 和 --no-target-directory"

#~ msgid "cannot run strip"
#~ msgstr "无法执行 strip 命令"

#~ msgid "Usage: %s [OPTION] [FILE]...\n"
#~ msgstr "用法：%s [选项] [文件]...\n"

#~ msgid ""
#~ "  -x, --one-file-system  skip directories on different file systems\n"
#~ "  -X FILE, --exclude-from=FILE  Exclude files that match any pattern in "
#~ "FILE.\n"
#~ "      --exclude=PATTERN  Exclude files that match PATTERN.\n"
#~ "      --max-depth=N     print the total for a directory (or file, with --"
#~ "all)\n"
#~ "                          only if it is N or fewer levels below the "
#~ "command\n"
#~ "                          line argument;  --max-depth=0 is the same as\n"
#~ "                          --summarize\n"
#~ msgstr ""
#~ "  -x, --one-file-system  略过属于其他文件系统的目录\n"
#~ "  -X 文件, --exclude-from=文件  由<文件>读取应排除的文件的样式\n"
#~ "      --exclude=PAT      排除符合指定<样式>的文件\n"
#~ "      --max-depth=N      只显示参数指定的目录 N 层或以内的子目录的总用量\n"
#~ "                         (若使用 --all 选项，也会显示文件的占用量)；\n"
#~ "                         --max-depth=0 的效果等于--summarize\n"

#~ msgid "%ld day"
#~ msgid_plural "%ld days"
#~ msgstr[0] "%ld 天"

#~ msgid ""
#~ "  -u                         with -lt: sort by, and show, access time\n"
#~ "                               with -l: show access time and sort by "
#~ "name\n"
#~ "                               otherwise: sort by access time\n"
#~ "  -U                         do not sort; list entries in directory "
#~ "order\n"
#~ "  -v                         sort by version\n"
#~ msgstr ""
#~ "  -u                         配合 -lt：显示访问时间而且依访问时间排序\n"
#~ "                               配合 -l：显示访问时间但根据名称排序\n"
#~ "                               否则：根据访问时间排序\n"
#~ "  -U                         不进行排序；依文件系统原有的次序列出项目\n"
#~ "  -v                         根据版本进行排序\n"

#~ msgid "cannot create temporary file %s"
#~ msgstr "无法创建临时文件%s"

#~ msgid "Usage: %s [OPTION]... [ FILE ]\n"
#~ msgstr "用法：%s [选项]... [文件]\n"

#~ msgid "Usage: %s [OPTION] NAME...\n"
#~ msgstr "用法：%s [选项] 名称...\n"

#~ msgid "Usage: %s [OPTIONS] FILE [...]\n"
#~ msgstr "用法：%s [选项] 文件 [...]\n"
